{"https://github.com/agnik2019/ADVANCED_DIGITAL_IMG_PROCESSING_COMPUTER_VISION": "#!/usr/bin/env python\n# coding: utf-8\n\n# In[1]:\n\n\n#import modules\nimport numpy as np\nimport cv2 \nimport matplotlib.pyplot as plt\nimport os\nimport math\nfrom PIL import Image\n\n\n# # For reading and conversion to gray.\n\n# In[2]:\n\n\ndef show_image(img_name, img, cmap):\n    ans = int(input('\\nSave(0) or Show(1) image? '))\n    if ans==0:\n        save_dir = './images'\n        if not os.path.exists(save_dir):\n            os.makedirs(save_dir)\n        plt.imsave(save_dir+'/'+img_name, img, cmap=cmap)\n        print('\\nImage saved! Check images folder.')\n    else:\n        plt.axis(\"off\")\n        plt.imshow(img, cmap=cmap)\n        plt.show()\n\n\n# In[3]:\n\n\n# For reading and conversion to gray\nimg = cv2.imread('./images/Butterfly.JPG')\n\ndef convert_to_grayscale(image):\n    B = image[:,:,0]\n    G = image[:,:,1]\n    R = image[:,:,2]\n    img_gray = 0.2989*R + 0.5870*G + 0.1140*B\n    img_gray = img_gray.astype('uint8')\n    return img_gray\n\n\n# ### Adding Gaussian Noise\n\n# In[ ]:\n\n\n# adding gaussian noise\nimg = cv2.imread('./images/Butterfly.JPG')\ndef gaussian_noise(img):\n    mean = 0\n    var = 10\n    sigma = var ** 0.5\n    gaussian = np.random.normal(mean, sigma, (4000, 6000)) #  np.zeros((224, 224), np.float32)\n\n    noisy_image = np.zeros(img.shape, np.float32)\n\n    if len(img.shape) == 2:\n        noisy_image = img + gaussian\n    else:\n        noisy_image[:, :, 0] = img[:, :, 0] + gaussian\n        noisy_image[:, :, 1] = img[:, :, 1] + gaussian\n        noisy_image[:, :, 2] = img[:, :, 2] + gaussian\n\n    cv2.normalize(noisy_image, noisy_image, 0, 255, cv2.NORM_MINMAX, dtype=-1)\n    noisy_image = noisy_image.astype(np.uint8)\n\n    cv2.imwrite(\"./images/img.jpg\", img)\n    cv2.imwrite(\"./images/gaussian.jpg\", gaussian)\n    cv2.imwrite(\"./images/noisy.jpg\", noisy_image)\n    \ngaussian_noise(img)\n\n\n# ### Adding Gaussian Filter\n\n# In[4]:\n\n\ndef isvalid(i, j, r, c):\n    if i >= r or j >= c or i < 0 or j < 0:\n        return 0\n    return 1\ndef gaussian(m, n, sigma = 1):\n    g = np.zeros((m,n))\n    m = m // 2\n    n = n // 2\n    for i in range(-m,m+1):\n        for j in range(-n,n+1):\n            den = 2.0*np.pi*(sigma**2)\n            num = np.exp(-(i**2 + j**2) / (2*(sigma**2)))\n            g[i+m][j+n] = num / den\n    return g\ndef filter2D(image, kernel):\n    r, c = image.shape\n    m, n = kernel.shape\n    filtered = np.zeros(image.shape)\n    dx, dy = m//2, n//2\n    for i in range(r):\n        for j in range(c):\n            psum = 0.0\n            for k in range(i-dx,i+dx+1):\n                for l in range(j-dy,j+dy+1):\n                    if isvalid(k,l,r,c):\n                        psum += image[k][l] * kernel[i-k+dx][j-l+dy]\n            filtered[i][j] = psum\n    return filtered\n\ndef scaling(image, sigmag = 3, k = 5):\n    kernel = gaussian(k,k,sigmag)\n    scaled = filter2D(image,kernel)\n    return scaled\n\n\n# In[5]:\n\n\ndef sharpen(image):\n    laplacian = np.array(\n    [\n        [-1,-1,-1],\n        [-1,8,-1],\n        [-1,-1,-1]\n    ])\n    lap = filter2D(image, laplacian)\n    lap = lap - np.min(lap)\n    lap = lap * (255.0 / np.max(lap))\n    \n    sharpened = image + lap\n    sharpened = sharpened - np.min(sharpened)\n    sharpened = sharpened * (255.0 / np.max(sharpened))\n    \n    return sharpened\n\n\n# ### Adding median filter\n\n# In[ ]:\n\n\ndef median_filter(data, filter_size):\n    temp = []\n    indexer = filter_size // 2\n    data_final = []\n    data_final = np.zeros((len(data),len(data[0])))\n    for i in range(len(data)):\n\n        for j in range(len(data[0])):\n\n            for z in range(filter_size):\n                if i + z - indexer < 0 or i + z - indexer > len(data) - 1:\n                    for c in range(filter_size):\n                        temp.append(0)\n                else:\n                    if j + z - indexer < 0 or j + indexer > len(data[0]) - 1:\n                        temp.append(0)\n                    else:\n                        for k in range(filter_size):\n                            temp.append(data[i + z - indexer][j + k - indexer])\n\n            temp.sort()\n            data_final[i][j] = temp[len(temp) // 2]\n            temp = []\n    return data_final\n\n\n# In[ ]:\n\n\nimg = Image.open('./images/Butterfly.JPG').convert(\"L\")\narr = np.array(img)\nremoved_noise = median_filter(arr, 3) \nimg = Image.fromarray(removed_noise)\nimg.show()\n\n\n# In[6]:\n\n\n# computing psnr\ndef psnr(original, modifief):\n    mse = np.mean((original - modified) ** 2)\n    if mse == 0:\n        return 100\n    PIXEL_MAX = 255.0\n    PSNR = 20 * math.log10(PIXEL_MAX / math.sqrt(mse))\n    return PSNR\n\n\n# # LoG(Laplace of gaussian) on the original image \n\n# In[ ]:\n\n\nrange_inc = lambda start, end: range(start, end+1) #Because this is easier to write and read\n\n\n# In[ ]:\n\n\ndef l_o_g(x, y, sigma):\n    nom = ( (y**2)+(x**2)-2*(sigma**2) )\n    denom = ( (2*math.pi*(sigma**6) ))\n    expo = math.exp( -((x**2)+(y**2))/(2*(sigma**2)) )\n    return nom*expo/denom\n\n\n# In[ ]:\n\n\ndef create_log(sigma, size = 7):\n    w = math.ceil(float(size)*float(sigma))\n    \n    # If the dimension is an even number, make it uneven\n    if(w%2 == 0):\n        print(\"even number detected, incrementing\")\n        w = w + 1\n\n    # Now make the mask\n    l_o_g_mask = []\n\n    w_range = int(math.floor(w/2))\n    print(\"Going from \" + str(-w_range) + \" to \" + str(w_range))\n    for i in range_inc(-w_range, w_range):\n        for j in range_inc(-w_range, w_range):\n            l_o_g_mask.append(l_o_g(i,j,sigma))\n    l_o_g_mask = np.array(l_o_g_mask)\n    l_o_g_mask = l_o_g_mask.reshape(w,w)\n    return l_o_g_mask\n\n\n# In[ ]:\n\n\n# Convolute the mask with the image. May only work for masks of odd dimensions\ndef convolve(image, mask):\n    width = image.shape[1]\n    height = image.shape[0]\n    w_range = int(math.floor(mask.shape[0]/2))\n\n    res_image = np.zeros((height, width))\n\n    # Iterate over every pixel that can be covered by the mask\n    for i in range(w_range,width-w_range):\n        for j in range(w_range,height-w_range):\n            # Then convolute with the mask \n            for k in range_inc(-w_range,w_range):\n                for h in range_inc(-w_range,w_range):\n                    res_image[j, i] += mask[w_range+h,w_range+k]*image[j+h,i+k]\n    return res_image\n\n\n# In[ ]:\n\n\n# Find the zero crossing in the l_o_g image\ndef z_c_test(l_o_g_image):\n    z_c_image = np.zeros(l_o_g_image.shape)\n\n    # Check the sign (negative or positive) of all the pixels around each pixel\n    for i in range(1,l_o_g_image.shape[0]-1):\n        for j in range(1,l_o_g_image.shape[1]-1):\n            neg_count = 0\n            pos_count = 0\n            for a in range_inc(-1, 1):\n                for b in range_inc(-1,1):\n                    if(a != 0 and b != 0):\n                        if(l_o_g_image[i+a,j+b] < 0):\n                            neg_count += 1\n                        elif(l_o_g_image[i+a,j+b] > 0):\n                            pos_count += 1\n\n            # If all the signs around the pixel are the same and they're not all zero, then it's not a zero crossing and not an edge. \n            # Otherwise, copy it to the edge map.\n            z_c = ( (neg_count > 0) and (pos_count > 0) )\n            if(z_c):\n                z_c_image[i,j] = 1\n\n    return z_c_image\n\n\n# In[ ]:\n\n\n# Apply the l_o_g to the image\ndef run_l_o_g(bin_image, sigma_val, size_val):\n    # Create the l_o_g mask\n    print(\"creating mask\")\n    l_o_g_mask = create_log(sigma_val, size_val)\n\n    # Smooth the image by convolving with the LoG mask\n    print(\"smoothing\")\n    l_o_g_image = convolve(bin_image, l_o_g_mask)\n\n    # Display the smoothed imgage\n    blurred = fig.add_subplot(1,4,2)\n    blurred.imshow(l_o_g_image, cmap=cm.gray)\n\n    # Find the zero crossings\n    print(\"finding zero crossings\")\n    z_c_image = z_c_test(l_o_g_image)\n    print(z_c_image)\n\n    #Display the zero crossings\n    edges = fig.add_subplot(1,4,3)\n    edges.imshow(z_c_image, cmap=cm.gray)\n    print(\"displaying\")\n    pylab.show()\n    print ('done updating')\n\n\n# In[ ]:\n\n\ngray_img = convert_to_grayscale(img)\n\n\n# In[ ]:\n\n\nrun_l_o_g(gray_img,5,7)\n\n\n# ## implement using builtin methods (though not asked in question!!)\n\n# In[7]:\n\n\nimg = cv2.imread('./images/Butterfly.JPG')\n\n\n# In[8]:\n\n\nsource = cv2.GaussianBlur(img, (3, 3), 0)\n\n\n# In[9]:\n\n\nsource_gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)\n\n\n# In[10]:\n\n\ndest = cv2.Laplacian(source_gray, cv2.CV_16S, ksize=3)\nabs_dest = cv2.convertScaleAbs(dest)\n\n\n# In[12]:\n\n\nplt.imshow(abs_dest, cmap=\"gray\")\n\n\n# # Perform histogram equalization on the original grayscale image and perform the Otsu thresholding operation\n\n# ## Histogram equalization \n\n# In[13]:\n\n\n# convert image into a numpy array\nimg = convert_to_grayscale(img)\nimg = np.asarray(img)\n\n\n# In[14]:\n\n\n# put pixels in a 1D array by flattening out img array\nflat = img.flatten()\n\n# show the histogram\nplt.hist(flat, bins=50)\n\n\n# In[15]:\n\n\n# create our own histogram function\ndef get_histogram(image, bins):\n    # array with size of bins, set to zeros\n    histogram = np.zeros(bins)\n    \n    # loop through pixels and sum up counts of pixels\n    for pixel in image:\n        histogram[pixel] += 1\n    \n    # return our final result\n    return histogram\n\nhist = get_histogram(flat, 256)\n\nplt.plot(hist)\n\n\n# In[16]:\n\n\n# create our cumulative sum function\ndef cumsum(a):\n    a = iter(a)\n    b = [next(a)]\n    for i in a:\n        b.append(b[-1] + i)\n    return np.array(b)\n\n# execute the fn\ncs = cumsum(hist)\n\n# display the result\nplt.plot(cs)\n\n\n# In[17]:\n\n\n# re-normalize cumsum values to be between 0-255\n\n# numerator & denomenator\nnj = (cs - cs.min()) * 255\nN = cs.max() - cs.min()\n\n# re-normalize the cdf\ncs = nj / N\n\nplt.plot(cs)\n\n\n# In[18]:\n\n\n# cast it back to uint8 since we can't use floating point values in images\ncs = cs.astype('uint8')\n\nplt.plot(cs)\n\n\n# In[19]:\n\n\n# get the value from cumulative sum for every index in flat, and set that as img_new\nimg_new = cs[flat]\n\n# we see a much more evenly distributed histogram\nplt.hist(img_new, bins=50)\n\n\n# In[20]:\n\n\n# put array back into original shape since we flattened it\nimg_new = np.reshape(img_new, img.shape)\nimg_new\n\n\n# In[21]:\n\n\n# set up side-by-side image display\nfig = plt.figure()\nfig.set_figheight(15)\nfig.set_figwidth(15)\n\nfig.add_subplot(1,2,1)\nplt.imshow(img, cmap='gray')\n\n# display the new image\nfig.add_subplot(1,2,2)\nplt.imshow(img_new, cmap='gray')\n\nplt.show(block=True)\n\n\n# # Otsu Thresholding\n# \n\n# In[9]:\n\n\ndef otsu(image):\n\n    hist, _ = np.histogram(image, bins=256, range=(0, 255))\n    total = image.shape[0]*image.shape[1]\n    current_max, threshold = 0, 0\n    sumT, sumF, sumB = 0, 0, 0\n    \n    for i in range(0,256):\n        sumT += i * hist[i]\n    \n    weightB, weightF = 0, 0\n    \n    for i in range(0,256):\n        weightB += hist[i]\n        weightF = total - weightB\n        if weightF == 0: # only background pixels\n            break\n        \n        sumB += i*hist[i]\n        sumF = sumT - sumB\n        \n        meanB = sumB/weightB\n        meanF = sumF/weightF \n        \n        varBetween = weightB*weightF*(meanB-meanF)**2\n        if varBetween > current_max:\n            current_max = varBetween\n            threshold = i  \n    \n    th = image\n    th[th>=threshold]=255\n    th[th<threshold]=0\n    \n    return th\n\n\n# In[23]:\n\n\nimg = cv2.imread('./images/Butterfly.JPG')\nimg = convert_to_grayscale(img)\nblur = scaling(img, 3, 5)\nsharpened = sharpen(blur)\n\n\n# In[24]:\n\n\notsu_thresh = otsu(sharpened)\n\n\n# In[27]:\n\n\nshow_image('otsu.png', otsu_thresh, cmap='gray')\n\n\n# ## Perform Harris corner detection on the gray image and display the detected corners\n\n# In[6]:\n\n\ndef edge_sobel(image):\n    Sx = np.array([\n        [-1,0,1],\n        [-2,0,2],\n        [-1,0,1]\n    ])\n    Sx = Sx / 8.0\n    \n    Sy = np.array([\n        [-1,-2,-1],\n        [0,0,0],\n        [1,2,1]\n    ])\n    Sy = Sy / 8.0\n    \n    Ix = filter2D(image, Sx)\n    Iy = filter2D(image, Sy)\n    \n    grads = np.sqrt(Ix**2 + Iy**2)\n    return Ix, Iy, grads\n\n\n# In[7]:\n\n\ndef harris(img, threshold=1e-2, nms_size=10):\n    \n    img_gray = convert_to_grayscale(img)\n    blur = scaling(img_gray, 3, 5)\n    otsu_thresh = otsu(blur)\n    \n    Ix, Iy, _ = edge_sobel(otsu_thresh)\n    Ixx = scaling(Ix*Ix, 3, 5)\n    Ixy = scaling(Ix*Iy, 3, 5)\n    Iyy = scaling(Iy*Iy, 3, 5)\n    \n    detA = Ixx*Iyy - Ixy**2\n    traceA = Ixx + Iyy\n    Rs = detA - 0.05*traceA**2\n    \n    img_copy_for_corners = np.copy(img)    \n    \n    # thresholding\n    Rs = Rs * (Rs > (threshold * Rs.max())) * (Rs > 0)\n    \n    # Non maxima suppression\n    rows, columns = np.nonzero(Rs)\n    new_Rs = np.zeros(Rs.shape)\n    for r,c in zip(rows,columns):\n        minr = max(0, r - nms_size / 2)\n        maxr = min(img.shape[0], minr + nms_size)\n        minc = max(0, c - nms_size / 2)\n        maxc = min(img.shape[1], minc + nms_size)\n        if Rs[r,c] == Rs[int(minr):int(maxr),int(minc):int(maxc)].max():\n            new_Rs[r,c] = Rs[r,c]\n   \n    # Corners found\n    corners_x,corners_y = np.nonzero(new_Rs)\n\n    for x,y in zip(corners_x, corners_y):\n        img_copy_for_corners=cv2.circle(img_copy_for_corners, (y,x), 2, (255,0,0), -1)\n        \n    return img_copy_for_corners\n\n\n# In[10]:\n\n\nimgcv = cv2.imread('./images/Butterfly.JPG')\nharris_img = harris(imgcv, 1e-2, 10)\n\n\n# In[11]:\n\n\nshow_image('harris.png', harris_img, cmap=None)\n\n\n# In[ ]:\n\n\n\n\n#import modules\n import numpy as np\n import cv2 \n import matplotlib.pyplot as plt\n import os\n import math\n from PIL import Image\n# For reading and conversion to gray.def show_image(img_name, img, cmap):\n     ans = int(input('\\nSave(0) or Show(1) image? '))\n     if ans==0:\n         save_dir = './images'\n         if not os.path.exists(save_dir):\n             os.makedirs(save_dir)\n         plt.imsave(save_dir+'/'+img_name, img, cmap=cmap)\n         print('\\nImage saved! Check images folder.')\n     else:\n         plt.axis(\"off\")\n         plt.imshow(img, cmap=cmap)\n         plt.show()# For reading and conversion to gray\n img = cv2.imread('./images/Butterfly.JPG')\n \n def convert_to_grayscale(image):\n     B = image[:,:,0]\n     G = image[:,:,1]\n     R = image[:,:,2]\n     img_gray = 0.2989*R + 0.5870*G + 0.1140*B\n     img_gray = img_gray.astype('uint8')\n     return img_gray### Adding Gaussian Noise# adding gaussian noise\n img = cv2.imread('./images/Butterfly.JPG')\n def gaussian_noise(img):\n     mean = 0\n     var = 10\n     sigma = var ** 0.5\n     gaussian = np.random.normal(mean, sigma, (4000, 6000)) #  np.zeros((224, 224), np.float32)\n \n     noisy_image = np.zeros(img.shape, np.float32)\n \n     if len(img.shape) == 2:\n         noisy_image = img + gaussian\n     else:\n         noisy_image[:, :, 0] = img[:, :, 0] + gaussian\n         noisy_image[:, :, 1] = img[:, :, 1] + gaussian\n         noisy_image[:, :, 2] = img[:, :, 2] + gaussian\n \n     cv2.normalize(noisy_image, noisy_image, 0, 255, cv2.NORM_MINMAX, dtype=-1)\n     noisy_image = noisy_image.astype(np.uint8)\n \n     cv2.imwrite(\"./images/img.jpg\", img)\n     cv2.imwrite(\"./images/gaussian.jpg\", gaussian)\n     cv2.imwrite(\"./images/noisy.jpg\", noisy_image)\n     \n gaussian_noise(img)### Adding Gaussian Filterdef isvalid(i, j, r, c):\n     if i >= r or j >= c or i < 0 or j < 0:\n         return 0\n     return 1\n def gaussian(m, n, sigma = 1):\n     g = np.zeros((m,n))\n     m = m // 2\n     n = n // 2\n     for i in range(-m,m+1):\n         for j in range(-n,n+1):\n             den = 2.0*np.pi*(sigma**2)\n             num = np.exp(-(i**2 + j**2) / (2*(sigma**2)))\n             g[i+m][j+n] = num / den\n     return g\n def filter2D(image, kernel):\n     r, c = image.shape\n     m, n = kernel.shape\n     filtered = np.zeros(image.shape)\n     dx, dy = m//2, n//2\n     for i in range(r):\n         for j in range(c):\n             psum = 0.0\n             for k in range(i-dx,i+dx+1):\n                 for l in range(j-dy,j+dy+1):\n                     if isvalid(k,l,r,c):\n                         psum += image[k][l] * kernel[i-k+dx][j-l+dy]\n             filtered[i][j] = psum\n     return filtered\n \n def scaling(image, sigmag = 3, k = 5):\n     kernel = gaussian(k,k,sigmag)\n     scaled = filter2D(image,kernel)\n     return scaleddef sharpen(image):\n     laplacian = np.array(\n     [\n         [-1,-1,-1],\n         [-1,8,-1],\n         [-1,-1,-1]\n     ])\n     lap = filter2D(image, laplacian)\n     lap = lap - np.min(lap)\n     lap = lap * (255.0 / np.max(lap))\n     \n     sharpened = image + lap\n     sharpened = sharpened - np.min(sharpened)\n     sharpened = sharpened * (255.0 / np.max(sharpened))\n     \n     return sharpened### Adding median filterdef median_filter(data, filter_size):\n     temp = []\n     indexer = filter_size // 2\n     data_final = []\n     data_final = np.zeros((len(data),len(data[0])))\n     for i in range(len(data)):\n \n         for j in range(len(data[0])):\n \n             for z in range(filter_size):\n                 if i + z - indexer < 0 or i + z - indexer > len(data) - 1:\n                     for c in range(filter_size):\n                         temp.append(0)\n                 else:\n                     if j + z - indexer < 0 or j + indexer > len(data[0]) - 1:\n                         temp.append(0)\n                     else:\n                         for k in range(filter_size):\n                             temp.append(data[i + z - indexer][j + k - indexer])\n \n             temp.sort()\n             data_final[i][j] = temp[len(temp) // 2]\n             temp = []\n     return data_finalimg = Image.open('./images/Butterfly.JPG').convert(\"L\")\n arr = np.array(img)\n removed_noise = median_filter(arr, 3) \n img = Image.fromarray(removed_noise)\n img.show()# computing psnr\n def psnr(original, modifief):\n     mse = np.mean((original - modified) ** 2)\n     if mse == 0:\n         return 100\n     PIXEL_MAX = 255.0\n     PSNR = 20 * math.log10(PIXEL_MAX / math.sqrt(mse))\n     return PSNR# LoG(Laplace of gaussian) on the original image range_inc = lambda start, end: range(start, end+1) #Because this is easier to write and readdef l_o_g(x, y, sigma):\n     nom = ( (y**2)+(x**2)-2*(sigma**2) )\n     denom = ( (2*math.pi*(sigma**6) ))\n     expo = math.exp( -((x**2)+(y**2))/(2*(sigma**2)) )\n     return nom*expo/denomdef create_log(sigma, size = 7):\n     w = math.ceil(float(size)*float(sigma))\n     \n     # If the dimension is an even number, make it uneven\n     if(w%2 == 0):\n         print(\"even number detected, incrementing\")\n         w = w + 1\n \n     # Now make the mask\n     l_o_g_mask = []\n \n     w_range = int(math.floor(w/2))\n     print(\"Going from \" + str(-w_range) + \" to \" + str(w_range))\n     for i in range_inc(-w_range, w_range):\n         for j in range_inc(-w_range, w_range):\n             l_o_g_mask.append(l_o_g(i,j,sigma))\n     l_o_g_mask = np.array(l_o_g_mask)\n     l_o_g_mask = l_o_g_mask.reshape(w,w)\n     return l_o_g_mask# Convolute the mask with the image. May only work for masks of odd dimensions\n def convolve(image, mask):\n     width = image.shape[1]\n     height = image.shape[0]\n     w_range = int(math.floor(mask.shape[0]/2))\n \n     res_image = np.zeros((height, width))\n \n     # Iterate over every pixel that can be covered by the mask\n     for i in range(w_range,width-w_range):\n         for j in range(w_range,height-w_range):\n             # Then convolute with the mask \n             for k in range_inc(-w_range,w_range):\n                 for h in range_inc(-w_range,w_range):\n                     res_image[j, i] += mask[w_range+h,w_range+k]*image[j+h,i+k]\n     return res_image# Find the zero crossing in the l_o_g image\n def z_c_test(l_o_g_image):\n     z_c_image = np.zeros(l_o_g_image.shape)\n \n     # Check the sign (negative or positive) of all the pixels around each pixel\n     for i in range(1,l_o_g_image.shape[0]-1):\n         for j in range(1,l_o_g_image.shape[1]-1):\n             neg_count = 0\n             pos_count = 0\n             for a in range_inc(-1, 1):\n                 for b in range_inc(-1,1):\n                     if(a != 0 and b != 0):\n                         if(l_o_g_image[i+a,j+b] < 0):\n                             neg_count += 1\n                         elif(l_o_g_image[i+a,j+b] > 0):\n                             pos_count += 1\n \n             # If all the signs around the pixel are the same and they're not all zero, then it's not a zero crossing and not an edge. \n             # Otherwise, copy it to the edge map.\n             z_c = ( (neg_count > 0) and (pos_count > 0) )\n             if(z_c):\n                 z_c_image[i,j] = 1\n \n     return z_c_image# Apply the l_o_g to the image\n def run_l_o_g(bin_image, sigma_val, size_val):\n     # Create the l_o_g mask\n     print(\"creating mask\")\n     l_o_g_mask = create_log(sigma_val, size_val)\n \n     # Smooth the image by convolving with the LoG mask\n     print(\"smoothing\")\n     l_o_g_image = convolve(bin_image, l_o_g_mask)\n \n     # Display the smoothed imgage\n     blurred = fig.add_subplot(1,4,2)\n     blurred.imshow(l_o_g_image, cmap=cm.gray)\n \n     # Find the zero crossings\n     print(\"finding zero crossings\")\n     z_c_image = z_c_test(l_o_g_image)\n     print(z_c_image)\n \n     #Display the zero crossings\n     edges = fig.add_subplot(1,4,3)\n     edges.imshow(z_c_image, cmap=cm.gray)\n     print(\"displaying\")\n     pylab.show()\n     print ('done updating')gray_img = convert_to_grayscale(img)run_l_o_g(gray_img,5,7)## implement using builtin methods (though not asked in question!!)img = cv2.imread('./images/Butterfly.JPG')source = cv2.GaussianBlur(img, (3, 3), 0)source_gray = cv2.cvtColor(source, cv2.COLOR_BGR2GRAY)dest = cv2.Laplacian(source_gray, cv2.CV_16S, ksize=3)\n abs_dest = cv2.convertScaleAbs(dest)plt.imshow(abs_dest, cmap=\"gray\")# Perform histogram equalization on the original grayscale image and perform the Otsu thresholding operation## Histogram equalization # convert image into a numpy array\n img = convert_to_grayscale(img)\n img = np.asarray(img)# put pixels in a 1D array by flattening out img array\n flat = img.flatten()\n \n # show the histogram\n plt.hist(flat, bins=50)# create our own histogram function\n def get_histogram(image, bins):\n     # array with size of bins, set to zeros\n     histogram = np.zeros(bins)\n     \n     # loop through pixels and sum up counts of pixels\n     for pixel in image:\n         histogram[pixel] += 1\n     \n     # return our final result\n     return histogram\n \n hist = get_histogram(flat, 256)\n \n plt.plot(hist)# create our cumulative sum function\n def cumsum(a):\n     a = iter(a)\n     b = [next(a)]\n     for i in a:\n         b.append(b[-1] + i)\n     return np.array(b)\n \n # execute the fn\n cs = cumsum(hist)\n \n # display the result\n plt.plot(cs)# re-normalize cumsum values to be between 0-255\n \n # numerator & denomenator\n nj = (cs - cs.min()) * 255\n N = cs.max() - cs.min()\n \n # re-normalize the cdf\n cs = nj / N\n \n plt.plot(cs)# cast it back to uint8 since we can't use floating point values in images\n cs = cs.astype('uint8')\n \n plt.plot(cs)# get the value from cumulative sum for every index in flat, and set that as img_new\n img_new = cs[flat]\n \n # we see a much more evenly distributed histogram\n plt.hist(img_new, bins=50)# put array back into original shape since we flattened it\n img_new = np.reshape(img_new, img.shape)\n img_new# set up side-by-side image display\n fig = plt.figure()\n fig.set_figheight(15)\n fig.set_figwidth(15)\n \n fig.add_subplot(1,2,1)\n plt.imshow(img, cmap='gray')\n \n # display the new image\n fig.add_subplot(1,2,2)\n plt.imshow(img_new, cmap='gray')\n \n plt.show(block=True)# Otsu Thresholding\ndef otsu(image):\n \n     hist, _ = np.histogram(image, bins=256, range=(0, 255))\n     total = image.shape[0]*image.shape[1]\n     current_max, threshold = 0, 0\n     sumT, sumF, sumB = 0, 0, 0\n     \n     for i in range(0,256):\n         sumT += i * hist[i]\n     \n     weightB, weightF = 0, 0\n     \n     for i in range(0,256):\n         weightB += hist[i]\n         weightF = total - weightB\n         if weightF == 0: # only background pixels\n             break\n         \n         sumB += i*hist[i]\n         sumF = sumT - sumB\n         \n         meanB = sumB/weightB\n         meanF = sumF/weightF \n         \n         varBetween = weightB*weightF*(meanB-meanF)**2\n         if varBetween > current_max:\n             current_max = varBetween\n             threshold = i  \n     \n     th = image\n     th[th>=threshold]=255\n     th[th<threshold]=0\n     \n     return thimg = cv2.imread('./images/Butterfly.JPG')\n img = convert_to_grayscale(img)\n blur = scaling(img, 3, 5)\n sharpened = sharpen(blur)otsu_thresh = otsu(sharpened)show_image('otsu.png', otsu_thresh, cmap='gray')## Perform Harris corner detection on the gray image and display the detected cornersdef edge_sobel(image):\n     Sx = np.array([\n         [-1,0,1],\n         [-2,0,2],\n         [-1,0,1]\n     ])\n     Sx = Sx / 8.0\n     \n     Sy = np.array([\n         [-1,-2,-1],\n         [0,0,0],\n         [1,2,1]\n     ])\n     Sy = Sy / 8.0\n     \n     Ix = filter2D(image, Sx)\n     Iy = filter2D(image, Sy)\n     \n     grads = np.sqrt(Ix**2 + Iy**2)\n     return Ix, Iy, gradsdef harris(img, threshold=1e-2, nms_size=10):\n     \n     img_gray = convert_to_grayscale(img)\n     blur = scaling(img_gray, 3, 5)\n     otsu_thresh = otsu(blur)\n     \n     Ix, Iy, _ = edge_sobel(otsu_thresh)\n     Ixx = scaling(Ix*Ix, 3, 5)\n     Ixy = scaling(Ix*Iy, 3, 5)\n     Iyy = scaling(Iy*Iy, 3, 5)\n     \n     detA = Ixx*Iyy - Ixy**2\n     traceA = Ixx + Iyy\n     Rs = detA - 0.05*traceA**2\n     \n     img_copy_for_corners = np.copy(img)    \n     \n     # thresholding\n     Rs = Rs * (Rs > (threshold * Rs.max())) * (Rs > 0)\n     \n     # Non maxima suppression\n     rows, columns = np.nonzero(Rs)\n     new_Rs = np.zeros(Rs.shape)\n     for r,c in zip(rows,columns):\n         minr = max(0, r - nms_size / 2)\n         maxr = min(img.shape[0], minr + nms_size)\n         minc = max(0, c - nms_size / 2)\n         maxc = min(img.shape[1], minc + nms_size)\n         if Rs[r,c] == Rs[int(minr):int(maxr),int(minc):int(maxc)].max():\n             new_Rs[r,c] = Rs[r,c]\n    \n     # Corners found\n     corners_x,corners_y = np.nonzero(new_Rs)\n \n     for x,y in zip(corners_x, corners_y):\n         img_copy_for_corners=cv2.circle(img_copy_for_corners, (y,x), 2, (255,0,0), -1)\n         \n     return img_copy_for_cornersimgcv = cv2.imread('./images/Butterfly.JPG')\n harris_img = harris(imgcv, 1e-2, 10)\nshow_image('harris.png', harris_img, cmap=None)import tkinter as tk\nfrom tkinter import ttk\nimport os\n\nwin=tk.Tk()\nwin.title(\"Assignment 2\")\nwin.geometry(\"500x400\")\n\n#T = tk.Text(win, height = 35, width = 70)\n \n# Create label\nl = tk.Label(win, text = \"Please select 8 points for \\n transformed image & affine rectification\")\nl.config(font =(\"Courier\", 14))\n\ndef run1():\n    os.system(\"python qn1.py\")\ndef run2():\n    os.system(\"python qn2_corner.py\")\ndef run3():\n    os.system(\"python qn2_edge.py\")\ndef run4():\n    os.system(\"python qn3.py\")\ndef run5():\n    os.system(\"python qn4_tk.py\")   \n\nbutton1=ttk.Button(win,text=\"Foreground extraction\",command=run1)\nbutton2=ttk.Button(win,text=\"Identify Corner Points\",command=run2)\nbutton3=ttk.Button(win,text=\"Identify Boundary Edges\",command=run3)\nbutton4=ttk.Button(win,text=\"displaying the transformed image\",command=run4)\nbutton5=ttk.Button(win,text=\"Affine rectification\",command=run5)\n\nl.pack()\n#T.pack()\nbutton1.pack(pady=10)\nbutton2.pack(pady=10)\nbutton3.pack(pady=10)\nbutton4.pack(pady=10)\nbutton5.pack(pady=10)\n\nwin.mainloop()import numpy as np\nimport cv2\nfrom matplotlib import pyplot as plt\n  \nimgname = \"PataChitraPuri2.jpg\"\nimage = cv2.imread(imgname)\n  \n\nmask = np.zeros(image.shape[:2], np.uint8)\n  \n\nbackgroundModel = np.zeros((1, 65), np.float64)\nforegroundModel = np.zeros((1, 65), np.float64)\n  \n\nrectangle = [20, 50, 1000, 381]\n  \n\ncv2.grabCut(image, mask, rectangle, \n            backgroundModel, foregroundModel,\n            3, cv2.GC_INIT_WITH_RECT)\n  \n\n\nmask2 = np.where((mask == 2)|(mask == 0), 0, 1).astype('uint8')\n  \n\nimage = image * mask2[:, :, np.newaxis]\n  \nplt.imshow(image)\nplt.colorbar()\nplt.show()import copy as cp\nimport cv2\nimport numpy as np\nimport sys\nimport os\n\ndef harris_corners(image):\n    gray_img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    gray_img = np.float32(gray_img)\n\n    corners_img = cv2.cornerHarris(gray_img, 3, 3, 0.04)\n\n    image[corners_img > 0.001 * corners_img.max()] = [255, 255, 0]\n\n    return image\n\ndef shi_tomasi(image):\n    gray_img = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n    corners_img = cv2.goodFeaturesToTrack(gray_img, 1200, 0.01, 10)\n    # corners_img = np.int0(corners_img)\n\n    blank_img = np.zeros((image.shape[0], image.shape[1], 3), np.uint8)\n\n    for corners in corners_img:\n        x, y = corners.ravel()\n        cv2.circle(image, (int(x), int(y)), 3, [255, 255, 0], -1)\n        cv2.circle(blank_img, (int(x), int(y)), 2, [255, 255, 0], -1)\n\n    return image, blank_img\n\n\ndef find_corner(img):\n    img_dup = cp.copy(img)\n    img_dup1 = cp.copy(img)\n\n    harris = harris_corners(img)\n    shitomasi, silhouette = shi_tomasi(img_dup)\n\n    # Display different corner detection methods side by side\n\n    out1 = np.concatenate((harris, shitomasi), axis=1)\n    out2 = np.concatenate((img_dup1, silhouette), axis=1)\n\n    out3 = np.concatenate((out1, out2), axis=0)\n    cv2.imshow('Corners', out3)\n    return harris, shitomasi, silhouette, out3\n\n\n\n    # loading image\nimgname = \"PataChitraPuri_1.jpg\"\nimg = cv2.imread(imgname)\n\nharris, shitomasi, silhoutte, out3 = find_corner(img)\ncv2.imwrite('qn2_corner_detect.jpg', out3)\ncv2.waitKey(0)\ncv2.destroyAllWindows()import cv2\nimport sys\nimport os\n\n\nimgname = \"PataChitraPuri_1.jpg\"\nimage = cv2.imread(imgname)\n\n\n\ngray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n\n# Gaussian Blurring to remove high frequency noise helping in\n# Contour Detection\ngray = cv2.GaussianBlur(gray, (5, 5), 0)\n# Canny Edge Detection\nedged = cv2.Canny(gray, 75, 200)\n\n# cv2.imshow(\"Image\", image)\ncv2.imshow(\"Edged\", edged)\ncv2.imwrite('Edged.jpg', edged)\n# finding the contours in the edged image, keeping only the\n# largest ones, and initialize the screen contour\ncnts = cv2.findContours(edged.copy(), cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)\n\n\n\n# Handling due to different version of OpenCV\ncnts = cnts[0] if len(cnts) == 2 else cnts[1]\n\n# Taking only the top 5 contours by Area\ncnts = sorted(cnts, key=cv2.contourArea, reverse=True)[:5]\n\n\nfor c in cnts:\n\n    # Calculates a contour perimeter or a curve length\n    peri = cv2.arcLength(c, True)\n    approx = cv2.approxPolyDP(c, 0.1 * peri, True)  # 0.02\n\n    # if our approximated contour has four points, then we\n    # can assume that we have found our screen\n    screenCnt = approx\n    if len(approx) == 4:\n        screenCnt = approx\n        break\n\ncv2.drawContours(image, [screenCnt], -1, (0, 255, 0), 2)\ncv2.imshow(\"Boundary\", image)\ncv2.imwrite('Boundary-' + imgname[0:2] + '.jpg', image)\ncv2.waitKey(0)\ncv2.destroyAllWindows()import cv2\nimport numpy as np\nfrom tkinter import *\nfrom PIL import ImageTk, Image\n\ntinker_root = Tk()\ntinker_root.resizable(0, 0)\ntinker_root.title(\"Main Window\")\n\n# Change input file name here\nfilename = 'PataChitraPuri_1.jpg'\nimg = cv2.imread(filename, cv2.IMREAD_COLOR)\n\nsource_vertices = []\ndestination_vertices = []\nimage_patch = None\nclick_count = 0\n\n# Image read for displaying in GUI Window\nimage = Image.open(filename)\nwindow_image = ImageTk.PhotoImage(image)\n\n# Creating the canvas object\ncanvas = Canvas(tinker_root, bg=\"black\", width=window_image.width(), height=window_image.height())\ncanvas.pack(expand=YES, fill=BOTH)\ncanvas_image = canvas.create_image(0, 0, image=window_image, anchor=NW)\n\n\ndef handle_source_point(coordinates):\n    global source_vertices\n\n    canvas.create_oval(coordinates.x - 3, coordinates.y - 3, coordinates.x + 3, coordinates.y + 3, fill=\"red\")\n    source_vertices.append(np.array([coordinates.x, coordinates.y]))\n\n\ndef handle_destination_point(coordinates):\n    global destination_vertices\n\n    canvas.create_oval(coordinates.x - 3, coordinates.y - 3, coordinates.x + 3, coordinates.y + 3, fill=\"blue\")\n    destination_vertices.append(np.array([coordinates.x, coordinates.y]))\n\n\ndef get_image_patch():\n    global image_patch\n    global img\n\n    dummy_image = np.zeros(img.shape, dtype=img.dtype)\n    cv2.fillPoly(dummy_image, np.array([source_vertices]), (1, 1, 1))\n    image_patch = img * dummy_image\n    # print image_patch\n\n\ndef transform_and_paste_patch():\n    global img\n    global image\n    global image_patch\n    global window_image\n    global canvas_image\n\n    dummy_image = np.ones(img.shape, dtype=img.dtype)\n    cv2.fillPoly(dummy_image, np.array([destination_vertices]), (0, 0, 0))\n    img = img * dummy_image\n    # Using in built function from opencv to find homography\n    homography = cv2.findHomography(np.array(source_vertices), np.array(destination_vertices))[0]\n    print(homography)\n    transformed_image = cv2.warpPerspective(image_patch, homography, (img.shape[1], img.shape[0]))\n    img = img + transformed_image\n\n    image = Image.frombytes('RGB', (img.shape[1], img.shape[0]), cv2.cvtColor(img, cv2.COLOR_BGR2RGB))\n    image.save(\"output.jpg\")\n    window_image = ImageTk.PhotoImage(image)\n    canvas_image = canvas.itemconfig(canvas_image, image=window_image)\n    canvas.pack()\n\n\ndef save_output():\n    image.save(\"output.jpg\")\n\n\ndef on_click(coordinates):\n    global click_count\n\n    click_count += 1\n    if click_count <= 4:\n        # vertex selected is of source\n        handle_source_point(coordinates)\n    elif click_count <= 8:\n        # vertex selected is of destination\n        handle_destination_point(coordinates)\n    else:\n        # Image patch already transformed\n        return\n\n    if click_count == 4:\n        # Store the patch of image to be transformed\n        get_image_patch()\n    if click_count == 8:\n        transform_and_paste_patch()\n        save_output()\n\n\n# Adding on_click event to left mouse button click\ncanvas.bind(\"<Button-1>\", on_click)\ntinker_root.mainloop()\nimport cv2\nimport numpy as np\nfrom tkinter import *\nfrom PIL import ImageTk, Image\n\ntinker_root = Tk()\ntinker_root.resizable(0, 0)\ntinker_root.title(\"Main Window\")\n\n# Change input file name here\nfilename = 'PataChitraPuri_1.jpg'\nimg = cv2.imread(filename, cv2.IMREAD_COLOR)\n\nlist1 = []\nlist2 = []\nimage_patch = None\nclick_count = 0\n\n# Image read for displaying in GUI Window\nimage = Image.open(filename)\nwindow_image = ImageTk.PhotoImage(image)\n\n# Creating the canvas object\ncanvas = Canvas(tinker_root, bg=\"black\", width=window_image.width(), height=window_image.height())\ncanvas.pack(expand=YES, fill=BOTH)\ncanvas_image = canvas.create_image(0, 0, image=window_image, anchor=NW)\n\n\n# affine rectification\n# This function returns the vanishing line equation\ndef vanishingline(list1, list2):\n    \n    # Equation of lines\n    l1 = np.cross([list1[0][0], list1[0][1], 1], [list1[1][0], list1[1][1], 1])\n    l2 = np.cross([list1[2][0], list1[2][1], 1], [list1[3][0], list1[3][1], 1])\n    p1 = np.cross([list2[0][0], list2[0][1], 1], [list2[1][0], list2[1][1], 1])\n    p2 = np.cross([list2[2][0], list2[2][1], 1], [list2[3][0], list2[3][1], 1])\n    \n    temp1 = np.cross(l1,l2)\n    temp2 = np.cross(p1,p2)\n    \n    # Vanishing Points\n    v1 = temp1/temp1[2]\n    v2 = temp2/temp2[2]\n    print(v1, v2)\n    \n    return np.cross(v1, v2)\n    \n\n\n# Returns the affine rectification homography matrix\ndef affineHom(line):    \n    return np.array([[1, 0, 0], [0, 1, 0], [line[0]/line[2], line[1]/line[2], 1]])\n\n\n\ndef parallel_line_1(coordinates):\n    global source_vertices\n\n    canvas.create_oval(coordinates.x - 3, coordinates.y - 3, coordinates.x + 3, coordinates.y + 3, fill=\"red\")\n    list1.append([coordinates.x, coordinates.y])\n\n\ndef parallel_line_2(coordinates):\n    global destination_vertices\n\n    canvas.create_oval(coordinates.x - 3, coordinates.y - 3, coordinates.x + 3, coordinates.y + 3, fill=\"blue\")\n    list2.append([coordinates.x, coordinates.y])\n\ndef main_helper():\n    global img\n    global image\n    global image_patch\n    global window_image\n    global canvas_image\n    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\n    size = gray.shape\n    sizeNew = (size[1], size[0])\n    vLine = vanishingline(list1, list2)\n    HomMatrix = np.float32(affineHom(vLine))\n    img_affine = cv2.warpPerspective(img,HomMatrix, sizeNew)\n    image = Image.frombytes('RGB', (img_affine.shape[1], img_affine.shape[0]), cv2.cvtColor(img_affine, cv2.COLOR_BGR2RGB))\n    image.save(\"AffineRectifiedImage.jpg\")\n    window_image = ImageTk.PhotoImage(image)\n    canvas_image = canvas.itemconfig(canvas_image, image=window_image)\n    canvas.pack()\n\ndef save_output():\n    image.save(\"AffineRectifiedImage.jpg\")\n\n\ndef on_click(coordinates):\n    global click_count\n\n    click_count += 1\n    if click_count <= 4:\n        # vertex selected is of source\n        parallel_line_1(coordinates)\n    elif click_count <= 8:\n        # vertex selected is of destination\n        parallel_line_2(coordinates)\n    else:\n        # Image patch already transformed\n        return\n\n    if click_count == 8:\n        main_helper()\n        save_output()\n\n\n# Adding on_click event to left mouse button click\ncanvas.bind(\"<Button-1>\", on_click)\ntinker_root.mainloop()\n### Importing necessary modules!pip install colour-science# importing required libraries\n import numpy as np\n import cv2\n import matplotlib.pyplot as plt\n import matplotlib.image as img\n import pandas as pd # for reading csv files\n \n # for plotting chromatic diagram\n import colour\n from colour.plotting import *### Displaying the imageimg_deer = img.imread('Deer.jpg')\n # displaying the shape of the image\n print(img_deer.shape)\n # displaying the modified image\n plt.imshow(img_deer)img_tiger = img.imread('Tiger.jpg')\n # displaying the shape of the image\n print(img_tiger.shape)\n # displaying the modified image\n plt.imshow(img_tiger)### Convert image to hsv imagehsvImg1 = cv2.cvtColor(img_deer, cv2.COLOR_BGR2HSV)\n plt.imshow(hsvImg1)hsvImg2 = cv2.cvtColor(img_tiger, cv2.COLOR_BGR2HSV)\n plt.imshow(hsvImg2)## Maximally Saturated Imagedef maxSat(img):\n     # convert it to hsv\n     hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n     max_sat_img = hsv_img\n     # making saturation value maximum\n     max_sat_img[:,:,1] = 255\n     # convert back to rgb image for displaying\n     color_img = cv2.cvtColor(max_sat_img, cv2.COLOR_HSV2BGR)\n     return color_img\n     deer_maxsat = maxSat(img_deer)plt.title('maximally saturated deer')\n plt.imshow(deer_maxsat)\ntiger_maxsat = maxSat(img_tiger)plt.title('maximally saturated tiger')\n plt.imshow(tiger_maxsat)## Desaturated Image def deSat(img, val):\n     # convert it to hsv\n     hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n     max_sat_img = hsv_img\n     # increase the value of saturation by some quantity\n     if val> 255:\n         print(\"Max pixel value is 255\")\n     max_sat_img[:,:,1] = max_sat_img[:,:,1] + val\n     # convert back to bgr image for displaying\n     de_sat_img = cv2.cvtColor(max_sat_img, cv2.COLOR_HSV2BGR)\n     return de_sat_imgdeer_desat = deSat(img_deer,30)plt.title('Desaturated deer')\n \n plt.imshow(deer_desat)tiger_desat = deSat(img_tiger,30)plt.title('Desaturated tiger')\n plt.imshow(tiger_desat)val = int(input(\"Enter the pixel value(value should be less than 255):\"))\n plt.imshow(deSat(img_deer,val))# cv2.imshow('Desaturated Image', deSat(img,100))\n # cv2.waitKey(0)\n # cv2.destroyAllWindows()val = int(input(\"Enter the pixel value(value should be less than 255):\"))\n plt.imshow(deSat(img_tiger,val))## Saturated Desaturated Imagedef satdeSat(img, val1,val2):\n     # convert it to hsv\n     hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)\n     max_sat_img = hsv_img\n     # increase the value pf saturation by a quantity\n     # decrease it by some other quantity\n     max_sat_img[:,:,1] = max_sat_img[:,:,1] + val1 - val2\n     max_sat_img = cv2.cvtColor(max_sat_img, cv2.COLOR_HSV2RGB)\n     return max_sat_imgdeer_satdesat = satdeSat(img_deer,90,20)plt.imshow(deer_satdesat)tiger_satdesat = satdeSat(img_tiger,90,20)plt.imshow(tiger_satdesat)val1 = int(input(\"Enter the  pixel value to increase:\"))\n val2 = int(input(\"Enter the  pixel value to decrease:\"))\n \n plt.imshow(satdeSat(img_deer,val1,val2))val3 = int(input(\"Enter the  pixel value to increase:\"))\n val4 = int(input(\"Enter the  pixel value to decrease:\"))\n \n plt.imshow(satdeSat(img_tiger,val3,val4))# Showing chromaticity plots### Reading data from csv file# Give the location of the file\n df = pd.read_csv(\"ciexyz31_1.csv\")\n \n df.head()df.columns = ['wavelength','x','y','z']\n df_new = df[[\"x\",\"y\",\"z\"]]\n rgb_arr = df_new.to_numpy()### Just displaying the CIE chromaticity graph . Though not asked in questionRGB = colour.models.eotf_inverse_sRGB(rgb_arr)\n \n plot_RGB_chromaticities_in_chromaticity_diagram_CIE1931(RGB)\n## Calculating xy values from xyz imagedef get_xy():\n     fp = open('ciexyz31_1.csv')\n     rows = fp.readlines()\n     X, Y, Z, xis, yis = [], [], [], [], []\n     for row in rows:\n         row = [float(i.strip()) for i in row.split(',')]\n         X.append(row[1])\n         Y.append(row[2])\n         Z.append(row[3])\n     for i in range(len(X)):\n         xis.append(X[i] / (X[i] + Y[i] + Z[i]))\n         yis.append(Y[i] / (X[i] + Y[i] + Z[i]))\n     return xis,yisdef valueNormalize(img):\n     x = list()\n     y = list()\n     for i in range(img.shape[0]):\n         for j in range(img.shape[1]):\n             a, b, c = int(img[i, j, 0]), int(img[i, j, 1]), int(img[i, j, 2])\n             sum = float(a+b+c)\n             if sum == 0:\n                 x.append(0)\n                 y.append(0)\n             else:\n                 x.append(a / sum)\n                 y.append(b / sum)\n     return x, yxi, yi = get_xy()deer_xyz = cv2.cvtColor(img_deer, cv2.COLOR_BGR2XYZ)\n deer_xyz1 = cv2.cvtColor(deer_maxsat, cv2.COLOR_BGR2XYZ)\n deer_xyz2 = cv2.cvtColor(deer_desat, cv2.COLOR_BGR2XYZ)\n deer_xyz3 = cv2.cvtColor(deer_satdesat, cv2.COLOR_BGR2XYZ)dx, dy = valueNormalize(deer_xyz)\n dx1, dy1 = valueNormalize(deer_xyz1)\n dx2, dy2 = valueNormalize(deer_xyz2)\n dx3, dy3 = valueNormalize(deer_xyz3)plt.scatter(xi, yi)\n plt.scatter(dx, dy, s = 1)\n plt.title('Original Deer')\n plt.savefig('CIE_deer.jpg')\n plt.show()\nplt.scatter(xi, yi)\n plt.scatter(dx1, dy1, s = 1)\n plt.title('Maximal Saturation Deer')\n plt.show()plt.scatter(xi, yi)\n plt.scatter(dx2, dy2, s = 1)\n plt.title('Desaturation Deer')\n plt.show()plt.scatter(xi, yi)\n plt.scatter(dx3, dy3, s = 1)\n plt.title('Saturated Desaturated Deer')\n plt.show()tiger_xyz = cv2.cvtColor(img_tiger, cv2.COLOR_BGR2XYZ)\n tiger_xyz1 = cv2.cvtColor(tiger_maxsat, cv2.COLOR_BGR2XYZ)\n tiger_xyz2 = cv2.cvtColor(tiger_desat, cv2.COLOR_BGR2XYZ)\n tiger_xyz3 = cv2.cvtColor(tiger_satdesat, cv2.COLOR_BGR2XYZ)tx, ty = valueNormalize(tiger_xyz)\n tx1, ty1 = valueNormalize(tiger_xyz1)\n tx2, ty2 = valueNormalize(tiger_xyz2)\n tx3, ty3 = valueNormalize(tiger_xyz3)plt.scatter(xi, yi)\n plt.scatter(tx, ty, s = 1)\n plt.title('Original Tiger')\n plt.show()plt.scatter(xi, yi)\n plt.scatter(tx1, ty1, s = 1)\n plt.title('Maximal Saturation Tiger')\n plt.show()plt.scatter(xi, yi)\n plt.scatter(tx2, ty2, s = 1)\n plt.title('Desaturation Tiger')\n plt.show()plt.scatter(xi, yi)\n plt.scatter(tx3, ty3, s = 1)\n plt.title('Saturated Desaturated Tiger')\n plt.show()", "https://github.com/agnik2019/agnik2019.github.io": "import React from 'react';\n//Global Style\nimport GlobalStyle from './components/GlobalStyle';\n//Import Pages\nimport AboutUs from './pages/AboutUs';\nimport OurWork from './pages/OurWork';\nimport ContactUs from './pages/ContactUs';\nimport MovieDetail from './pages/MovieDetail';\n//Router\nimport { Route, Switch, useLocation } from 'react-router-dom';\n//Animation\n//mport { AnimatePresence } from 'framer-motion';\n\n\n//imports\n\nimport Topbar from \"./components/topbar/Topbar\";\nimport Me from \"./components/About/Me\";\nimport Portfolio from \"./components/portfolio/Portfolio\";\nimport Testimonials from \"./components/testimonials/Testimonials\";\nimport Menu from \"./components/menu/Menu\"\nimport \"./app.scss\"\nimport { useState } from \"react\";\n\n\nfunction App() {\n  const location = useLocation();\n  const [menuOpen, setMenuOpen] = useState(false);\n  return (\n    <div className=\"App\">\n\n      <GlobalStyle />\n\n      <Topbar menuOpen={menuOpen} setMenuOpen={setMenuOpen} />\n      <Menu menuOpen={menuOpen} setMenuOpen={setMenuOpen}/>\n      <Switch location={location} key={location.pathname} >\n          <Route path=\"/\" exact >\n              <AboutUs/>\n          </Route>\n          <Route path=\"/about\" exact >\n              <Me/>\n          </Route>\n          <Route path=\"/portfolio\" exact>\n              <Portfolio />\n          </Route>\n        <Route path=\"/work\" exact>\n          <OurWork />\n        </Route>\n        <Route path=\"/work/:id\" >\n          <MovieDetail />\n        </Route>\n        <Route path=\"/testimonials\" exact>\n          <Testimonials />\n        </Route>\n        <Route path=\"/contact\">\n            <ContactUs />\n          </Route>\n      </Switch>       \n        \n       \n       \n        </div>\n  );\n}\n\nexport default App;\nexport const pageAnimation = {\n  hidden: {\n    opacity: 0,\n  },\n  show: {\n    opacity: 1,\n    transition: {\n      staggerChildren: 0.25,\n      duration: 0.5,\n      when: 'beforeChildren',\n    },\n  },\n  exit: {\n    opacity: 0,\n    transition: { ease: 'easeOut', duration: 0.5 },\n  },\n};\n\nexport const titleAnim = {\n  hidden: { y: 200 },\n  show: {\n    y: 0,\n    transition: { type: 'tween', ease: 'easeOut', duration: 0.75 },\n  },\n};\n\nexport const fade = {\n  hidden: { opacity: 0 },\n  show: {\n    opacity: 1,\n    transition: { type: 'tween', ease: 'easeOut', duration: 1, delay: 0.5 },\n  },\n};\n\nexport const photoAnim = {\n  hidden: { scale: 1.5, opacity: 0 },\n  show: {\n    scale: 1,\n    opacity: 1,\n    transition: {\n      type: 'tween',\n      ease: 'easeOut',\n      duration: 1,\n      delay: 0.5,\n    },\n  },\n};\n\nexport const lineAnim = {\n  hidden: { width: '0%' },\n  show: {\n    width: '100%',\n    transition: { duration: 1 },\n  },\n};\n\nexport const slider = {\n  hidden: { x: '-130%', skew: '45deg' },\n  show: {\n    x: '100%',\n    skew: '0deg',\n    transition: { type: 'tween', ease: 'easeOut', duration: 1 },\n  },\n};\nexport const sliderContainer = {\n  hidden: {\n    opacity: 1,\n  },\n  show: {\n    opacity: 1,\n\n    transition: {\n      staggerChildren: 0.15,\n      ease: 'easeOut',\n      duration: 1,\n    },\n  },\n};\nexport const movieContainer = {\n  hidden: {\n    opacity: 0,\n  },\n  show: {\n    opacity: 1,\n    transition: {\n      staggerChildren: 0.15,\n      ease: 'easeOut',\n      duration: 1,\n      when: 'beforeChildren',\n    },\n  },\n};\n\nexport const reveal = {\n  hidden: { opacity: 0, scale: 0.9 },\n  show: {\n    opacity: 1,\n    scale: 1,\n    transition: {\n      type: 'tween',\n      ease: 'easeOut',\n      duration: 1,\n    },\n  },\n};\nexport const featuredPortfolio = [\n    {\n      id: 1,\n      title: \"Social Media App\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 2,\n      title: \"Rampa UI Design\",\n      img:\n        \"https://cdn.dribbble.com/users/702789/screenshots/15054318/media/4ea5d492b7b07eebc9528ff960794879.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 3,\n      title: \"E-commerce Web Design\",\n      img:\n        \"https://cdn.dribbble.com/users/1387827/screenshots/15466426/media/deb2dca6762cd3610321c98bfccb0b72.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 4,\n      title: \"Relax Mobile App\",\n      img:\n        \"https://cdn.dribbble.com/users/4095861/screenshots/15467417/media/d6a15c416626f12b31fa5ca1db192572.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 5,\n      title: \"Hero Web Design\",\n      img:\n        \"https://cdn.dribbble.com/users/5031392/screenshots/15467520/media/c36b3b15b25b1e190d081abdbbf947cf.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 6,\n      title: \"Banking App\",\n      img:\n        \"https://cdn.dribbble.com/users/3307260/screenshots/15468444/media/447b4501f7a145b05e11c70199a9c417.jpg?compress=1&resize=1200x900\",\n    },\n  ];\n  \n  export const webPortfolio = [\n    {\n      id: 1,\n      title: \"Web Social Media App\",\n      img: \"https://cdn.dribbble.com/users/5031392/screenshots/15467520/media/c36b3b15b25b1e190d081abdbbf947cf.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 2,\n      title: \"Web Rampa UI Design\",\n      img: \"https://cdn.dribbble.com/users/3967258/screenshots/15463803/media/4fddb9a2caf3b3bd634060f706a91e73.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 3,\n      title: \"Web E-commerce Design\",\n      img: \"https://cdn.dribbble.com/users/3637068/screenshots/15467010/media/69a3279182b75365013fe285733d1122.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 4,\n      title: \"Web Relax App\",\n      img: \"https://cdn.dribbble.com/users/2264844/screenshots/15463998/media/d85e92a332c41094f68e1f716884f7ce.jpg?compress=1&resize=1200x900\",\n    },\n    {\n      id: 5,\n      title: \"Web Design\",\n      img: \"https://cdn.dribbble.com/users/387658/screenshots/15458608/media/e92ec1dd33dd1170ae3dc9c5272f2693.jpg?compress=1&resize=1200x900\",\n    },\n    {\n      id: 6,\n      title: \"Web Banking App\",\n      img: \"https://cdn.dribbble.com/users/6384483/screenshots/15468426/media/ce9479fa1f8dba3a4a49840d76e55e31.png?compress=1&resize=1200x900\",\n    },\n  ];\n  \n  export const mobilePortfolio = [\n    {\n      id: 1,\n      title: \"Mobile Social Media App\",\n      img:\n        \"https://cdn.dribbble.com/users/2597268/screenshots/15468893/media/44313553d73ba41580f1df69749bba28.jpg?compress=1&resize=1200x900\",\n    },\n    {\n      id: 2,\n      title: \"Mobile Rampa UI Design\",\n      img:\n        \"https://cdn.dribbble.com/users/5920881/screenshots/15463142/media/b5a460223798bd85d835710806e2f3dd.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 3,\n      title: \"Mobile E-commerce Design\",\n      img:\n        \"https://cdn.dribbble.com/users/1998175/screenshots/15459384/media/48ac2b43ebe81ba0866afea1383cc939.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 4,\n      title: \"Mobile Relax App\",\n      img:\n        \"https://cdn.dribbble.com/users/2083704/screenshots/15468619/media/cd958306c7a772449e1ac23bd65ce506.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 5,\n      title: \"Mobile Hero Design\",\n      img:\n        \"https://cdn.dribbble.com/users/26642/screenshots/15462545/media/1a202ef5c8338b6f78634e6edc1ba350.png?compress=1&resize=1200x900\",\n    },\n    {\n      id: 6,\n      title: \"Mobile Banking App\",\n      img:\n        \"https://cdn.dribbble.com/users/1387827/screenshots/15466426/media/deb2dca6762cd3610321c98bfccb0b72.png?compress=1&resize=1200x900\",\n    },\n  ];\n  \n  export const designPortfolio = [\n    {\n      id: 1,\n      title: \"Design Social Media App\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 2,\n      title: \"Design Rampa UI Design\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 3,\n      title: \"Design E-commerce Web Design\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 4,\n      title: \"Design Relax Mobile App\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 5,\n      title: \"Design Keser Web Design\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 6,\n      title: \"Design Banking App\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n  ];\n  \n  export const contentPortfolio = [\n    {\n      id: 1,\n      title: \"Content Social Media App\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 2,\n      title: \"Content Rampa UI Design\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 3,\n      title: \"Content E-commerce Web Design\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 4,\n      title: \"Content Relax Mobile App\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 5,\n      title: \"Content Keser Web Design\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n    {\n      id: 6,\n      title: \"Content Banking App\",\n      img:\n        \"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRKvdHn8GmPGCO0y3SJqNHACygpm0h9VycMHg&usqp=CAU\",\n    },\n  ];import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { BrowserRouter } from 'react-router-dom';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n    </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n//Import Images\nimport ds from './img/ds1.jpg';\nimport theracer from './img/wd.jpg';\nimport ds2 from './img/ds2.jpg';\nimport android from './img/android.jpg';\n\n\n\nexport const MovieState = () => {\n  return [\n    {\n      title: 'Data Science',\n      mainImg: ds,\n      secondaryImg: ds2,\n      url: '/work/dataScience',\n      projects: [\n        {\n          title: 'Image Caption Generator',\n          tools:'PYTHON, TENSORFLOW, OPEN-CV',\n          description:'\"lorem30\"',\n          github_link:\"https://github.com/agnik2019/image_caption_generator\",\n        },\n        {\n          title: 'Gender Classification',\n          description:'\"yo yo lorem20',\n          github_link:\"https://github.com/agnik2019/image_caption_generator\",\n\n        },\n        {\n          title: 'Facial & Speech Emotion Recognition',\n          description:'lorem20 ',\n          github_link:\"https://github.com/agnik2019/image_caption_generator\",\n        },\n      ],\n    },\n    {\n      title: 'Android development',\n      mainImg: android,\n      url: '/work/android',\n      projects: [\n        {\n          title: 'Android Note App',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'MEME Sender',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'Social App',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n      ],\n    },\n    {\n      title: 'Web Development',\n      mainImg: theracer,\n      url: '/work/web',\n      projects: [\n        {\n          title: 'Lets Go',\n          description:\n            '\u201cYou can see various tourist spots and also can add a tourist spots and give your ratings\u201d',\n        },\n        {\n          title: 'Restaurant site',\n          description:\n            '\u201cYou can see foods available\u201d',\n        },\n        {\n          title: 'My old portfolio',\n          description:\n            '\u201cThis website is my old portfolio\u201d',\n        },\n      ],\n    },\n  ];\n};\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n//Styled\nimport styled from 'styled-components';\nimport { motion } from 'framer-motion';\n\nexport const About = styled(motion.div)`\n  min-height: 60vh;\n  display: flex;\n  align-items: center;\n  margin-right: 4%;\n  justify-content: space-between;\n   padding: 5rem 10rem;\n  color: white;\n  overflow-x: visible;\n\n  @media screen and (max-width: 1100px) {\n   display: flex;\n   flex-direction: column;\n  }\n\n\n`;\nexport const Description = styled(motion.div)`\n\n  flex: 0.7;\n  position: relative;\n  padding: 2rem 5rem 0rem 5rem;\n  h2 {\n    font-weight: lighter;\n    font-size: 50px;\n  }\n  @media screen and (max-width: 1100px) {\n    h2{\n      z-index:2;\n      font-size: 30px;\n    }\n  }\n\n`;\nexport const Image = styled(motion.div)`\n\nwidth:450px;\n  height: 670px;\n background-image: linear-gradient(to right, green , yellow);\n  border-radius: 50%;\n   display: flex;\n   align-items: flex-end;\n  justify-content: space-between;\n   float: right;\n\n  z-index:2;\n    flex:1;\n    overflow:hidden;\n    img{\n        width:100%;\n        height:80vh;\n        object-fit:cover;\n    }\n    @media screen and (max-width: 1100px) {\n      z-index:-1;\n     // flex:0.3;\n      width:350px;\n      height: 450px;\n  img{\n        height:50vh;\n    }\n  }\n`;\n\n \n", "https://github.com/agnik2019/Basics_Of_Javascript": "//filter method\nconst numbers = [1,-1,2,3,-5,6,7];\n\nconst filtered = numbers.filter(n => n>=0);\nconsole.log(\"Explaining filter method [\"+filtered+\"]\");\n\n//combined and slice method\n\nconst first=[1,2,3];\nconst second=[4,5,6];\nconst combined = first.concat(second);\nconst slice = combined.slice(2);\nconsole.log(combined);\nconsole.log(slice);\n\n\n\n//Spread operator\nconst first1=[1,2,3];\nconst second1=[4,5,6];\nconst combined1 = [...first1,'a', ...second1,'b'];\n//const copy = combined.slice();\nconst copy = [...combined1];\nconsole.log(copy);\n\n//map\nconsole.log(\"explaining map\")\nconst numbers1 = [1,-1,2,3,-5,6,7];\nconst filtered1 = numbers1.filter(n => n>=0);\nconst items = filtered1.map(n => ({value : n}) );\nconsole.log(items);\n\n\n//for..of \nconst numbers2 = [1,-1,2,3];\nlet sum2=0;\n \nfor(let n of numbers2)\n    sum2+=n;\nconsole.log(sum2);\n\n//you can use reduce method to clean your code\nconst sum1 = numbers.reduce(\n    (accumulator,currentValue) => accumulator+currentValue\n\n);\nconsole.log(sum1);\n\n// indexOf\nconst ages = [3, 10, 18, 20];\n\nages.findIndex(checkAge)   // Returns 3\n\nfunction checkAge(age) {\n  return age > 18;\n}\n//  Slice method won't mutate the original array but it returns the subset as a new\n// array\n// let arrayIntegers = [1, 2, 3, 4, 5];\n// let arrayIntegers1 = arrayIntegers.slice(0,2); // returns [1,2]\n// let arrayIntegers2 = arrayIntegers.slice(2,3); // returns [3]\n// let arrayIntegers3 = arrayIntegers.slice(4); //returns [5]\n\n// Splice method modifies the original array and returns the deleted array\nlet arrayIntegersOriginal1 = [1, 2, 3, 4, 5];\nlet arrayIntegersOriginal2 = [1, 2, 3, 4, 5];\nlet arrayIntegersOriginal3 = [1, 2, 3, 4, 5];\nlet arrayIntegers1 = arrayIntegersOriginal1.splice(0,2); // returns [1, 2]; \nlet arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; \nlet arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, \"a\", \"b\", \"c\");\n\nfor(let x in arrayIntegers1)\n    console.log(x);\n\n// calculate the sum using map method\nlet arr = [1,2,3,4,5];\nvar sum = 0;\nconsole.log(arr.map( val => sum+= val))\nconsole.log(sum);\nvar arr = [31,28,31,30,31,30,31,31,30,31,30,31];\narr[1000] = 22;\nconsole.log(arr.length) // 1001\n\nconsole.log(23+undefined) // NaN\n\n// array sorts element alphabetically\nvar arr2 = [-2, 8,22,10,-5];\narr2.sort(function(a,b){return a-b});\nconsole.log(arr2)\n// Curried functions are great to improve code reusability and functional composition.\n\nconst multiArgFunction = (a, b, c) => a + b + c;\nconsole.log(multiArgFunction(1,2,3));// 6\nconst curryUnaryFunction = a => b => c => a + b + c;\ncurryUnaryFunction (1); // returns a function: b => c => 1 + b + c\ncurryUnaryFunction (1) (2); // returns a function: c => 3 + c\ncurryUnaryFunction (1) (2) (3); // returns the number 6const data = [\n  { \"firstname\":\"Agnik \", \"lastname\":\"Saha\",\"age\":23 },\n  { \"firstname\":\"Donald \", \"lastname\":\"Trump\",\"age\":65 },\n  { \"firstname\":\"Alia \", \"lastname\":\"Bhatt\",\"age\":23 },\n  { \"firstname\":\"Deb \", \"lastname\":\"Saha\",\"age\":24 },\n];\n\n\nconst output1 = data.map( x => x.firstname+x.lastname);\nconsole.log(output1);\n\nconst output2 = data.filter( x=> x.age>50 );\nconsole.log(output2);\n\n// Reduce\nlet arr = [1,2,3,45,6,43];\nconst output3 = arr.reduce(function(acc, curr){\n    acc = acc+curr;\n    return acc;\n},0)\nconsole.log(output3);\n\n// Finding max using reduce method\nlet arr2 = [1,2,3,45,6,43];\nconst output4 = arr2.reduce(function(acc, curr){\n    if(curr>acc)  acc= curr;\n    return acc;\n},0)\nconsole.log(output4);\n\n// Finding min using reduce method\nconst output5 = arr2.reduce(function(acc, curr){\n    if(curr<acc)  acc= curr;\n    return acc;\n},arr2[0]);\nconsole.log(output5);//console.log(sum(1,2,3,4,6));\nconsole.log(sum(\"Agnik\",99,89,45,99))\n\n// function sum(){\n//     let sum = 0;\n//     console.log(typeof(arguments)) // Object\n//     console.log(arguments);\n//     for(let i in arguments)\n//         sum+= arguments[i];\n//     return sum;\n// }\n\nfunction sum(name, ...args){\n    console.log(`Hi, ${name}`);\n    let s = 0;\n    for(let i in args)\n        s= s+ args[i];\n    return s;\n}\n//Explaining hoisting and arguments of functions\nconsole.log(sum(1,2,4,5,8,9,11));\n\nfunction sum()\n{\n    console.log(arguments);\n    let total =0;\n    for(let value of arguments)\n        total += value;\n    return total;\n}\n //console.log(sum(1,2,4,5,8,9,11));\n\n\nfunction sum1(discount, ...prices){\n    const total = prices.reduce((a,b) =>a+b);\n    return total*(1-discount);\n}\nconsole.log(sum1(0.1,20,30,1));\n\n\n\nfunction sum2(...args){\n    let total=0;\n    return args.reduce((a,b) => a+b);\n}\nconsole.log(sum2(1,2,3,5,10));\n\n\n\n// //method -> obj\n// // function -> global(window,global)\n\n\n// const video = {\n//     title : 'a', \n//     play(){\n//         console.log(this);\n//     }\n// };\n\n// function video2(title)\n// {\n//     this.title= title;\n//     console.log(this);\n// }\n// const v= new video2('b');  //local object\n\n\n\n\n// video.stop = function(){\n//     console.log(this);\n// };  \n\n// video.stop();  //window object\n\n// video.play();\n\n\n// function playvideo(){\n//     console.log(this);\n// }\n// playvideo();  //window object\n\n\n// const video = {\n//     title: 'a',\n//     tags:['a','b','c','d'],\n//     showTags(){\n//         this.tags.forEach(function(tag){\n//             console.log(this,tag);\n//         });\n//     }\n// };\n// video.showTags();\n \n// function playVideo(){\n//     console.log(this);\n// }\n// playVideo.call({name: \"Agnik\"},1,2);\n\n\n// const video = {\n//     title: 'a',\n//     tags:['a','b','c','d'],\n//     showTags(){\n//         this.tags.forEach(tag => {\n//             console.log(this.title,tag);\n//         });\n//     }\n// };\n// video.showTags();\n\nvar employee1 = {'firstname':\"Agnik\", 'lastname':\"Saha\"};\nvar employee2 = {'firstname':\"Ayan\", 'lastname':\"Malakar\"};\n\nfunction greeting(greeting1 , greeting2){\n    console.log(greeting1+\" \"+this.firstname+\" \"+this.lastname+ \" \"+greeting2);\n}\n\ngreeting.call(employee1,\"hi\",\"gentleman\");\n\n//Apply: Invokes the function with a given this value and allows you to pass in\n// arguments as an array\ngreeting.apply(employee2,[\"hello\",\"good evening\"]);\n\n// bind: returns a new function, allowing you to pass any number of arguments\nvar inviteEmployee1 = greeting.bind(employee1);\nvar inviteEmployee2 = greeting.bind(employee2);\ninviteEmployee1('Hello', 'How are you?'); // Hello John Rodson, How are you?\ninviteEmployee2('Hello', 'How are you?');// hoisting in javascript\n// getName();\n// console.log(x);\n// var x = 7;\n// function getName() {\n//  console.log(\"Namaste Javascript\");\n// }\n\nvar x = 1;\na();\nb();\nconsole.log(x);\nfunction a() {\n var x = 10;\n console.log(x);\n}\nfunction b() {\n var x = 100;\n console.log(x);\n}\n/* \noutput:\n10\n100\n1\n*/\nconst circle = {\n    radius: 1,\n    location :{\n        x:2,\n        y:-1\n    },\n    isVisible: true,\n    draw: function(){\n        console.log(\"draw\")\n    }\n};\ncircle.draw();\n//factor function\nfunction createCircle(radius)\n{\n    return {\n        radius, // radius : radius\n        draw(){\n            console.log(\"draw\");\n        },\n        area(){\n            console.log(\"Area is \"+3.1416*radius*radius)\n        }\n    }\n};\nconst circle1 = createCircle(3);\ncircle1.area();\nconst circle2 = createCircle(4);\n\n//constructor function\nfunction Circle(radius)\n{\n    this.radius = radius,\n    this.draw = function(){\n        console.log(\"draw\")\n    }\n}\n\n//Circle.apply({},[1,2,3]);\nconst circle3 = new Circle(7);\nCircle.call({},7); //internally new Circle calls empty object and the value\ncircle3.draw();function userDetails(username) {\n    if(username) \n    {\n        console.log(salary); // undefined due to hoisting\n        console.log(age); // ReferenceError: Cannot access 'age' before initializati\n        let age = 30;\n        var salary = 10000;\n    }\n    console.log(salary); //10000 (accessible to due function scope)\n    console.log(age); //error: age is not defined(due to block scope)\n}\nuserDetails('John');//string is primitive\n//2 type of string--> string prconst button = document.querySelector('button');\nconst disp = document.getElementById('display');\nvar count = 0;\n\nfunction toggle(){\n    count++;\n    button.classList.toggle('altColor')\n    disp.innerHTML = count;\n}\n//toggle();  ---> not a callback function\n\nbutton.addEventListener('click',toggle);\n\n\n// callback\n// function firstAction(){\n//     console.log(\"I am the first action\");\n//     setTimeout(secondAction, 2000);\n// }\n// function secondAction(){\n//     console.log(\"I am the second action\");\n// }\n// setTimeout(firstAction,5000);\n\n\n\n\n\n// function firstAction(callback){\n//     console.log(\"I am the first action\");\n//     setTimeout(callback, 2000);\n// }\n// function secondAction(){\n//     console.log(\"I am the second action\");\n// }\n// setTimeout(firstAction(secondAction),5000);\n//This is not a callback\n\n\n\n\n\n\n// To make this callback\n// function firstAction(callback){\n//     console.log(\"I am the first action\");\n//     setTimeout(callback, 2000);\n// }\n// function secondAction(){\n//     console.log(\"I am the second action\");\n// }\n// setTimeout(()=>firstAction(secondAction),5000);\n\n\n\n\n\nfunction firstAction(callback){\n    console.log(\"I am the first action\");\n    setTimeout(callback, 2000);\n}\nfunction secondAction(message){\n    console.log(message);\n}\nsetTimeout(()=>firstAction(()=>secondAction(\"I am the second action\")),5000);// global scope\nlet x = 1;\n\nconst parentFunction = () => {\n    let myValue = 2;\n    console.log(x);\n    console.log(myValue);\n\n    const childFunction = () => {\n        console.log(x+=5);\n        console.log(myValue += 1);\n    }\n    return childFunction;\n}\n const result = parentFunction();\n console.log(result);\n result();\n result();function x(){\n    var a = 7;\n    return function y(){\n        console.log(a);\n    };\n}\n\nvar z = x();\nconsole.log(z);\n//.......\nz();// function x(){\n//     var i = 1;\n//     setTimeout(function(){\n//         console.log(i);\n//     },3000);\n//     console.log(\"Hello..\")\n// }\n// x();\n\n//Question: print 1 after 1 second, print 2 after 2 second , print 3 after 3 seconds.....\n// function x()\n// {\n//     for(var i = 1; i<=5; i++)\n//     {\n//         setTimeout(function(){\n//             console.log(i);\n//         },i*1000);\n//     }\n// }\n// x();\n\n// function x()\n// {\n//     for(let i = 1; i<=5; i++)\n//     {\n//         setTimeout(function(){\n//             console.log(i);\n//         },i*1000);\n//     }\n// }\n// x();\nfunction x()\n{\n        for(var i = 1; i<=5; i++){\n        function close(i)\n        {\n            setTimeout(function(){\n                console.log(i);\n            },i*1000);\n        }\n       close(i);\n        }\n}\nx();\n\n\nfunction multiplier(factor){\n    return (number) => number*factor;\n}\n\n// twice = multiplier(2);\n// thrice = multiplier(3);\n// console.log(twice(10));\n// console.log(thrice(10));\nconsole.log(multiplier(2)(3));function x(){\n    var a = 7;\n    function y(){\n        console.log(a);\n    };\n    a = 100;\n    return y;\n}\n\nvar z = x();\nconsole.log(z);\n//.......\nz();\n\n/*\n[Function: y]\n100  \n*/function z(){\n    var b = 100;\n    function x(){\n        var a = 7;\n        function y(){\n            console.log(a,b);\n        };\n       y();\n    }\n    x();    \n}\nz();const radius = [3,4,5,6];\n// area\nconst area = function(radius){\n    return Math.PI*radius*radius\n};\n\nconst diameter = function(radius){\n    return 2*radius;\n};\nconst circum = (radius) => {return 2*Math.PI*radius;}\nconst calculateArea = (radius,logic) =>\n{\n    let output = [];\n    for(let i = 0; i< radius.length; i++)\n    {\n        output.push(logic(radius[i]));\n    }\n    return output;\n}\nconsole.log(calculateArea(radius,area));\nconsole.log(calculateArea(radius,circum));\nconsole.log(calculateArea(radius,diameter));\n// write a function to calculate area, circumference, diameter of radius\nconst radius = [3,4,5,6];\n// area\nconst calculateArea = (radius) =>\n{\n    let output = [];\n    for(let i = 0; i< radius.length; i++)\n    {\n        output.push(Math.PI * radius[i] *radius[i]);\n    }\n    return output;\n}\nconsole.log(calculateArea(radius));\n\n// Circumference\nconst calculateCircum = (radius) =>\n{\n    let output = [];\n    for(let i = 0; i< radius.length; i++)\n    {\n        output.push(Math.PI * radius[i] *2);\n    }\n    return output;\n}\nconsole.log(calculateCircum(radius));\n\n// diameter\nconst calculateDiameter = (radius) =>\n{\n    let output = [];\n    for(let i = 0; i< radius.length; i++)\n    {\n        output.push( radius[i] *2);\n    }\n    return output;\n}\nconsole.log(calculateDiameter(radius));\n\n\n\n\n/*  \nOutput:\n[\n  28.274333882308138,\n  50.26548245743669,\n  78.53981633974483,\n  113.09733552923255\n]\n[\n  18.84955592153876,\n  25.132741228718345,\n  31.41592653589793,\n  37.69911184307752\n]\n[ 6, 8, 10, 12 ]\n*/\nconst radius = [1,2,3,4];\nconst area = (radius) => {\n    return Math.PI * radius*radius;\n}\nconsole.log(radius.map(area));\n\n\nArray.prototype.calculate = function(logic){\n    let output = [];\n    for(let i = 0; i< this.length; i++){\n        output.push(logic(this[i]));\n    }\n    return output;\n}\nconsole.log(radius.calculate(area));/* \nYou've written the code shown to log a set of consecutive values, but it instead results in the\n value 5, 5, 5, and 5 being logged to the console. Which revised version of the code would result \n in the value 1, 2, 3 and 4 being logged?\n\n*/\n\n\nfor (var i = 1; i <= 4; i++) {\n    setTimeout(function () {\n      console.log(i);\n    }, i * 100);\n  }\n\n\n  for (var i = 1; i <= 4; i++) {\n    (function (j) {\n      setTimeout(function () {\n        console.log(j);\n      }, j * 100);\n    })(i);\n  }console.log(sum(10, 20));\nconsole.log(diff(10, 20));\nfunction sum(x, y) {\n  return x + y;\n}\n\nlet diff = function (x, y) {\n  return x - y;\n};\n//console.log(diff(10, 20));var v = 1;\nvar f1 = function () {\n  console.log(v);\n};\n\nvar f2 = function () {\n  var v = 2;\n  f1();\n};\n\nf2();console.log(\"I\");\nsetTimeout(\n    function(){\n      console.log(\"Love\")\n    },0)\nconsole.log(\"Javascript\")//globalThis.setTimeout(()=> console.log('hello'),100)\n//window.setTimeout(()=> console.log('hello'),100)\n\n// Optional Chaining\n\n// const language = {\n//     name:'Javascript',\n//     creator:'Brendan Eich',\n//     library:{\n//         react:{\n//             company:'Facebook'\n//         }\n//     }\n// };\n// let company = language?.library?.react?.company;\n// console.log(company);\n\n\n// let colors = ['red','green','blue'];\n// colors = null;\n// console.log(colors?.[1]);\n\n// Nullish coalescing Operator\nlet language;\nconsole.log(language ?? 'Javascript')const flag = document.createElement('img');\ndocument.body.appendChild(flag);\n\nfetch('https://restcountries.eu/rest/v2/all')\n    .then(response => {return response.json(); })\n    .then(json => {\n        console.log(json)\n        flag.src = json[0].flag;\n        console.log(\"flag added\");\n    })\n    .catch(err => console.log('errors '+err.message));\n\nfunction reverseStr(str)\n{\n    return str.split('').reverse().join('')\n}\n\nfunction isPalindrome(str)\n{\n    var reverse = reverseStr(str)\n    if(reverse === str){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// write a function that converts date from number to string\n\nfunction convertDateToStr(date)\n{\n    var dateStr = {day:'',month:'',year:''}; \n    dateStr.day = (date.day < 10) ? '0'+date.day : date.day.toString();\n    dateStr.month = (date.month < 10) ? '0'+date.month : date.month.toString();\n    dateStr.year = date.year.toString();\n    return dateStr; \n}\n\n\n\n// Write a JS function that takes a date and returns all variations of it\n\nfunction getAllDateFormats(date) {\n    var dateStr = convertDateToStr(date);\n    var ddmmyyyy = dateStr.day + dateStr.month+ dateStr.year\n    var mmddyyyy = dateStr.month + dateStr.day + dateStr.year\n    var yyyymmdd = dateStr.year+dateStr.month + dateStr.day\n    var ddmmyy =  dateStr.day + dateStr.month+ dateStr.year.slice(-2)\n    var mmddyy = dateStr.month + dateStr.day + dateStr.year.slice(-2)\n    var yymmdd = dateStr.year.slice(-2)+dateStr.month + dateStr.day;\n    return [ddmmyyyy, mmddyyyy,yyyymmdd, ddmmyy, mmddyy, yymmdd]\n}\n\n\n\n// Write a function that checks palindrome for all the date formats\nfunction checkPalindromForAllDateFormats(date)\n{\n    var listOfAllDates = getAllDateFormats(date)\n    var flag = false;\n    for(var i = 0; i< listOfAllDates.length; i++){\n        if(isPalindrome(listOfAllDates[i]))\n        {\n            flag = true;\n            break;\n        }\n    }\n    return flag; \n}\n\n//console.log(checkPalindromForAllDates(date));\n\n\n//  Find the next palindrome date, also how many days are in between\nfunction isLeapYear(year){\n    if(year % 400 === 0) \n        return true;\n    if(year % 100 === 0)\n        return false;\n    if(year % 4 === 0)\n        return true;\n    return false;\n}\n\nfunction getNextDate(date){\n    var day = date.day+1;\n    var month = date.month;\n    var year = date.year;\n    var daysInMonth = [31,28,31,30,31,30,31,31,30,31,30,31];\n    if(month === 2)\n    {\n        if(isLeapYear(year))\n        {\n            if(day > 29)\n            {\n                day = 1;\n                month++;\n            }\n\n        } else {\n            if(day > 28)\n            {\n                day = 1;\n                month++;\n            }\n\n        }\n    } else {\n       if(day >daysInMonth[month-1])\n       {\n           day = 1;\n           month++;\n       }\n    }\n    if(month > 12)\n    {\n        month = 1;\n        year++;\n    }\n    return {\n        day: day,\n        month: month,\n        year: year\n    };\n}\n\nfunction getNextPalindromeDate(date)\n{\n    var count = 0;\n    var nextDate = getNextDate(date);\n    while(1){\n        count++;\n        var flag = checkPalindromForAllDateFormats(nextDate);\n        if(flag) break;\n        nextDate = getNextDate(nextDate);\n    }\n    return [count, nextDate];\n}\n\n// get the previous date\nfunction getPreviousDate(date)\n{\n    var day = date.day-1;\n    var month = date.month;\n    var year = date.year;\n    var daysInMonth = [31,28,31,30,31,30,31,31,30,31,30,31];\n    if(month === 3)\n    {\n        if(isLeapYear(year))\n        {\n            if(day < 1)\n            {\n                day = 29;\n                month--;\n            }\n\n        } else {\n            if(day < 1)\n            {\n                day = 28;\n                month--;\n            }\n\n        }\n    } else {\n       if(day <1)\n       {\n           day = daysInMonth[month-1];\n           month--;\n       }\n    }\n    if(month < 1)\n    {\n        month = 12;\n        year--;\n    }\n    return {\n        day: day,\n        month: month,\n        year: year\n    };\n\n}\n\nfunction getPreviousPalindromeDate(date)\n{\n    var count = 0;\n    var prevDate = getPreviousDate(date);\n    while(1){\n        count++;\n        var flag = checkPalindromForAllDateFormats(prevDate);\n        if(flag) break;\n        prevDate = getPreviousDate(prevDate);\n    }\n    return [count, prevDate];\n}\n\n\nvar DateInputRef = document.querySelector(\"#bday-input\");\nvar ShowButtonRef = document.querySelector(\"#show-btn\");\nvar resultRef = document.querySelector(\"#result\");\nfunction clickHandler(e){\n    var textinputdate = DateInputRef.value;\n    var listOfValues = textinputdate.split('-');\n    var date = {\n        day: Number(listOfValues[2]),\n        month : Number(listOfValues[1]),\n        year : Number(listOfValues[0]),\n    }\n    if(textinputdate !== ''){\n        var isPalindrome = checkPalindromForAllDateFormats(date);\n        if(isPalindrome){\n            resultRef.innerText = \"Yay!! Your Entered number is Palindrome\"\n        } else {\n            var [ctr, nextDate] = getNextPalindromeDate(date);\n            resultRef.innerText = `Your next Palindrome is ${ctr} days left!! \n            The date is ${nextDate.day} / ${nextDate.month} / ${nextDate.year}`\n        }\n    }\n}\nShowButtonRef.addEventListener('click', clickHandler)const Person = {\n    alive: true\n};\n\nconst musician = {\n    plays: true\n};\n\nmusician.__proto__ = Person;\nconsole.log(musician.plays);\nconsole.log(musician.alive);\n", "https://github.com/agnik2019/Basic_Crud_Api": "const mongoose = require('mongoose')\n\nconst alienSchema = new mongoose.Schema({\n    name : {\n        type: String,\n       required: true,\n       default:\"Agnik\"\n    },\n    tech : {\n        type : String,\n        required : true,\n        default:\"NodeJS\"\n    },\n    sub : {\n        type: Boolean,\n        required: true,\n        default : false\n    }\n})\n\nmodule.exports = mongoose.model('Alien', alienSchema)404: Not Foundconst express = require('express')\nconst router = express.Router()\nconst Alien = require('../models/alien')\n\nrouter.get('/', async(req,res) => {\n    try{\n        const aliens = await Alien.find()\n        res.json(aliens)\n    }\n    catch(err) {\n        res.send('Error '+err)\n    }\n})\n\nrouter.get('/:id', async(req,res) => {\n    try{\n        const aliens = await Alien.findById(req.params.id)\n        res.json(aliens)\n    }\n    catch(err) {\n        res.send('Error '+err)\n    }\n})\n\nrouter.post('/', async(req, res) => {\n    const alien = new Alien({\n        name : req.body.name,\n        tech : req.body.tech,\n        sub : req.body.sub\n    })\n    try {\n         const a1 =   await alien.save()\n         res.json(a1)\n    } catch(err){\n        res.send('Error')\n        console.log(err);\n    }\n})\n\nrouter.patch(\"/:id\", async(req, res) => {\n    try {\n        const alien = await Alien.findById(req.params.id)\n        alien.sub = req.body.sub \n        const a1 = await alien.save()\n        res.json(a1)\n    }\n    catch(err){\n        res.send('Error')\n    }\n})\n\nrouter.delete(\"/:id\", async(req, res) => {\n    try {\n        const alien = await Alien.findByIdAndRemove(req.params.id)\n        // await alien.save()\n        res.redirect('/aliens')\n    }\n    catch(err){\n        res.send('Error')\n        console.log(err)\n    }\n})\n\nmodule.exports = router", "https://github.com/agnik2019/Big-data-analytics-with-ML": "", "https://github.com/agnik2019/Cancer_classification_multimodal": "!pip install -U torch datasets transformersimport json\n \n with open('skin_cancer_dataset.json') as user_file:\n     ds = user_file.read()\n     \n parsed_json = json.loads(ds)\n print(parsed_json)type(parsed_json)import requests\n image_url = \"https://www.skincancer.org/wp-content/uploads/basal-cell-carcinoma-2-open-sore-340x240.png\"\n img_data = requests.get(image_url).content\n with open('image_name.jpg', 'wb') as handler:\n     handler.write(img_data)import requests\n \n headers = {\"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\",\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.9\"\n            }\n \n for i,ele in enumerate(parsed_json):\n     print(f\"{i}  -> {ele['cancer_img']}\")\n     image_url = ele['cancer_img']\n     img_data = requests.get(url=image_url, headers=headers).content\n     with open(f'{i}.jpg', 'wb') as handler:\n         handler.write(img_data)\nfrom datasets import load_dataset\n \n imagenette = load_dataset(\n     'frgfm/imagenette',\n     'full_size',\n     split='train',\n     ignore_verifications=False  # set to True if seeing splits Error\n )\n imagenette\n from transformers import CLIPTokenizerFast, CLIPProcessor, CLIPModel\n import torch\n \n # if you have CUDA or MPS, set it to the active device like this\n device = \"cuda\" if torch.cuda.is_available() else \\\n          (\"mps\" if torch.backends.mps.is_available() else \"cpu\")\n model_id = \"openai/clip-vit-base-patch32\"\n \n # we initialize a tokenizer, image processor, and the model itself\n tokenizer = CLIPTokenizerFast.from_pretrained(model_id)\n processor = CLIPProcessor.from_pretrained(model_id)\n model = CLIPModel.from_pretrained(model_id).to(device)\n \n \n # create text embedding\n prompt = \"a dog in the snow\"\n \n # create transformer-readable tokens\n inputs = tokenizer(prompt, return_tensors=\"pt\")\n print(inputs)\n \n # Then feed these tokens into the model using the get_text_features method.\n # use CLIP to encode tokens into a meaningful embedding\n text_emb = model.get_text_features(**inputs)\n print(text_emb.shape)\n \n \n # create image embeddings\n image = processor(\n     text=None,\n     images=imagenette[0]['image'],\n     return_tensors='pt'\n )['pixel_values'].to(device)\n print(image.shape)\n import matplotlib.pyplot as plt\n # we can still visualize the processed image\n plt.imshow(image.squeeze(0).T)\n \n # we process these inputs with CLIP, this time using the get_image_features method.\n img_emb = model.get_image_features(image)\n print(img_emb.shape)\n \n \n # And with that, we built vector embeddings for text and image with CLIP. With these embeddings,\n # we can compare their similarity using metrics like Euclidean distance, cosine similarity, or dot product similarity.\n# CNN for Sentence Classification with PyTorch## Introduction**Convolutional Neural Networks (CNN)** were originally invented for computer vision (CV) and now are the building block of state-of-the-art CV models. One of the earliest applications of CNN in Natural Language Processing (NLP) was introduced in the paper ***Convolutional Neural Networks for Sentence Classification*** (Kim, 2014). With the same idea as in computer vision, CNN model is used as an feature extractor that encodes semantic features of sentences before these features are fed to a classifier.\n \n With only a simple one-layer CNN trained on top of pretrained word vectors and little hyperparameter tuning, the model achieves excellent results on multiple sentence-level classification tasks. CNN models are now used widely other NLP tasks such as translation or question answering as a part of a more complex architecture.\n \n When implementing the original paper (Kim, 2014) in PyTorch, I needed to put many pieces together to complete this project. This article serves as a complete guide to CNN for sentence classification tasks accompnied with advice for practioners. It will cover:\n - Tokenizing and building vocabuilary from text data\n - Loading pretrained fastText word vectors and creating embedding layer for fine-tuning\n - Building and training CNN model with PyTorch\n - Advice for practitioners\n - Bonus: Using Skorch as a scikit-like wrapper for PyTorch's Deep Learning models\n \n **Reference:**\n -  [Convolutional Neural Networks for Sentence Classification](https://arxiv.org/abs/1408.5882) (Kim, 2014).\n - [A Sensitivity Analysis of (and Practitioners' Guide to) Convolutional Neural Networks for Sentence Classification](https://arxiv.org/abs/1510.03820) (Zhang, 2015).\n - [Advances in Pre-Training Distributed Word Representations](https://arxiv.org/abs/1712.09405) (Mikolov, 2018).\n \n## 1. Set up### 1.1. Import Librariesimport os\n import re\n from tqdm import tqdm\n import numpy as np\n import pandas as pd\n import nltk\n nltk.download(\"all\")\n import matplotlib.pyplot as plt\n import torch\n \n %matplotlib inline### 1.2. Download DatasetsThe dataset we will use is Movie Review (MR), a sentence polarity dataset from (Pang and Lee, 2005). The dataset has 5331 positive and 5331 negative processed sentences/snippets.# URL = 'https://www.cs.cornell.edu/people/pabo/movie-review-data/rt-polaritydata.tar.gz'\n # # Download Datasets\n # !wget -P 'Data/' $URL\n # # Unzip\n # !tar xvzf 'Data/rt-polaritydata.tar.gz' -C 'Data/'# def load_text(path):\n #     \"\"\"Load text data, lowercase text and save to a list.\"\"\"\n \n #     with open(path, 'rb') as f:\n #         texts = []\n #         for line in f:\n #             texts.append(line.decode(errors='ignore').lower().strip())\n \n #     return texts\n \n # # Load files\n # neg_text = load_text('Data/rt-polaritydata/rt-polarity.neg')\n # pos_text = load_text('Data/rt-polaritydata/rt-polarity.pos')\n \n # # Concatenate and label data\n # texts = np.array(neg_text + pos_text)\n # labels = np.array([0]*len(neg_text) + [1]*len(pos_text))import json\n \n with open('/content/skin_cancer_dataset.json') as user_file:\n     ds = user_file.read()\n     \n parsed_json = json.loads(ds)\n \n tkns,final_labels = [],[]\n for i,ele in enumerate(parsed_json):\n     # print(f\"{i}  -> {ele['cancer_img_caption']}\")\n     tkns.append(ele['cancer_img_caption'])\n     final_labels.append(ele['cancer_type'])\n \n mp_labels_2_num = {\"Basal Cell Carcinoma (BCC)\":0,\"Squamous Cell Carcinoma (SCC)\":1,\"Melanoma\":2, \"Merkel Cell Carcinoma (MCC)\":3}\n \n final_labels_2 = [mp_labels_2_num[x] for x in final_labels]\n \n \n texts = np.array(tkns)\n labels = np.array(final_labels_2)### 1.3. Download fastText Word VectorsThe pretrained word vectors used in the original paper is *word2vec* (Mikolov et al., 2013) trained on 100 billion tokens of Google News. In this tutorial, we will use [*fastText* pretrained word vectors](https://fasttext.cc/docs/en/english-vectors.html) (Mikolov et al., 2017), trained on 600 billion tokens on Common Crawl. *fastText* is an upgraded version of *word2vec* and outperform other state-of-the-art methods by a large margin.\n \n The code below will download fastText pretrained vectors. Using Google Colab, the running time is approximately 3min 30s.%%time\n URL = \"https://dl.fbaipublicfiles.com/fasttext/vectors-english/crawl-300d-2M.vec.zip\"\n FILE = \"fastText\"\n \n if os.path.isdir(FILE):\n     print(\"fastText exists.\")\n else:\n     !wget -P $FILE $URL\n     !unzip $FILE/crawl-300d-2M.vec.zip -d $FILE### 1.4. Set up GPU for TrainingGoogle Colab offers free GPUs and TPUs. Since we'll be training a large neural network it's best to utilize these features.\n \n A GPU can be added by going to the menu and selecting:\n \n > Runtime -> Change runtime type -> Hardware accelerator: GPU\n \n Then we need to run the following cell to specify the GPU as the device.if torch.cuda.is_available():       \n     device = torch.device(\"cuda\")\n     print(f'There are {torch.cuda.device_count()} GPU(s) available.')\n     print('Device name:', torch.cuda.get_device_name(0))\n \n else:\n     print('No GPU available, using the CPU instead.')\n     device = torch.device(\"cpu\")## 2. Data PreparationTo prepare our text data for training, first we need to tokenize our sentences and build a vocabulary dictionary `word2idx`, which will later be used to convert our tokens into indexes and build an embedding layer.\n \n ***So, what is an embedding layer?***\n \n An embedding layer serves as a look-up table which take word indexes in the vocabulary as input and output word vectors. Hence, the embedding layer has shape $(N, d)$ where $N$ is the size of the vocabulary and $d$ is the embedding dimension. In order to fine-tune pretrained word vectors, we need to create an embedding layer in our `nn.Modules` class. Our input to the model will then be `input_ids`, which is the tokens' index in the vocabulary.### 2.1. TokenizeThe function `tokenize` will tokenize our sentences, build a vocabulary and fine the maximum sentence length. The function `encode` will take in the outputs of `tokenize`, perform sentence padding and return `input_ids` as a numpy array.from nltk.tokenize import word_tokenize\n from collections import defaultdict\n \n def tokenize(texts):\n     \"\"\"Tokenize texts, build vocabulary and find maximum sentence length.\n     \n     Args:\n         texts (List[str]): List of text data\n     \n     Returns:\n         tokenized_texts (List[List[str]]): List of list of tokens\n         word2idx (Dict): Vocabulary built from the corpus\n         max_len (int): Maximum sentence length\n     \"\"\"\n \n     max_len = 0\n     tokenized_texts = []\n     word2idx = {}\n \n     # Add <pad> and <unk> tokens to the vocabulary\n     word2idx['<pad>'] = 0\n     word2idx['<unk>'] = 1\n \n     # Building our vocab from the corpus starting from index 2\n     idx = 2\n     for sent in texts:\n         tokenized_sent = word_tokenize(sent)\n \n         # Add `tokenized_sent` to `tokenized_texts`\n         tokenized_texts.append(tokenized_sent)\n \n         # Add new token to `word2idx`\n         for token in tokenized_sent:\n             if token not in word2idx:\n                 word2idx[token] = idx\n                 idx += 1\n \n         # Update `max_len`\n         max_len = max(max_len, len(tokenized_sent))\n \n     return tokenized_texts, word2idx, max_len\n \n def encode(tokenized_texts, word2idx, max_len):\n     \"\"\"Pad each sentence to the maximum sentence length and encode tokens to\n     their index in the vocabulary.\n \n     Returns:\n         input_ids (np.array): Array of token indexes in the vocabulary with\n             shape (N, max_len). It will the input of our CNN model.\n     \"\"\"\n \n     input_ids = []\n     for tokenized_sent in tokenized_texts:\n         # Pad sentences to max_len\n         tokenized_sent += ['<pad>'] * (max_len - len(tokenized_sent))\n \n         # Encode tokens to input_ids\n         input_id = [word2idx.get(token) for token in tokenized_sent]\n         input_ids.append(input_id)\n     \n     return np.array(input_ids)### 2.2. Load Pretrained VectorsWe will load the pretrain vectors for each tokens in our vocabulary. For tokens with no pretraiend vectors, we will initialize random word vectors with the same length and variance.from tqdm import tqdm_notebook\n \n def load_pretrained_vectors(word2idx, fname):\n     \"\"\"Load pretrained vectors and create embedding layers.\n     \n     Args:\n         word2idx (Dict): Vocabulary built from the corpus\n         fname (str): Path to pretrained vector file\n \n     Returns:\n         embeddings (np.array): Embedding matrix with shape (N, d) where N is\n             the size of word2idx and d is embedding dimension\n     \"\"\"\n \n     print(\"Loading pretrained vectors...\")\n     fin = open(fname, 'r', encoding='utf-8', newline='\\n', errors='ignore')\n     n, d = map(int, fin.readline().split())\n \n     # Initilize random embeddings\n     embeddings = np.random.uniform(-0.25, 0.25, (len(word2idx), d))\n     embeddings[word2idx['<pad>']] = np.zeros((d,))\n \n     # Load pretrained vectors\n     count = 0\n     for line in tqdm_notebook(fin):\n         tokens = line.rstrip().split(' ')\n         word = tokens[0]\n         if word in word2idx:\n             count += 1\n             embeddings[word2idx[word]] = np.array(tokens[1:], dtype=np.float32)\n \n     print(f\"There are {count} / {len(word2idx)} pretrained vectors found.\")\n \n     return embeddingsNow let's put above steps together.# Tokenize, build vocabulary, encode tokens\n print(\"Tokenizing...\\n\")\n tokenized_texts, word2idx, max_len = tokenize(texts)\n input_ids = encode(tokenized_texts, word2idx, max_len)\n \n # Load pretrained vectors\n embeddings = load_pretrained_vectors(word2idx, \"fastText/crawl-300d-2M.vec\")\n embeddings = torch.tensor(embeddings)embeddings.shape### 2.3. Create PyTorch DataLoaderWe will create an iterator for our dataset using the torch DataLoader class. This will help save on memory during training and boost the training speed. The batch_size used in the paper is 50.from torch.utils.data import (TensorDataset, DataLoader, RandomSampler,\n                               SequentialSampler)\n \n def data_loader(train_inputs, val_inputs, train_labels, val_labels,\n                 batch_size=50):\n     \"\"\"Convert train and validation sets to torch.Tensors and load them to\n     DataLoader.\n     \"\"\"\n \n     # Convert data type to torch.Tensor\n     train_inputs, val_inputs, train_labels, val_labels =\\\n     tuple(torch.tensor(data) for data in\n           [train_inputs, val_inputs, train_labels, val_labels])\n \n     # Specify batch_size\n     batch_size = 10\n \n     # Create DataLoader for training data\n     train_data = TensorDataset(train_inputs, train_labels)\n     train_sampler = RandomSampler(train_data)\n     train_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=batch_size)\n \n     # Create DataLoader for validation data\n     val_data = TensorDataset(val_inputs, val_labels)\n     val_sampler = SequentialSampler(val_data)\n     val_dataloader = DataLoader(val_data, sampler=val_sampler, batch_size=batch_size)\n \n     return train_dataloader, val_dataloaderWe will use 90% of the dataset for training and 10% for validation.from sklearn.model_selection import train_test_split\n \n # Train Test Split\n train_inputs, val_inputs, train_labels, val_labels = train_test_split(\n     input_ids, labels, test_size=0.1, random_state=42)\n \n # Load data to PyTorch DataLoader\n train_dataloader, val_dataloader = \\\n data_loader(train_inputs, val_inputs, train_labels, val_labels, batch_size=50)## 3. Model**CNN Architecture**\n \n The picture below is the illustration of the CNN architecture that we are going to build with three filter sizes: 2, 3, and 4, each of which has 2 filters.![](https://github.com/chriskhanhtran/CNN-Sentence-Classification-PyTorch/blob/master/cnn-architecture.JPG?raw=true)\n \n *CNN Architecture (Source: Zhang, 2015)*\n \n ```python\n # Sample configuration:\n filter_sizes = [2, 3, 4]\n num_filters = [2, 2, 2]\n ```\n \n Suppose that we are classifying the sentence \"***I like this movie very much!***\" ($N = 7$ tokens) and the dimensionality of word vectors is $d=5$. After applying the embedding layer on the input token ids, the sample sentence is presented as a 2D tensor with shape (7, 5) like an image.\n \n $$\\mathrm{x_{emb}} \\quad \\in \\mathbb{R}^{7 \\times 5}$$\n \n We then use 1-dimesional convolution to extract features from the sentence. In this example, we have 6 filters in total, and each filter has shape $(f_i, d)$ where $f_i$ is the filter size for $i \\in \\{1,...,6\\}$. Each filter will then scan over $\\mathrm{x_{emb}}$ and returns a feature map:\n \n $$\\mathrm{x_{conv_ i} = Conv1D(x_{emb})} \\quad \\in \\mathbb{R}^{N-f_i+1}$$\n \n Next, we apply the ReLU activation to $\\mathrm{x_{conv_{i}}}$ and use max-over-time-pooling to reduce each feature map to a single scalar. Then we concatenate these scalars into the final feature vector which will be fed to a fully connected layer to compute the final scores for our classes (logits).\n \n $$\\mathrm{x_{pool_i} = MaxPool(ReLU(x_{conv_i}))} \\quad \\in \\mathbb{R}$$\n \n $$\\mathrm{x_{fc} = \\texttt{concat}(x_{pool_i})} \\quad \\in \\mathbb{R}^6$$\n \n The idea here is that each filter will capture different semantic signals in the sentence (ie. happiness, humor, politic, anger...) and max-pooling will record only the strongest signal over the sentence. This logic makes sense because humans also perceive the sentiment of a sentence based on its strongest word/signal.\n \n Finally, we use a fully connected layer with the weight matrix $\\mathbf{W_{fc}} \\in \\mathbb{R}^{2 \\times 6} $ and dropout to compute $\\mathrm{logits}$, which is a vector of length 2 that keeps the scores for 2 classes.\n \n $$\\mathrm{logits = Dropout(\\mathbf{W_{fc}}x_{fc})}  \\in \\mathbb{R}^2$$\n \n An in-depth explanation of CNN can be found in this [article](https://cs231n.github.io/convolutional-networks/) and this [video](https://www.youtube.com/watch?v=YRhxdVk_sIs).\n \n \n \n \n \n \n \n \n### 3.1. Create CNN ModelFor simplicity, the model above has very small configurations. The final model we'll use is much bigger but has the same architecture:\n \n |Description         |Values           |\n |:------------------:|:---------------:|\n |input word vectors  |fastText         |\n |embedding size      |300              |\n |filter sizes        |(3, 4, 5)        |\n |num filters         |(100, 100, 100)  |\n |activation          |ReLU             |\n |pooling             |1-max pooling    |\n |dropout rate        |0.5              |\n \nimport torch\n import torch.nn as nn\n import torch.nn.functional as F\n \n class CNN_NLP(nn.Module):\n     \"\"\"An 1D Convulational Neural Network for Sentence Classification.\"\"\"\n     def __init__(self,\n                  pretrained_embedding=None,\n                  freeze_embedding=False,\n                  vocab_size=None,\n                  embed_dim=300,\n                  filter_sizes=[3, 4, 5],\n                  num_filters=[100, 100, 100],\n                  num_classes=4,\n                  dropout=0.5):\n         \"\"\"\n         The constructor for CNN_NLP class.\n \n         Args:\n             pretrained_embedding (torch.Tensor): Pretrained embeddings with\n                 shape (vocab_size, embed_dim)\n             freeze_embedding (bool): Set to False to fine-tune pretraiend\n                 vectors. Default: False\n             vocab_size (int): Need to be specified when not pretrained word\n                 embeddings are not used.\n             embed_dim (int): Dimension of word vectors. Need to be specified\n                 when pretrained word embeddings are not used. Default: 300\n             filter_sizes (List[int]): List of filter sizes. Default: [3, 4, 5]\n             num_filters (List[int]): List of number of filters, has the same\n                 length as `filter_sizes`. Default: [100, 100, 100]\n             n_classes (int): Number of classes. Default: 2\n             dropout (float): Dropout rate. Default: 0.5\n         \"\"\"\n \n         super(CNN_NLP, self).__init__()\n         # Embedding layer\n         if pretrained_embedding is not None:\n             self.vocab_size, self.embed_dim = pretrained_embedding.shape\n             self.embedding = nn.Embedding.from_pretrained(pretrained_embedding,\n                                                           freeze=freeze_embedding)\n         else:\n             self.embed_dim = embed_dim\n             self.embedding = nn.Embedding(num_embeddings=vocab_size,\n                                           embedding_dim=self.embed_dim,\n                                           padding_idx=0,\n                                           max_norm=5.0)\n         # Conv Network\n         self.conv1d_list = nn.ModuleList([\n             nn.Conv1d(in_channels=self.embed_dim,\n                       out_channels=num_filters[i],\n                       kernel_size=filter_sizes[i])\n             for i in range(len(filter_sizes))\n         ])\n         # Fully-connected layer and Dropout\n         self.fc = nn.Linear(np.sum(num_filters), num_classes)\n         self.dropout = nn.Dropout(p=dropout)\n \n     def forward(self, input_ids):\n         \"\"\"Perform a forward pass through the network.\n \n         Args:\n             input_ids (torch.Tensor): A tensor of token ids with shape\n                 (batch_size, max_sent_length)\n \n         Returns:\n             logits (torch.Tensor): Output logits with shape (batch_size,\n                 n_classes)\n         \"\"\"\n \n         # Get embeddings from `input_ids`. Output shape: (b, max_len, embed_dim)\n         x_embed = self.embedding(input_ids).float()\n \n         # Permute `x_embed` to match input shape requirement of `nn.Conv1d`.\n         # Output shape: (b, embed_dim, max_len)\n         x_reshaped = x_embed.permute(0, 2, 1)\n \n         # Apply CNN and ReLU. Output shape: (b, num_filters[i], L_out)\n         x_conv_list = [F.relu(conv1d(x_reshaped)) for conv1d in self.conv1d_list]\n \n         # Max pooling. Output shape: (b, num_filters[i], 1)\n         x_pool_list = [F.max_pool1d(x_conv, kernel_size=x_conv.shape[2])\n             for x_conv in x_conv_list]\n         \n         # Concatenate x_pool_list to feed the fully connected layer.\n         # Output shape: (b, sum(num_filters))\n         x_fc = torch.cat([x_pool.squeeze(dim=2) for x_pool in x_pool_list],\n                          dim=1)\n         \n         # Compute logits. Output shape: (b, n_classes)\n         logits = self.fc(self.dropout(x_fc))\n \n         return logits### 3.2. OptimizerTo train Deep Learning models, we need to define a loss function and minimize this loss. We'll use back-propagation to compute gradients and use an optimization algorithm (ie. Gradient Descent) to minimize the loss. The original paper used the Adadelta optimizer.import torch.optim as optim\n \n def initilize_model(pretrained_embedding=None,\n                     freeze_embedding=False,\n                     vocab_size=None,\n                     embed_dim=300,\n                     filter_sizes=[3, 4, 5],\n                     num_filters=[100, 100, 100],\n                     num_classes=4,\n                     dropout=0.5,\n                     learning_rate=0.01):\n     \"\"\"Instantiate a CNN model and an optimizer.\"\"\"\n \n     assert (len(filter_sizes) == len(num_filters)), \"filter_sizes and \\\n     num_filters need to be of the same length.\"\n \n     # Instantiate CNN model\n     cnn_model = CNN_NLP(pretrained_embedding=pretrained_embedding,\n                         freeze_embedding=freeze_embedding,\n                         vocab_size=vocab_size,\n                         embed_dim=embed_dim,\n                         filter_sizes=filter_sizes,\n                         num_filters=num_filters,\n                         num_classes=4,\n                         dropout=0.5)\n     \n     # Send model to `device` (GPU/CPU)\n     cnn_model.to(device)\n \n     # Instantiate Adadelta optimizer\n     optimizer = optim.Adadelta(cnn_model.parameters(),\n                                lr=learning_rate,\n                                rho=0.95)\n \n     return cnn_model, optimizer### 3.3. Training LoopFor each epoch, the code below will perform a forward step to compute the *Cross Entropy* loss, a backward step to compute gradients and use the optimizer to update weights/parameters. At the end of each epoch, the loss on training data and the accuracy over the validation data will be printed to help us keep track of the model's performance. The code is heavily annotated with detailed explanations.import random\n import time\n \n # Specify loss function\n loss_fn = nn.CrossEntropyLoss()\n \n def set_seed(seed_value=42):\n     \"\"\"Set seed for reproducibility.\"\"\"\n \n     random.seed(seed_value)\n     np.random.seed(seed_value)\n     torch.manual_seed(seed_value)\n     torch.cuda.manual_seed_all(seed_value)\n \n def train(model, optimizer, train_dataloader, val_dataloader=None, epochs=10):\n     \"\"\"Train the CNN model.\"\"\"\n     \n     # Tracking best validation accuracy\n     best_accuracy = 0\n \n     # Start training loop\n     print(\"Start training...\\n\")\n     print(f\"{'Epoch':^7} | {'Train Loss':^12} | {'Val Loss':^10} | { 'Val Acc':^9} | {'Elapsed':^9}\")\n     print(\"-\"*60)\n \n     for epoch_i in range(epochs):\n         # =======================================\n         #               Training\n         # =======================================\n \n         # Tracking time and loss\n         t0_epoch = time.time()\n         total_loss = 0\n \n         # Put the model into the training mode\n         model.train()\n \n         for step, batch in enumerate(train_dataloader):\n             # Load batch to GPU\n             b_input_ids, b_labels = tuple(t.to(device) for t in batch)\n \n             # Zero out any previously calculated gradients\n             model.zero_grad()\n \n             # Perform a forward pass. This will return logits.\n             logits = model(b_input_ids)\n \n             # Compute loss and accumulate the loss values\n             loss = loss_fn(logits, b_labels)\n             total_loss += loss.item()\n \n             # Perform a backward pass to calculate gradients\n             loss.backward()\n \n             # Update parameters\n             optimizer.step()\n \n         # Calculate the average loss over the entire training data\n         avg_train_loss = total_loss / len(train_dataloader)\n \n         # =======================================\n         #               Evaluation\n         # =======================================\n         if val_dataloader is not None:\n             # After the completion of each training epoch, measure the model's\n             # performance on our validation set.\n             val_loss, val_accuracy = evaluate(model, val_dataloader)\n \n             # Track the best accuracy\n             if val_accuracy > best_accuracy:\n                 best_accuracy = val_accuracy\n \n             # Print performance over the entire training data\n             time_elapsed = time.time() - t0_epoch\n             print(f\"{epoch_i + 1:^7} | {avg_train_loss:^12.6f} | {val_loss:^10.6f} | {val_accuracy:^9.2f} | {time_elapsed:^9.2f}\")\n             \n     print(\"\\n\")\n     print(f\"Training complete! Best accuracy: {best_accuracy:.2f}%.\")\n \n def evaluate(model, val_dataloader):\n     \"\"\"After the completion of each training epoch, measure the model's\n     performance on our validation set.\n     \"\"\"\n     # Put the model into the evaluation mode. The dropout layers are disabled\n     # during the test time.\n     model.eval()\n \n     # Tracking variables\n     val_accuracy = []\n     val_loss = []\n \n     # For each batch in our validation set...\n     for batch in val_dataloader:\n         # Load batch to GPU\n         b_input_ids, b_labels = tuple(t.to(device) for t in batch)\n \n         # Compute logits\n         with torch.no_grad():\n             logits = model(b_input_ids)\n \n         # Compute loss\n         loss = loss_fn(logits, b_labels)\n         val_loss.append(loss.item())\n \n         # Get the predictions\n         preds = torch.argmax(logits, dim=1).flatten()\n \n         # Calculate the accuracy rate\n         accuracy = (preds == b_labels).cpu().numpy().mean() * 100\n         val_accuracy.append(accuracy)\n \n     # Compute the average accuracy and loss over the validation set.\n     val_loss = np.mean(val_loss)\n     val_accuracy = np.mean(val_accuracy)\n \n     return val_loss, val_accuracy## 4. Evaluation In the original paper, the author tried different variations of the model.\n - **CNN-rand**: The baseline model where the embedding layer is randomly initialized and then updated during training.\n - **CNN-static**: A model with pretrained vectors. However, the embedding layer is freezed during training.\n - **CNN-non-static**: Same as above but the embedding layers are fine-tuned during training.\n \n We will experiment with all 3 variations and compare their performance. Below is the report of our results and the results in the original paper.\n \n |Model            |Kim's results  |Our results  |\n |:----------------|:-------------:|:-----------:|\n |CNN-rand         |76.1           |74.2         |\n |CNN-static       |81.0           |82.7         |\n |CNN-non-static   |81.5           |84.4         |\n \n Randomness could cause the difference in the results. I think the reason for the improvement in our results is that we used fastText pretrained vectors, which are of higher quality than word2vec vectors that the author used.\nword2idx# CNN-rand: Word vectors are randomly initialized.\n set_seed(42)\n cnn_rand, optimizer = initilize_model(vocab_size=len(word2idx),\n                                       embed_dim=300,\n                                       learning_rate=0.25,\n                                       dropout=0.5)\n train(cnn_rand, optimizer, train_dataloader, val_dataloader, epochs=5)embeddings.shapeembeddings.dtype# CNN-static: fastText pretrained word vectors are used and freezed during training.\n set_seed(42)\n cnn_static, optimizer = initilize_model(pretrained_embedding=embeddings,\n                                         freeze_embedding=True,\n                                         learning_rate=0.25,\n                                         dropout=0.5)\n train(cnn_static, optimizer, train_dataloader, val_dataloader, epochs=10)# CNN-non-static: fastText pretrained word vectors are fine-tuned during training.\n set_seed(42)\n cnn_non_static, optimizer = initilize_model(pretrained_embedding=embeddings,\n                                             freeze_embedding=False,\n                                             learning_rate=0.25,\n                                             dropout=0.5)\n train(cnn_non_static, optimizer, train_dataloader, val_dataloader, epochs=5)## 5. Test ModelLet's test our CNN-non-static model on some examples.def predict(text, model=cnn_non_static.to(\"cpu\"), max_len=62):\n     \"\"\"Predict probability that a review is positive.\"\"\"\n \n     # Tokenize, pad and encode text\n     tokens = word_tokenize(text.lower())\n     padded_tokens = tokens + ['<pad>'] * (max_len - len(tokens))\n     input_id = [word2idx.get(token, word2idx['<unk>']) for token in padded_tokens]\n \n     # Convert to PyTorch tensors\n     input_id = torch.tensor(input_id).unsqueeze(dim=0)\n \n     # Compute logits\n     logits = model.forward(input_id)\n \n     #  Compute probability\n     probs = F.softmax(logits, dim=1).squeeze(dim=0)\n \n     print(f\"This review is {probs[1] * 100:.2f}% positive.\")Our model can easily regconize reviews with strong negative signals. On samples that have mixed feelings but positive sentiment overvall, our model also gets excellent results.predict(\"A sore throat.\")\n## 6. Advice for PractitionersIn [***A Sensitivity Analysis of (and Practitioners' Guide to) Convolutional Neural Networks for Sentence Classification***](https://arxiv.org/abs/1510.03820) (Zhang, 2015), the authors conducted a sensitivity analysis of the above CNN architecture by running it many different sets of hyperparameters. Based on main empirical findings of the research, below are some advice for practioners to choose hyperparameters when applying this architecture for sentence classification tasks:\n - **Input word vectors:** Using pretrained word vectors such as word2vec, Glove (or fastText in our implementation) yields much better results than using one-hot vectors or randomly initialized vectors.\n - **Filter region size** can have a large effect on performance, and should be tuned. A reasonable range might be 1~10. For example, using `filter_size=[7]` and `num_filters=[400]` yields the best result in the MR dataset.\n - **Number of feature maps:** try values from 100 to 600 for each filter region size.\n - **Activation funtions:** ReLu and tanh are the best candidates.\n - **Pooling:** Use 1-max pooling.\n - **Regularization:** When increasing number of feature maps, try imposing stronger regularization, e.g. a dropout rate larger than 0.5.\n \n \n \n## Bonus: Skorch: A Scikit-like Library for PyTorch Modules If you find the training loop in PyTorch intimidating with a lot of steps and wonder why those steps aren't wrapped in a function like `model.fit()` and `model.predict()` in `scikit-learn` library. Actually it is something I like in PyTorch. It allows me to manipulate my codes to add extra customizations during training like gradient clipping or updating learning rates. And because I build my model and training loop block by block, when my model runs into errors, it's easier for me to navigate the bugs. However, when I need to deploy a baseline model quickly, writing an entire training loop is really a burden. It's when I come to `skorch`.\n \n `skorch` is \"a scikit-learn compatible neural network library that wraps PyTorch.\" There is no need to create `DataLoader` or write a training/evaluation loop. All you just need to do is defining the model and optimizer as in the code below, then a simple `net.fit(X, y)` is enough.\n \n `skorch` does not only make it neat and fast to train your Deep Learning models, it also provides even more powerful support. You can specify `callbacks` parameters to define early stopping and when to save your model. You can also combine `skorch` model with `scikit-learn` methods to do cross-validation and hyperparameter tuning with grid-search. Please check out the [documentation](https://skorch.readthedocs.io/en/stable/index.html#) to explore this powerful PyTorch library for Deep Learning.\n \n \n \n!pip install skorch\n from skorch import NeuralNetClassifier\n from skorch.helper import predefined_split\n from skorch.callbacks import EarlyStopping, Checkpoint, LoadInitState\n from skorch.dataset import Dataset\n \n # Specify validation set\n val_dataset = Dataset(val_inputs, val_labels)\n \n # Specify callbacks and checkpoints\n cp = Checkpoint(monitor='valid_acc_best', dirname='exp1')\n callbacks = [\n     ('early_stop', EarlyStopping(monitor='valid_acc', patience=5, lower_is_better=False)),\n     cp\n ]\n \n net = NeuralNetClassifier(\n     # Module\n     module=CNN_NLP,\n     module__pretrained_embedding=embeddings,\n     module__freeze_embedding=False,\n     module__dropout=0.5,\n     # Optimizer\n     criterion=nn.CrossEntropyLoss,\n     optimizer=optim.Adadelta,\n     optimizer__lr=0.25,\n     optimizer__rho=0.95,\n     # Others\n     max_epochs=5,\n     batch_size=10,\n     train_split=predefined_split(val_dataset),\n     iterator_train__shuffle=True,\n     warm_start=False,\n     callbacks=callbacks,\n     device=device\n )`skorch` also prints training results in a very nice table. My training loop in section 3 is inspired by this format. When model (checkpoints) are saved, you can see the `+` sign in column `cp`.set_seed(42)\n _ = net.fit(np.array(train_inputs), train_labels)\n \n valid_acc_best = np.max(net.history[:, 'valid_acc'])\n print(f\"Training complete! Best accuracy: {valid_acc_best * 100:.2f}%\")As Deep Learning model can overfit the training data, it's important to save our model when it fits our validation data just right. After training, we can load our model from the last checkpoint to make predictions.# Load parameters from checkpoint\n net.load_params(checkpoint=cp)\n \n predict(\"All of friends slept while watching this movie. But I really enjoyed it.\", model=net)\n## ConclusionBefore the rise of huge and complicated models using Transformer architecture, a simple CNN architecture with one layer of convolution can yeild excellent performance on sentence classification tasks. The model can take advantages of unsupervise pre-training of word vectors to improve overall performance. Improvements can be made in this architecture by increasing the number of CNN layers or utilizing sub-word model (using BPE tokenizer and fastText pretrained sub-word vectors). Because of its speed, we can use the CNN model as a strong baseline model before trying more complicated models such as BERT.\n \n Thank you for staying with me to this point. If interested, you can check out other articles in my NLP tutorial series:\n - [Tutorial: Fine-tuning BERT for Sentiment Analysis](https://chriskhanhtran.github.io/posts/bert_for_sentiment_analysis/)# !pip install requests\n # !pip install beautifulsoup4\n # !pip install gTTS# import modules\n import os\n import requests\n from bs4 import BeautifulSoup\n \n from gtts import gTTS\n## Skin Cancer \n #### Website: https://www.skincancer.org/skin-cancer-information/skin-cancer-pictures/url = 'https://www.skincancer.org/skin-cancer-information/skin-cancer-pictures/'\n headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36'}\n response = requests.get(url, headers=headers)\n #print(response.status_code)cancer_types = [\"Basal Cell Carcinoma (BCC)\",\"Squamous Cell Carcinoma (SCC)\",\"Melanoma\", \"Merkel Cell Carcinoma (MCC)\",\n               \"Actinic Keratosis\"]\n \n cancer_ids = ['bcc', 'scc', 'melanoma','merkel','ak']\ndef get_img_cap_cancer(cancer_id):\n     soup = BeautifulSoup(response.content, 'html.parser')\n     bcc_sec = soup.find('section',attrs = {'id':cancer_id})\n \n     sec_img = bcc_sec.find_all('img')\n     sec_imgs = []\n     for img in sec_img:\n         if img.get('src').find(\"https\")== 0:\n             sec_imgs.append(img.get('src'))\n \n     bcc_sec_cap = bcc_sec.find_all('figcaption')\n     captions = []\n     for cap in bcc_sec_cap:\n         captions.append(cap.get_text())\n \n     return sec_imgs, captions\nlanguage = 'en'    \n def get_text_to_speech(mytext):\n     myobj = gTTS(text=mytext, lang=language, slow=False)\n     return myobj\ndata = []\n id = 0\n for cancer_type,cancer_id in zip(cancer_types,cancer_ids):\n     bcc_sec_imgs,captions = get_img_cap_cancer(cancer_id)\n     for img,cap in zip(bcc_sec_imgs,captions):\n         get_text_to_speech(cap).save(f\"id_{id}.mp3\")\n         dataset_cancer_cell = {\n             'id':id,\n             'cancer_type':cancer_type,\n             'cancer_img':img,\n             'cancer_img_caption':cap,\n             'caption_speech':f\"id_{id}.mp3\",\n         }\n         id += 1\n         data.append(dataset_cancer_cell)import json\n with open('skin_cancer_dataset.json', 'w') as f:\n     json.dump(data, f)## Creating MMBT model### image.pyimport os\n import logging\n import torch\n import torch.nn as nn\n import torchvision\n import torch.nn.functional as F\n \n \n logger = logging.getLogger(__name__)\n \n # mapping number of image embeddings to AdaptiveAvgPool2d output size\n POOLING_BREAKDOWN = {1: (1, 1), 2: (2, 1), 3: (3, 1), 4: (2, 2), 5: (5, 1), 6: (3, 2), 7: (7, 1), 8: (4, 2), 9: (3, 3)}\n \n # module assumes that the directory where the saved chexnet weight is in the same level as this module\n MMBT_DIR_PARENT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n DATA_DIR = os.path.join(MMBT_DIR_PARENT, \"data\")\n MODELS_DIR = os.path.join(DATA_DIR, \"models\")\n SAVED_CHEXNET = os.path.join(MODELS_DIR, \"saved_chexnet.pt\")\n \n \n class ImageEncoderDenseNet(nn.Module):\n     def __init__(self, num_image_embeds, saved_model=True, path=os.path.join(MODELS_DIR, SAVED_CHEXNET)):\n         \"\"\"\n \n         :type num_image_embeds: int\n         :param num_image_embeds: number of image embeddings to generate; 1-9 as they map to specific numbers of pooling\n         output shape in the 'POOLING_BREAKDOWN'\n         :param saved_model: True to load saved pre-trained model False to use torch pre-trained model\n         :param path: path to the saved .pt model file\n         \"\"\"\n         super().__init__()\n         if saved_model:\n             # loading pre-trained weight, e.g. ChexNet\n             # the model here expects the weight to be regular Tensors and NOT cuda Tensor\n             model = torch.load(path)\n             logger.info(f\"Saved model loaded from: {path}\")\n         else:\n             model = torchvision.models.densenet121(pretrained=True)\n \n         # DenseNet architecture last layer is the classifier; we only want everything before that\n         modules = list(model.children())[:-1]\n         self.model = nn.Sequential(*modules)\n         # self.model same as original DenseNet self.features part of the forward function\n         self.pool = nn.AdaptiveAvgPool2d(POOLING_BREAKDOWN[num_image_embeds])\n \n     def forward(self, input_modal):\n         \"\"\"\n         B = batch\n         N = number of image embeddings\n         1024 DenseNet embedding size, this can be changed when instantiating MMBTconfig for modal_hidden_size\n \n         Bx3x224x224 (this is input shape) -> Bx1024x7x7 (this is shape after DenseNet CNN layers before the last layer)\n         -> Bx1024xN (this is after torch.flatten step in this function below) -> BxNx1024 (this is the shape of the\n         output tensor)\n \n         :param input_modal: image tensor\n         :return:\n         \"\"\"\n         # Bx3x224x224 -> Bx1024x7x7 -> Bx1024xN -> BxNx1024\n         features = self.model(input_modal)\n         out = F.relu(features, inplace=True)\n         out = self.pool(out)\n         out = torch.flatten(out, start_dim=2)\n         out = out.transpose(1, 2).contiguous()\n \n         return out  # BxNx1024!pip install ftfy regex tqdm\n !pip install git+https://github.com/openai/CLIP.git\n !pip install pyarrowimport os\n import torch\n import clip\n import numpy as np\n import pandas as pd\n import pyarrow.feather as feather\n from PIL import Image\n from urllib import request\n from tqdm import tqdm\n from torch.utils.data import Dataset, DataLoader\n from torchvision import datasets, transformsdevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n model, preprocess = clip.load(\"ViT-B/32\", device=device)\n deviceimport json\n \n with open('/content/skin_cancer_dataset.json') as user_file:\n     ds = user_file.read()\n     \n parsed_json = json.loads(ds)\n print(parsed_json)parsed_jsontkns,final_labels = [],[]\n for i,ele in enumerate(parsed_json):\n     print(f\"{i}  -> {ele['cancer_img_caption']}\")\n     tkns.append(ele['cancer_img_caption'])\n     final_labels.append(ele['cancer_type'])final_labelslen(set(final_labels))import requests\n img_ids = []\n headers = {\"User-Agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\",\n            \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n            \"Accept-Language\": \"en-US,en;q=0.9\"\n            }\n \n for i,ele in enumerate(parsed_json):\n     print(f\"{i}  -> {ele['cancer_img']}\")\n     img_ids.append(i)\n     image_url = ele['cancer_img']\n     img_data = requests.get(url=image_url, headers=headers).content\n     with open(f'{i}.jpg', 'wb') as handler:\n         handler.write(img_data)\nlabels = [\"Basal Cell Carcinoma (BCC)\",\"Squamous Cell Carcinoma (SCC)\",\"Melanoma\", \"Merkel Cell Carcinoma (MCC)\",\n               \"Actinic Keratosis\"]\n text = clip.tokenize(tkns).to(device)text.shapetext# image embeddings\n images = [\n         preprocess(\n             Image.open(f\"/content/{img_id}.jpg\")\n         ) for img_id in img_ids\n     ]\n \n image_input = torch.tensor(np.stack(images)).to(device)\n image_features = model.encode_image(image_input)image_featuresimage_features.shape# combining two vectors\n combo = torch.cat([text,image_features],dim = 1)combocombo.shape# combo_embed = torch.nn.functional.normalize(combo)### Random Forest Classifier for Combo *Embedding*# imports\n import pandas as pd\n import numpy as np\n \n from sklearn.ensemble import RandomForestClassifier\n from sklearn.model_selection import train_test_split\n from sklearn.metrics import classification_report, accuracy_score\n \n # load data\n \n # df = pd.read_csv(datafile_path)\n # df[\"embedding\"] = df.embedding.apply(eval).apply(np.array)  # convert string to array\n \n combo_embedding = combo.cpu().detach().numpy()\n # split data into train and test\n X_train, X_test, y_train, y_test = train_test_split(\n     combo_embedding, final_labels, test_size=0.2, random_state=42\n )\n \n # train random forest classifier\n clf = RandomForestClassifier(n_estimators=100)\n clf.fit(X_train, y_train)\n preds = clf.predict(X_test)\n probas = clf.predict_proba(X_test)\n \n report = classification_report(y_test, preds)\n print(report)### Support Vector Machine for combo embeddingfrom sklearn.svm import SVC ,SVR\n \n # split data into train and test\n X_train, X_test, y_train, y_test = train_test_split(\n     combo_embedding, final_labels, test_size=0.2, random_state=42\n )\n \n svc_model = SVC(kernel='rbf', C = 2)\n svc_model.fit(X_train, y_train)\n # for validation data\n preds = svc_model.predict(X_test)\n \n report = classification_report(y_test, preds)\n print(report)### Random Forest Classifier for text *Embedding* only\n \n \ntext_embed = text.cpu().detach().numpy()\n \n \n X_train, X_test, y_train, y_test = train_test_split(\n     text_embed, final_labels, test_size=0.2, random_state=42\n )\n \n # train random forest classifier\n clf = RandomForestClassifier(n_estimators=100)\n clf.fit(X_train, y_train)\n preds = clf.predict(X_test)\n probas = clf.predict_proba(X_test)\n \n report = classification_report(y_test, preds)\n print(report)### Random Forest Classifier for image *Embedding* onlyimg_embed = image_features.cpu().detach().numpy()\n X_train, X_test, y_train, y_test = train_test_split(\n     img_embed, final_labels, test_size=0.2, random_state=42\n )\n \n # train random forest classifier\n clf = RandomForestClassifier(n_estimators=100)\n clf.fit(X_train, y_train)\n preds = clf.predict(X_test)\n probas = clf.predict_proba(X_test)\n \n report = classification_report(y_test, preds)\n print(report)### Multilayer Perceptron Classifier for combo *Embedding* only\nfrom sklearn.neural_network import MLPClassifiercombo_embedding = combo.cpu().detach().numpy()\n # split data into train and test\n X_train, X_test, y_train, y_test = train_test_split(\n     combo_embedding, final_labels, test_size=0.2, random_state=42\n )\n \n clf_mlp = MLPClassifier(hidden_layer_sizes=(20,20,20), activation='relu', learning_rate_init=0.01, learning_rate='adaptive').fit(X_train, y_train)\n clf_mlp.fit(X_train, y_train)\n preds = clf_mlp.predict(X_test)\n probas = clf_mlp.predict_proba(X_test)\n \n report = classification_report(y_test, preds)\n print(report)### Multilayer Perceptron Classifier for text *Embedding* only\ntext_embed = text.cpu().detach().numpy()\n \n \n X_train, X_test, y_train, y_test = train_test_split(\n     text_embed, final_labels, test_size=0.2, random_state=42\n )\n \n clf = MLPClassifier(hidden_layer_sizes=(20,20,20), activation='relu', learning_rate_init=0.01, learning_rate='adaptive').fit(X_train, y_train)\n preds = clf.predict(X_test)\n probas = clf.predict_proba(X_test)\n \n report = classification_report(y_test, preds)\n print(report)### Multilayer Perceptron Classifier for image *Embedding* only\nimg_embed = image_features.cpu().detach().numpy()\n X_train, X_test, y_train, y_test = train_test_split(\n     img_embed, final_labels, test_size=0.2, random_state=42\n )\n \n clf = MLPClassifier(hidden_layer_sizes=(20,20,20), activation='relu', learning_rate_init=0.01, learning_rate='adaptive').fit(X_train, y_train)\n \n preds = clf.predict(X_test)\n probas = clf.predict_proba(X_test)\n \n report = classification_report(y_test, preds)\n print(report)# BATCH_SIZE = 10\n # ln = len(img_ids)\n \n # results = []\n \n # for i in tqdm(range(0,ln,BATCH_SIZE)):\n #     images = [\n #         preprocess(\n #             Image.open(f\"/content/{img_id}.jpg\")\n #         ) for img_id in img_ids[i:i+BATCH_SIZE]\n #     ]\n #     image_input = torch.tensor(np.stack(images)).to(device)\n #     with torch.no_grad():\n #         image_features = model.encode_image(image_input)\n #         logits_per_image, logits_per_text = model(image_input, text)\n #         # The softmax function takes the original confidence and applys a transform to make all the confidence add up to one\n #         probs = logits_per_image.softmax(dim=-1).cpu().numpy()\n #         results.append(probs)\n \n # res = np.concatenate(results,axis=0)\n # choices = np.argmax(res,axis=1)\n # print(choices.shape)\n # getlabel = lambda x:labels[x]\n # vgetlabel = np.vectorize(getlabel)\n # times = vgetlabel(choices)\n # print(times)", "https://github.com/agnik2019/capture_react": "import Aboutus from \"./pages/Aboutus\"\nimport GlobalStyle from \"./components/GlobalStyle\"\nimport Nav from './components/Nav'\nimport ContactUs from \"./pages/ContactUs\";\nimport OurWork from './pages/OurWork';\nimport { Switch, Route, useLocation } from 'react-router-dom';\nimport MovieDetail from \"./pages/MovieDetail\";\n\n//Animation\nimport {AnimatePresence } from 'framer-motion';\n\nimport ScrollTop from \"./components/ScrollTop\";\n\n\nfunction App() {\n  const location = useLocation();\n  return (\n    <div className=\"App\">\n      <GlobalStyle />\n      <ScrollTop />\n      <Nav />\n     < AnimatePresence exitBeforeEnter>\n      <Switch location={location} key={location.pathname} >\n      <Route path=\"/\" exact >\n           <Aboutus/>\n      </Route>\n      <Route path=\"/work\" exact>\n          <OurWork/>\n      </Route>\n    <Route path=\"/work/:id\" >\n      <MovieDetail />\n    </Route>\n      <Route path=\"/contact\" >\n         <ContactUs/>\n      </Route>\n      </Switch>\n      </AnimatePresence>\n    </div>\n  );\n}\n\nexport default App;\nexport const pageAnimation = {\n    hidden:{\n        opacity:0,\n        y:300\n    },\n    show:{\n        opacity:1,\n        y:0,\n        transition:{\n            duration:0.5,\n            when:\"beforeChildren\",\n            staggerChildren:0.25,\n\n        },\n    },\n    exit:{\n        opacity:0,\n        transition:{\n            duration:0.5,\n           \n        },\n    },\n}\n\nexport const titleAnim = {\n    hidden: {y:100},\n    show:{\n        y:0,\n        transition: {duration:0.75, ease:'easeOut'},\n    },\n}\n\nexport const fade = {\n    hidden:{opacity:0},\n    show:{\n        opacity:1,\n        transition:{ ease:'easeOut', duration:0.75},\n    },\n};\n\nexport const photoAnim = {\n    hidden:{scale:1.5, opacity:0},\n    show:{\n        scale:1,\n        opacity:1,\n        transition:{\n            ease:\"easeOut\",\n            duration:0.75,\n            delay:0.5,\n        },\n    }\n};\n\nexport const lineAnim = {\n    hidden: {width: '0%'},\n    show:{\n        width:\"100%\",\n        transition:{duration:1},\n    },\n};\n\nexport const slider = {\n    hidden: {x:'-130%', skew: '45deg'},\n    show:{\n        x:'100%',\n        skew:'0deg',\n        transition:{ease:'easeOut', duration:1},\n    },\n};\n\nexport const sliderContainer = {\n    hidden:{opacity:1},\n    show:{opacity:1, transition:{staggerChildren:0.15, ease:'easeOut'}}\n};\n\nexport const scrollReveal = {\n    hidden:{\n        opacity:0, \n        scale:1.2, \n        transition:\n        {\n            duration:0.5,\n        }\n    },\n    show:{\n        opacity:1,\n        scale:1,\n        transition:{\n            duration:0.5,\n        }\n    }\n};\n\nexport const swoopAdoop = {\n    hidden: {width:'-30%'},\n    show:{\n        width:'100%',\n        transition:{ease:'easeOut', duration:1},\n    },\n};import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport {BrowserRouter} from 'react-router-dom';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter >\n    <App />\n    </ BrowserRouter >\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n//Import Images\nimport athlete from './img/athlete-small.png';\nimport goodtimes from './img/goodtimes-small.png';\nimport theracer from './img/theracer-small.png';\nimport athlete2 from './img/athlete2.png';\nimport goodtimes2 from './img/good-times2.jpg';\nimport theracer2 from './img/the-racer2.jpg';\n\nexport const MovieState = () => {\n  return [\n    {\n      title: 'The Athlete',\n      mainImg: athlete,\n      secondaryImg: athlete2,\n      url: '/work/the-athlete',\n      awards: [\n        {\n          title: 'Truly A masterpiece',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'Fresh look on a brutal sport.',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'It\u2019s okay lmao.',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n      ],\n    },\n    {\n      title: 'Good Times',\n      mainImg: goodtimes,\n      url: '/work/good-times',\n      secondaryImg: goodtimes2,\n      awards: [\n        {\n          title: 'Truly A masterpiece',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'Fresh look on a brutal sport.',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'It\u2019s okay lmao.',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n      ],\n    },\n    {\n      title: 'The Racer',\n      mainImg: theracer,\n      url: '/work/the-racer',\n      secondaryImg: theracer2,\n      awards: [\n        {\n          title: 'Truly A masterpiece',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'Fresh look on a brutal sport.',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n        {\n          title: 'It\u2019s okay lmao.',\n          description:\n            '\u201cLorem Ipsum is simply dummy text of the printing and typesetting industry.\u201d',\n        },\n      ],\n    },\n  ];\n};\nimport styled from 'styled-components';\nimport {motion} from 'framer-motion';\n\n//Styled Components\nexport const About = styled(motion.div)`\n    min-height:90vh;\n    display:flex;\n    align-items:center;\n    justify-content:center;\n    padding:5rem 10rem;\n    color:white;\n`;\n\nexport const Description = styled.div`\n    flex : 1;\n    padding-right: 5rem;\n    z-index:2;\n    h2{\n        font-weight:lighter;\n    }\n\n`;\n\nexport const Image = styled.div`\n    z-index:2;\n    flex:1;\n    overflow:hidden;\n    img{\n        width:100%;\n        height:80vh;\n        object-fit:cover;\n    }\n`;\n\nexport const Hide = styled.div`\n    overflow:hidden;\n`;\n\n", "https://github.com/agnik2019/CodeSearch": "", "https://github.com/agnik2019/Conduit_Android_kotlin": "", "https://github.com/agnik2019/CPP-Learnings": "#include<stdio.h>\nvoid main()\n{\n\tint i;\n\tscanf(\"%d\",&i);\n\tprintf(\"%d\",i>>2);\n}\n#include<stdio.h>\nvoid check_prime(int n)\n{\n\tint i,p=0;\n\tfor(i=2;i<n;i++)\n\t{\n\t\tif(n%i==0)\n\t\t\tp=1;\n\t}\n\tif(p==1 || n==0)\n\t\tprintf(\"Not Prime\\n\");\n\telse if(p==0)\n\t\tprintf(\"Prime\\n\");\n}\nvoid main()\n{\n\tint n;\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n>0)\n\t\t{\n\t\t\tcheck_prime(n);\n\t\t}\n\t}\n}\n#include<stdio.h>\nvoid main()\n{\n\tint n,a,b,c,i=1,arr[15];\n\tn=15;\n\ta=0;b=0;c=7;int d=6;\n\tarr[0]=0;arr[1]=0;\n\tfor(i=2;i<=14;i++)\n\t{\n\t\tif(i%2==0)\n\t\t{\n\t\t\tarr[i]=arr[i-2]+7;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tarr[i]=arr[i-2]+6;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",arr[14]);\n\n}\n\n\t\t\t\n#include<stdio.h>\n#include<ctype.h>\n#include<stdlib.h>\n#include<string.h>\n#define N 10000\nvoid main()\n{\n\tint i,n,pos;\n\tchar string[N];\n\tgets(string);\n\tn=strlen(string);\n\t//printf(\"%d\",n);\n\tif(n>=2)\n\t{\n\t\tfor(i=0;i<strlen(string);i++)\n\t\t{\n\t\t\tif(string[i]==' ')\n\t\t\t{\n\t\t\t\twhile(string[i]==' ')\n\t\t\t\t\ti++;\n\t\t\t\tpos=i-2;\n\t\t\t\tstring[pos]=toupper(string[pos]);\n\t\t\t}\n\t\t}\n\t\tstring[n-2]=toupper(string[n-2]);\n\t\t\n\t}\n\tif(n==1)\n\t{\n\t\tstring[0]=toupper(string[0]);\n\t}\n\tputs(string);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# include <iostream>\nusing namespace std;\n\nint main(){\n\t\n\tconst float DISC_1=0.2,DISC_2=0.3,DISC_3=0.4,DISC_4=0.5,COST_PER_UNIT=99;\n\tint units;\n\tfloat price=0,cost;\n\tcout << \"Enter number of units sold : \";\n\tcin >> units;\n\tcost = units*COST_PER_UNIT;\n\tif (units <=0){\n\t\tcout << \"Invalid input\\n\" ;\n\t}\n\telse if (units>=10 && units<20)\n\t\tprice=cost-(cost*DISC_1);\n\telse if(units>=20 && units<50)\n\t\tprice=cost-cost*DISC_2;\n\telse if(units>=50 && units<100)\n\t\tprice=cost-cost*DISC_3;\n\telse if(units>=100)\n\t\tprice=cost-cost*DISC_4;\n\telse\n\t\tprice=cost;\n\t\n\tcout << \"Total price is  $\" << price ;\t\t\n\treturn 0;\n}\n# include<iostream>\n# include<string>\nusing namespace std;\n\nvoid printbar(string store[],int sales[],int itr);\n\nint main(){\n\n\tconst int N=10;\n\tconst string DATE=\"July 24 2019\";\n\tstring name_of_manager;\n\tcout << \"Enter name of manager : \" ;\n\tgetline(cin,name_of_manager);\n\tint sales[N],n,o[N];\n\tstring store[5],k; \n\tcout << \"Enter number of regions \" ;\n\tcin >> n;\t\n\tgetline(cin,k);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcout <<\"Enter storename : \";\n\t\tgetline(cin,store[i]);\n\t\t//cout << a[i];\n\t}\t\n\tfor (int i=0;i<n;i++){\n\t\tcout << \"Enter sales of store \" << i+1 << \" : \" ;\n\t\tcin >> sales[i];\t\t\n\t}\n\n\tcout << \"\\n\\nDate : \" << DATE ;\n\tcout << \"\\nName of Manager : \" << name_of_manager << \"\\n\" ;\n\tint large = sales[0],pos=0,sum=0;\n\tfor (int i=0;i<n;i++){\n\t\tprintbar(store,sales,i);\n\t\tif(sales[i]>large){\n\t\t\tlarge=sales[i];\n\t\t\tpos=i;\t\t\n\t\t}\t\t\n\t\tsum+=sales[i];\n\t}\n\n\tcout << \"\\nThe top sales for the day is \" << store[pos] << \" with sales of $\" << large ;\n\n\tcout << \"\\nThe total sales on \" << DATE << \" is $\" << sum << \"\\n\" ;\n\t\n\treturn 0;\n}\n\nvoid printbar(string store[],int sales[],int itr)\n{\n\tcout << store[itr] << \" : \";\n\tfor(int i=1;i<=sales[itr]/100;i++){\n\t\tcout << \"*\";\n\t}\n\tcout << \"\\n\" ;\n\n}\n# include<iostream>\n# include<string>\nusing namespace std;\n\nint main()\n{\n\t\n\tint attempt,guesses=0,num;\n\tnum=(rand() % 10) + 2;\n\t//cout << num;\n\twhile(1)\n\t{\n\t\tcout << \"Enter your guess: \" ;\n\t\tcin >> attempt;\n\t\tguesses++;\n\t\tif(attempt<num)\n\t\t\tcout << \"Guess is low!\";\n\t\telse if (attempt>num)\n\t\t\tcout << \"Guess is high!\";\n\t\telse{\n\t\t\tcout << \"Guess is correct. Number of attempts : \" << guesses << \" !\\n\" ;\n\t\t\tbreak;\n\t\t}\n\t} \n\n\treturn 0;\n}\n# include<iostream>\n# include<string>\nusing namespace std;\n\nint main(){\n\tstring a[5];\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tcout <<\"Enter\";\n\t\tgetline(cin,a[i]);\n\t\t//cout << a[i];\n\t}\t\n\treturn 0;\n}\n# include<iostream>\n# include <fstream>\n\nusing namespace std;\n\nvoid printbar(ofstream &myfile,string store[],double sales[],int itr);\nvoid getSales(double *ptr, int n);\ndouble calcTotalSales(double * ptr, int size);\nint main(){\n\n\tconst string DATE=\"July 24 2019\";\n\tstring name_of_manager;\n\tcout << \"Enter name of manager : \" ;\n\tgetline(cin,name_of_manager);\n\tint n=5;\n\tdouble sales[5];\n\tdouble *ptr = sales;\n\tstring store[5]; \n\tstore[0] = \"City Centre\";\n\tstore[1] = \"Park Street\";\n\tstore[2] = \"Rajarhat\";\n\tstore[3] = \"South City\";\n\tstore[4] = \"Dum Dum\";\n\tofstream myfile;\n\tgetSales(ptr,n);\t\n\tmyfile.open(\"Sales_Report.txt\");\t\n\tif(myfile){\n\n\t\tmyfile << \"\\nDate : \" << DATE ;\n\t\tmyfile << \"\\nName of Manager : \" << name_of_manager << \"\\n\" ;\n\t\tint large = sales[0],pos=0;\n\t\tfor (int i=0;i<n;i++){\n\t\t\tprintbar(myfile,store,sales,i);\n\t\t\tif(sales[i]>large){\n\t\t\t\tlarge=sales[i];\n\t\t\t\tpos=i;\t\t\n\t\t\t}\t\t\n\t\t}\n\n\t\tmyfile << \"\\nThe top sales for the day is \" << store[pos] << \" with sales of $\" << large ;\n\n\t\tmyfile << \"\\nThe total sales on \" << DATE << \" is $\" << calcTotalSales(ptr,n) << \"\\n\" ;\n\t\n\n\t\tmyfile.close();\n\t}\n\telse{\n\t\n\tcout << \"Unable to open file\" ;\n\t\n\t}\n\treturn 0;\n}\n\nvoid printbar(ofstream &myfile, string store[],double sales[],int itr)\n{\n\t\n\t\tmyfile <<\"\\n\\n\" << store[itr] << \" : \";\n\t\tfor(int i=1;i<=sales[itr]/100;i++){\n\t\t\tmyfile << \"*\" ;\n\t\t}\t\n\t\tmyfile << \"\\n\" ;\n}\ndouble calcTotalSales(double * ptr, int n)\n{\n\t\tdouble sum = 0;\n\t\tfor (int i=0;i<n;i++){\n\t\t\tsum+= *(ptr + i);\n\t\t}\n\t\treturn sum;\n}\n\nvoid getSales(double *ptr,int size)\n{\n\t\n\tfor (int i=0;i<5;i++){\n\t\t\tcout << \"Enter sales of store \" << i+1 << \" : \" ;\n\t\t\tcin >> *(ptr+i);\t\t\n\t\t}\n\n\n}\n# include<iostream>\n# include<fstream>\nusing namespace std;\n\nint main()\n{\n\tifstream infile;\n\tint n=0;\n\tstring country[15],temp;\n    infile.open(\"countries.txt\");\n\tif(infile){\n\t\twhile (!infile.eof()) {\n\t\t   \t\tgetline(infile,country[n]);\n\t\t\t\tn++;\n\t\t\t\t//cout << country[i] << endl;\n\t\t }\n\t\t /*for(i=0;i<14;i++)\n\t\t{\t\n\t\t\tcout << i;\n\t\t\tcout << country[i] << endl;\n\t\t}*/\t\n\t\t for(int i=0;i<n;i++)\n\t\t {\n\t\t\tfor(int j=0;j<n-1;j++)\n\t\t\t{\n\t\t\t\tif(country[j][0]<country[j+1][0])\n\t\t\t\t{\n\t\t\t\t\ttemp = country[j];\n\t\t\t\t\tcountry[j] = country[j+1];\n\t\t\t\t\tcountry[j+1] = temp;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\t\n\t\t//cout << temp;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\t\n\t\t\t//cout << i;\n\t\t\tcout << country[i] << endl;\n\t\t}\t\n\t\t infile.close();\n\t}\n\telse{\n\t\tcout << \"Unable to open file\";\n\t}\n}\n\n# include <iostream>\nusing namespace std;\nint count_vowels(string str);\nint  count_consonants(string str);\nint main()\n{\n\tcout << \"A) Count the number of vowels in the string\" << endl;\n\tcout << \"B) Count the number of consonants in the string\" << endl;\n\tcout << \"C) Count both the vowels and consonants in the string\" << endl;\n\tcout << \"D) Enter another string\" << endl;\n\tcout << \"E) Exit\" << endl;\n\tstring k,ch,str;\t\n\twhile(1)\n\t{\t\n\t\tcout << \"Enter choice : \" << endl;\n\t\tcin >> ch;\n\t\t\n\t\tgetline(cin, k);\n\t\tif(ch==\"A\"){\n\t\t\tcout << \"Enter a string\" << endl;\n\t\t\tgetline(cin, str);\t\n\t\t \tcout << \"Number of vowels : \" << count_vowels(str) << endl ;\n\t\t}\n\t\telse if (ch==\"B\"){\n\t\t\tcout << \"Enter a string\" << endl;\n\t\t\tgetline(cin, str);\t\n\t\t \tcout << \"Number of consonants : \" << count_consonants(str) << endl ;\n\t\t}\n\t\telse if(ch==\"C\"){\n\t\t\tcout << \"Enter a string\" << endl;\n\t\t\tgetline(cin, str);\t\n\t\t \tcout << \"Number of vowels : \" << count_vowels(str) << endl ;\n\t\t   \tcout << \"Number of consonants : \" << count_consonants(str) << endl ;\n\t\t}\n\t\telse if(ch==\"D\"){\n\t\t}\n\t\telse if(ch==\"E\")\n\t\t\tbreak;\n\t\telse \n\t\t\tcout << \"Wrong input\" << endl ;\n\t}\n\n\treturn 0;\n}\n\nint count_vowels(string str)\n{\n\t\tint count=0;\n\t\tstring c;\n\t\tfor(int i=0;i<str.length();i++)\n\t\t{\n\t\t\tc=str[i];//cout<< i;\n\t\t\tif (c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\" || c == \"A\" || c == \"E\" || c == \"I\" || c == \"O\" || c == \"U\")\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n}\n\nint count_consonants(string str)\n{\n\t\tint count=0;\n\t\tstring c;\n\t\tfor (int i=0;i<str.length();i++)\n\t\t{\n\t\t\tc = str[i];\n\t\t\tif( ( int(str[i]) >=97 && int(str[i]) <=122 ) || (int(str[i])>=65 && int(str[i])<=90) )\n\t\t\t{\n\t\t\t\tif (c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\" || c == \"A\" || c == \"E\" || c == \"I\" || c == \"O\" || c == \"U\")\n\t\t\t\t{\n\t\t\t\t\tcout << \"\";\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n}\n\t\t\t\n\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\nclass Rectangle{\n\t\n\tprivate :\n\t\t\n\t\tint length;\n\t\tint width;\n\t\tstring colour;\n\n\t\tRectangle(){\n\t\t\tlength = 0;\n\t\t\twidth = 0;\n\t\t}\t\t\n\t\n\tpublic :\n\t\t\n\t\tRectangle(int len,int wid,string colour);\n\t\t\n\t\t\n\t\tint getArea(){\n\t\t\t\n\t\t\treturn length*width;\n\t\t}\n\t\t\n\t\tint compare(Rectangle rect1){\n\t\t\tint c =0;\n\t\t\tif (getArea() == rect1.getArea()){\n\t\t\t\t c = 0;\n\t\t\t}\n\t\t\telse if (getArea() > rect1.getArea()){\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\telse \n\t\t\t\tc = -1;\n\t\t\t\n\t\t\treturn c;\n\t\t}\n\t\t\n\t\tstring print(){\n\t\t\t\n\t\t\tstring c=\"Length : \";\n\t\t\tc.append(to_string(length));\n\t\t\tc.append(\" Width : \" ); \n\t\t\tc.append(to_string(width));\n\t\t\tc.append(\" Area : \");\n\t\t\tc.append(to_string(getArea()));\n\t\t\tc.append(\" Colour :\");\n\t\t\tc.append(colour);\n\t\t\tc.append(\"\\n\");\t\n\t\t\t\n\t\t\treturn c;\n\t\t}\n};\n\nRectangle::Rectangle(int len,int wid,string col){\n\t\n\tlength = len;\n\twidth = wid;\n\tcolour = col;\t\n\n}\n\nint main(){\n\t\n\tint len1,wid1,len2,wid2;\n\tstring col1,col2;\n\tcout << \"Enter length and width and color of Rectangle 1\" << endl;\n\tcin >> len1;\n\tcin >> wid1;\n\tcin >> col1;\n\tcout << \"Enter length and width of Rectangle 2\" << endl;\n\tcin >> len2;\n\tcin >> wid2;\n\tcin >> col2;\n\tif (len1>0 && wid1>0 && len2>0 && wid2>0){\n\t\tRectangle myRect(len1,wid1,col1);\n\t\tcout << \"Rectangle 1 : \" << endl;\n\t\tcout << myRect.print();\n\t\t//cout << \"Area of Rectangle 1: \" << myRect.getArea() << endl;\n\t\tRectangle yourRect(len2,wid2,col2);\n\t\t//cout << \"Area of Rectangle 2: \" << yourRect.getArea() << endl;\n\t\tcout << \"Rectangle 2 : \" << endl;\n\t\tcout << yourRect.print();\n\t\tint cmp = myRect.compare(yourRect);\n\t\tif(cmp==0)\n\t\t\tcout << \"Equal\" << endl;\n\t\telse if (cmp == 1)\n\t\t\tcout << \"Rectangle 1 is greater than rectangle 2\" << endl;\n\t\telse \n\t\t\tcout << \"Rectangle 1 smaller than rectangle 2\" << endl;\t\n\t}\n\telse{\n\t\tcout << \"Wrong input \" << endl;\n\t}\n\t\n\t\n\treturn 0;\n\n}\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\nclass Student{\n    \n    private :\n        \n        string name;\n        int roll;\n        //string mobileNumber;\n        //string email;\n        float attendance;  \n        string mobileNumber; \n        string email; \n    \n    public:\n    \n     Student (){}\n    \n     Student(string name,int roll,float attendance){\n         this->name = name;\n         this->roll = roll;\n         this->attendance = attendance;\n    \n     }\n        \n        string getName(){\n            \n            return name;    \n            \n        }\n        \n        bool setName(string name){\n        \n        \tif(name.length()<=30){\n\t\t        this->name = name;\n\t\t        return false;\n            }\n            else\n            \treturn true;\n        }\n        \n        int getRoll(){\n        \t//cout << \"ROLL\" << this->roll << endl;\n            return this->roll;\n        }\n        \n        bool setRoll(int roll){\n        \tif (roll>0 && roll<260){\n            \tthis->roll = roll;\n            \treturn false;\n            }\n            else{\n            \treturn true;\n            }\n        }\n        \n        \n        float getAttendance(){\n        \t//cout << \"ATT\" << attendance << endl;\n            return attendance;\n        }\n        \n        bool setAttendance(float att){\n        \tif(att>0  && att<1){\n        \t\tthis->attendance = att;\n        \t\treturn false;\n        \t}\n        \telse{\n        \t\t\treturn true;\n        \t}\n        }\n        \n        \n        bool setMobileNumber(string num){\n        \tif(mobileNumber.length()==10){\n        \t\tthis->mobileNumber = num;\n        \t\treturn false;\n        \t}\n        \telse{\n        \t\t\treturn true;\n        \t}\n        \t\n        }\n        \n        int setEmailId(string email){\n        int result;\n        int flag1,flag2;\n        \tfor(int i=0;i<email.length();i++)\n        \t{\n        \t\tif(email[i]=='@')\n\t\t\t\t{\n\t\t\t\t\tflag1=1;\n\t\t\t\t}\n\t\t\t\tstring s = email.substr(i,email.length());\n\t\t\t\tfor(int j =i;j<s.length();j++)\n\t\t\t\t{\n\t\t\t\t\tif(s[j]=='.')\n\t\t\t\t\t\tflag2 =2;\n\t\t\t\t}\t\t\t   \n        }\n        if(flag1==1 && flag2==1){\n        \tthis->email = email;\n        \tresult=1;\n        }\n        else{\n        \tresult=0;\n       }\n       \n       return result;\n    } \n        \n        \n        \n        \n};    \n/*Student::Student(string n,int r,float atten){\n    \n    name =n;\n    roll = r;\n    //mobile = mobileNumber;\n    //email = emailA;\n    attendance = atten;\n}*/\n\n#include<iostream>\n#include<fstream>\n#include \"NewStudent.cpp\"\n\nusing namespace std;\n\nclass StudentManager{\n    \n    public :\n    \n        Student myList[10];\n    \n    \n    \n    Student getStudentInput(){\n    \t//myList[0].setName(\"XY\");\n    \tStudent s;\n    \tstring name,email,mobile;int roll; float att;\n    \tcout << \"Enter your name : \" ;\n    \tcin >> name;\n    \twhile(s.setName(name)){\n    \t\tcout << \"Incorrect Format.\\nEnter name again : \" ;\n    \t\tcin >> name;\n    \t\ts.setName(name);\n    \t}\n    \t\n    \tcout << \"Enter Roll Number : \" ;\n    \tcin >> roll;\n    \twhile(s.setRoll(roll)){\n    \t\tcout << \"Incorrect Format.\\nEnter roll again : \" ;\n    \t\tcin >> roll;\n    \t\ts.setRoll(roll);\n    \t\n    \t}\n    \t\n    \tcout << \"Enter Attendance : \" ;\n    \tcin >> att;\n    \twhile(s.setAttendance(att)){\n    \t\tcout << \"Incorrect Format.\\nEnter attendance again : \" ;\n    \t\tcin >> att;\n    \t\ts.setAttendance(att);\n    \t\n    \t}\n    \t\n    \t/*cout << \"Enter Mobile Number : \" ;\n    \tcin >> mobile;\n    \twhile(s.setMobileNumber(mobile)){\n    \t\tcout << \"Incorrect Format.\\nEnter Mobile Number again : \" ;\n    \t\tcin >> mobile;\n    \t\ts.setMobileNumber(mobile);\n    \t\n    \t}\n    \t\n    \tcout << \"Enter Email Id : \" ;\n    \tcin >> email;\n    \twhile(s.setEmailId(email)){\n    \t\tcout << \"Incorrect Format.\\nEnter Email Id again : \" ;\n    \t\tcin >> email;\n    \t\ts.setEmailId(email);\n    \t\n    \t}*/\n    \t\n    \t\n    \treturn s;\n    \n    \n    }\n    \n    \n    void sortByRoll(){\n    \n        //cout << myList[0].getRoll();\n        \n        //Student sortListRoll[10];\n        \n        int i,j;\n        int n=4;\n        \n        Student temp;\n        \n        for(int i=0;i<n;i++){\n \t       cout << myList[i].getRoll()<<endl;\n        }\n        //cout << \"Break\\n\\n\" << endl;\n        \n        for(int i=0;i<n-1;i++)\n        {\n            for(int j=0;j<n-i-1;j++){\n            \t//cout << this->myList[j+1].getRoll()<<endl;\n                if(this->myList[j].getRoll() > this->myList[j+1].getRoll()){\n                    temp = myList[j];\n                    myList[j] = myList[j+1];\n                    myList[j+1] = temp;\n                }\n            }\n        }\n        /*for(int i=0;i<n;i++){\n        \tcout << \"\";\n \t       //cout << myList[i].getRoll()<<endl;\n        }*/\n        \n        //return myList;\n    }\n    \n    void sortByAttendance(){   \n    //Student sortListRoll[10];\n        \n        int i,j;\n        int n=4;\n        \n        Student temp;\n        \n        for(int i=0;i<n-1;i++)\n        {\n            for(int j=0;j<n-i-1;j++){\n            \t//cout << *(sptr+j)->getRoll()<<endl;\n                if(myList[j].getAttendance() > myList[j+1].getAttendance()){\n                    temp = myList[j];\n                    myList[j] = myList[j+1];\n                    myList[j+1] = temp;\n                }\n            }\n        }\n        /*for(int i=0;i<n;i++){\n        cout << \"\";\n        //cout << myList[i].getAttendance () << endl;\n        }    */   \n    \n    }  \n\t\n\t\n\t\n\t\n\tbool printAttendance(string filename,bool sortby){\n\t\t\n\t\tofstream myfile;\n\t\tmyfile.open(filename);\n\t\tif(myfile){\n\t\t\tint n=4;\n\t\t\tif(sortby){\n\t\t\t\tsortByRoll();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsortByAttendance();\n\t\t\t}\n\t\t\tmyfile << \"Name\\tRoll Number\\tAttendance\" << endl; \n\t\t\tfor (int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tmyfile << myList[i].getName() << \"\\t\\t\" << myList[i].getRoll() << \"\\t\\t\\t\" <<  myList[i].getAttendance() << endl ;\n\t\t\t}\t\n\t\treturn true;\n\t\t\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\n\t}\n\t\n\t\n\tvoid updateMobileNumber(int n,int roll,string num){\n\t\tint i,flag=0;\n\t\t//cout << \"Enter Roll Number of Student : \" ;\n\t\tfor( i=0;i<n;i++){\n\t\t\tif(myList[i].getRoll()==roll){\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==0){\n\t\t\tcout << \"Roll Number not present in database\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"Roll Number matched!\" << endl;\n\t\t\tflag=0;\n\t\t\twhile(myList[i].setMobileNumber(num)==0){\n\t\t\t\tcout << \"Enter mail id again\" << endl;\t\n\t\t\t\tcin >> num;\n\t\t\t\tmyList[i].setMobileNumber(num);\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcout << \"Mobile Number updated! \" << endl;\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n\tvoid updateEmailId(int n,int roll,string num){\n\t\tint i,flag=0;string email;\n\t\t//cout << \"Enter Roll Number of Student : \" ;\n\t\tfor( i=0;i<n;i++){\n\t\t\tif(myList[i].getRoll()==roll){\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag==0){\n\t\t\tcout << \"Roll Number not present in database\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"Roll Number matched!\" << endl;\n\t\t\tflag=0;\n\t\t\twhile(myList[i].setEmailId(num)==0){\n\t\t\t\tcout << \"Enter mail id again\" << endl;\t\n\t\t\t\tcin >> num;\n\t\t\t\tmyList[i].setEmailId(num);\n\t\t\t\t\t\n\t\t\t}\n\t\t\tcout << \"Email Id updated! \" << endl;\n\t\t\t\n\t\t}\n\t}\n\t\n\t\n};\n\n\nint main(){\n\n    StudentManager myMgr;\n    int n = 0;\n    /*Student student2(\"AB\",43,0.7);\n    Student student1(\"CD\",32,0.9);\n    Student student3(\"EF\",56,1);\n    Student student4(\"GH\",78,0.8);\n    \n    Student myList[10];\n    \n    myMgr.myList[0] = student1;\n    myMgr.myList[1] = student2;\n    myMgr.myList[2] = student3;\n    myMgr.myList[3] = student4;\n    myMgr.myList[4] = myMgr.getStudentInput();*/\n    \n    \n    cout << \"\\t\\t\\tStudent Management System\" << endl;\n    \n    int ch=-1;string numb,email,filename;;\n    while(ch!=5){\n\t\tcout << \"Enter 0 to enter student details\" << endl;\n\t\tcout << \"Enter 1 to Update Student Mobile Number\" << endl;\n\t\tcout << \"Enter 2 to Update Student Email Id\" << endl;\n\t\tcout << \"Enter 3 to print Attendance Report By Roll Number\" << endl;\n\t\tcout << \"Enter 4 to print Attendance Report By Attendance\" << endl;\n\t\tcout << \"Enter 5 to exit\" << endl;\n\t\tcout << \"Enter your choice : \" ;\n    \tcin >>ch;\n    \tswitch(ch){\n    \t\n    \t\tcase 0 : myMgr.myList[n++] = myMgr.getStudentInput();\n    \t\t\t\tcout << \"Student details registered! \" << endl;\n    \t\t\t\tbreak;\n    \t\tcase 1: cout << \"Enter roll number of Student : \" ;\n\t\t\t\t\tint roll; cin >> roll;\n\t\t    \t\tcout << \"Enter updated mobile number\" << endl;\n    \t\t\t\tcin >> numb;\n    \t\t\t\tmyMgr.updateMobileNumber(n,roll,numb);\n    \t\t\t\tbreak;\n    \t\tcase 2: cout << \"Enter roll number of Student : \" ;\n\t\t\t\t\tcin >> roll;\n\t\t    \t\tcout << \"Enter updated Email Id\" << endl;\n    \t\t\t\tcin >> email;\n    \t\t\t\tmyMgr.updateEmailId(n,roll,email);\n    \t\t\t\tbreak;\n    \t\tcase 3: cin >> filename;\n    \t\t\t\tmyMgr.printAttendance(filename,true);\n    \t\t\t\tbreak;\n    \t\tcase 4: cin >> filename;\n    \t\t\t\tmyMgr.printAttendance(filename,false);\n    \t\t\t\tbreak;\n    \t\tcase 5: cout << \"Exiting system ..\" << endl;\n    \t\tbreak;\n    \t\tdefault : cout << \"Wrong input\" << endl;\n    \t}  \n    }\n    \n    /*cout << \"Hello\" << endl;\n    cout << myMgr.myList[0].getName() << endl;\n    \n //   myMgr.sortByRoll();\n    cout << endl;\n \tmyMgr.sortByAttendance();\n //  myMgr.getStudentInput();\n    \n \tbool print = myMgr.printAttendance(\"Attendance.txt\",true);\n    \n    if(print){\n    \n    \tcout << \"Written to file \" << endl;\n    }\n    \n    else{\n    \n    \tcout << \"Wrong File Name\" << endl;\n    }\n    cout << myMgr.myList[0].getName() << endl;\n    \n    //cout << myMgr.m*/\n    return 0;\n\n}\n#include<iostream>\n#include<string>\n\nusing namespace std;\n\nclass Student{\n\t\n\tprivate :\n\t\t\n\t\tstring name;\n\t\tint roll;\n\t\t//string mobileNumber;\n\t\t//string email;\n\t\tdouble attendance;\t\n\t\n\tpublic:\n\t \n\t Student (){}\n\t \n\t Student(string name,int roll,double attendance){\n\t \tthis->name = name;\n\t \tthis->roll = roll;\n\t \tthis->attendance = attendance;\n\t \n\t }\n\t\t\n\t\tstring getName(){\n\t\t\t\n\t\t\treturn name;\t\n\t\t\t\n\t\t}\n\t\t\n\t\tvoid setName(string name){\n\t\t\tthis->name = name;\n\t\t}\n\t\t\n\t\tint getRoll(){\n\t\t\n\t\t\treturn roll;\n\t\t}\n\t\t\n\t\tvoid setRoll(int roll){\n\t\t\n\t\t\tthis->roll = roll;\n\t\t}\n\t\t\n\t\t\n\t\tdouble getAttendance(){\n\t\t\n\t\t\treturn attendance;\n\t\t}\n\t\t\n};\t\n/*Student::Student(string n,int r,float atten){\n\t\n\tname =n;\n\troll = r;\n\t//mobile = mobileNumber;\n\t//email = emailA;\n\tattendance = atten;\n}*/\n#include<iostream>\n\n#include \"Student.cpp\"\n\nusing namespace std;\n\nclass StudentManager{\n\t\n\tpublic :\n\t\n\t\tStudent myList[10];\n\t\n\tvoid sortByRoll(Student* sptr){\n\t\n\t\t//cout << myList[0].getRoll();\n\t\t\n\t\tStudent sortListRoll[10];\n\t\t\n\t\tint min_idx,i,j;\n\t\tint n=4,p,l;\n    \t\n    \tStudent temp;\n    \t\n    \tfor(int i=0;i<4;i++)\n    \t{\n    \t\tfor(int j=0;j<n-i+1;j++){\n    \t\t\tif((sptr+j)->getRoll()>(sptr+j+1)->getRoll()){\n    \t\t\t\ttemp = *(sptr+j);\n    \t\t\t\t*(sptr+j) = *(sptr+j+1);\n    \t\t\t\t*(sptr+j) = temp;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tfor(int i=0;i<n;i++){\n    \tcout << myList[i].getRoll()<<endl;\n    \t}\n    \t\n    \t//return myList;\n\t}\n\t\n\tvoid sortByAttendance(Student *sptr){\n\t\n\t//Student sortListRoll[10];\n\t\t\n\t\t//int min_idx,i,j;\n\t\tint n=4;//p,l;\n    \t\n    \tStudent temp;\n    \t\n    \tfor(int i=0;i<4;i++)\n    \t{\n    \t\tfor(int j=0;j<4;j++){\n    \t\t\tif((sptr+j)->getAttendance()>(sptr+j+1)->getAttendance()){\n    \t\t\t\ttemp = *(sptr+j);\n    \t\t\t\t*(sptr+j) = *(sptr+j+1);\n    \t\t\t\t*(sptr+j) = temp;\n    \t\t\t}\n    \t\t}\n    \t}\n    \t\n    \tfor(int i=0;i<n;i++){\n    \t\tcout << myList[i].getAttendance()<<endl;\n    \t}\n\t\n\t\n\t}\n\t\n\t\n\t\n\n};\n\n\nint main(){\n\n\tStudentManager myMgr;\n\t\n\tStudent student2(\"AB\",43,0.7);\n\tStudent student1(\"CD\",32,0.9);\n\tStudent student3(\"EF\",56,0.8);\n\tStudent student4(\"GH\",78,0.5);\n\t\n\tStudent myList[10];\n\t\n\tmyMgr.myList[0] = student1;\n\tmyMgr.myList[1] = student2;\n\tmyMgr.myList[2] = student3;\n\tmyMgr.myList[3] = student4;\n\t\n\tcout << \"Hello\" << endl;\n\tcout << myMgr.myList[0].getName() << endl;\n\t\n\t//myMgr.sortByRoll(myList);\n\tcout << endl;\n\tmyMgr.sortByAttendance(myList);\n\t//myMgr.getStudentInput();\n\t\n\tcout << myMgr.myList[0].getName() << endl;\n\t\n\t//cout << myMgr.m\n\treturn 0;\n\n}\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Employee{\n\n\tprivate :\n\t\tstring name;\n\t\tint gender;\n\t\t\n\t\tEmployee(){}\n\t\n\tpublic:\n\t\t\n\t\tEmployee(string name, bool gender){\n\t\t\t\n\t\t\tthis->name = name;\n\t\t\tthis->gender = gender;\n\t\t\n\t\t}\n\t\t\n\t\tEmployee(string name, int gender,bool updated){\n\t\t\t\n\t\t\tthis->name = name;\t\t\n\t\t\tthis->gender = gender;\n\t\t}\n\t\t\n\t\tstring getName(){\n\t\t\treturn name;\n\t\t}\n\t\t//before 2014\n\t\tbool getGender(){\n\t\t\t\n\t\t\tbool result = false;\n\t\t\tif (gender == 1)\n\t\t\t\tresult = true;\n\t\t\treturn result;\t\n\t\t\t\n\t\t}\n\t\t//after 2014\n\t\tint getGender(bool updated){\n\t\t\t\n\t\t\tint result = 0;\n\t\t\t\n\t\t\tif(gender == 1)\n\t\t\t\tresult = 1;\n\t\t\telse if (gender == -1)\t\t\n\t\t\t\tresult = -1;\n\t\t\t//cout << result;\n\t\t\treturn result;\n\t\t}\n\t\t//before 2014\n\t\tstring print(){\n\t\t\n\t\t\tstring res = \"My name is \" ;\n\t\t\tres.append(name);\n\t\t\tres.append(\" . I am \");\n\t\t\tif(getGender())\n\t\t\t\tres.append(\"female\");\n\t\t\telse\n\t\t\t\tres.append(\"male\");\n\t\t\t\t\n\t\t\treturn res;\n\t\t}\n\t\t//after 2014\n\t\tstring print(bool updated){\n\t\t\n\t\t\tstring res = \"My name is \" ;\n\t\t\tres.append(name);\n\t\t\tres.append(\" . I am \");\n\t\t\tif(getGender(1)==0)\n\t\t\t\tres.append(\"male\");\n\t\t\telse if (getGender(1)==-1)\n\t\t\t\tres.append(\"transgender\");\n\t\t\telse \n\t\t\t\tres.append(\"female\");\t\n\t\t\tres.append(\" .\");\t\n\t\t\treturn res;\n\t\t\n\t\t}\n};\n\n\nint main(){\n\n\tEmployee me(\"ABC\",-1,true);\n\t//me.getGender(1);\n\tcout << me.print(1) << endl;\n\n\n\n\n\treturn 0;\n\n}\n#include <iostream>\nusing namespace std;\nclass RealTime{\n\t\tprivate:\n\tint sec,min,hour;\n\tpublic:\n\t\t\tRealTime(){\n\t\t\tsec = 0;\n\t\t\tmin = 0;\n\t\t\thour = 0;\n\t\t};\n    RealTime(int h,int m,int s){\n            sec = s;\n\t\t\tmin = m;\n\t\t\thour = h;\n    }\n    RealTime operator + (RealTime that)\n\t{\t\n\t\tRealTime result;\n\t\tresult.sec= this->sec + that.sec;\n\t\tresult.min= this->min + that.min;\n\t\tresult.hour= this->hour + that.hour;\n\t\t//cout << result.sec << endl;\n\t\tif(result.sec>=60){\n\t\t\tresult.min+= 1;\n\t\t\tresult.sec -= 60;\n\t\t\tif(result.min>=60){\n\t\t\t\tresult.hour += 1;\n\t\t\t\tresult.min -= 60;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(result.min>=60){\n\t\t\tresult.min -= 60;\n\t\t\tresult.hour += 1;\n\t\t\t\n\t\t}\n        return result;\n\t}\n    RealTime operator = ( RealTime that){\n\t\tRealTime result;\n\t\tresult.sec = that.sec;\n\t\tresult.min = that.min;\n\t\tresult.hour = that.hour;\n\t\treturn result;\n\t}\n\tRealTime operator ++ (){\n\t\t++(this->sec);\n\t\t//cout << this->sec << endl;\n\t\tif(this->sec>=60){\n\t\t\tthis->sec -= 60;\n\t\t\t//cout << this->sec << endl;\n\t\t\tthis->min+=1;\n\t\t\t//cout << this->min << endl; \n\t\t\tif(this->min>=60){\n\t\t\t\tthis->hour += 1;\n\t\t\t\tthis->min -= 60;\n\t\t\t}\n\t\t}\n\t\tif(this->min>=60){\n\t\t\tthis->min -= 60;\n\t\t\tthis->hour += 1;\n\t\t\t\n\t\t}\n\t\treturn RealTime(*this);\n\t}\n\tRealTime operator ++ (int){\n\t\tRealTime old(*this);\n\t\t(this->sec)++;\n\t\tif(this->sec>=60){\n\t\t\tthis->sec = 0;\n\t\t\t//cout << this->sec << endl;\n\t\t\tthis->min+=1;\n\t\t\t//cout << this->min << endl; \n\t\t\tif(this->min>=60){\n\t\t\t\tthis->hour += 1;\n\t\t\t\tthis->min -= 60;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(this->min>=60){\n\t\t\tthis->min -= 60;\n\t\t\tthis->hour += 1;\n\t\t\t\n\t\t}\n\t\treturn old;\n\t\n\t}\n\tstring print(){\n\t\tstring s;\n\t\ts.append(to_string(hour));\n\t\ts.append(\":\");\n\t\ts.append(to_string(min));\n\t\ts.append(\":\");\n\t\ts.append(to_string(sec));\n\treturn s;\n\t\n\t}\n};\nint main(){\n\tRealTime time1(1,20,50);\n\t//cout << time1.print() << endl;\n\tRealTime time2(2,30,10);\n\tcout << \"Time 1 : \" << time1.print() << endl;\n\tcout << \"Time 2 : \" << time2.print() << endl;\n\tRealTime time4 = time1+time2;\n\t//time4 = time1 + time2;\n\t//time3 = time1 + time2;\n\tcout << \"Addition \" << time4.print() << endl;\n\t//cout << \"Time 1 : \" << time1.print() << endl;\n\t//RealTime time3 = time1++;\n\tRealTime time5(2,45,59);\n\tRealTime time6(3,2,59);\n\tcout << \"Time : \" << time5.print() << endl;\n\tRealTime time7 = ++time5;\n\tcout << \"Post Increment old : \" << time5.print() << endl;\n\tcout << \"Post Increment new : \" << time7.print() << endl;\n\tcout << \"Time : \" << time6.print() << endl;\n\tRealTime time8 = time6++;\n\tcout << \"Pre Increment old : \" << time6.print() << endl;\n\tcout << \"Pre Increment new : \" << \ttime8.print() << endl;\n\treturn 0;\n}\n#ifndef PERSON_CPP\n\t#define PERSON_CPP\n\t#include \"Person.cpp\"\n#endif\nclass Clerk : public Person{\n\n\tpublic: \n\tstring designation;\n\t\n\t\n\tClerk(string name){\n\t\tthis->setName(name);\n\t\tthis->designation = \"Clerk\";\n\t}\n\n\tvoid setDesignation(string designation){\n\t\tthis->designation = designation;\n\t}\n\t\n\tstring getDesignation(){\n\t\treturn designation;\n\t}\n\t\n\tstring introduce(){\t\n\t\tstring s;\n\t\ts.append(\"\\nHello!\\nMy name is \");\n\t\ts.append(getName());\n\t\ts.append(\"\\nMy designation is \");\n\t\ts.append(getDesignation());\t\n\t\treturn s;\n\t}\n\t\n\tbool approveInvoice(double amount){\n\t\tbool result = false;\n\t\tif (amount>=0 && amount <= 100){\n\t\t\tresult =true;\n\t\t}\n\t\treturn result;\t\n\t}\n\t\n};\n\n\n/*int main(){\n\n\tClerk myClerk(\"ABC\");\n\tcout << myClerk.introduce();\n\tif(myClerk.approveInvoice(192))\n\t\tcout << \"\\nApproved\" ;\n\telse \n\t\tcout << \"\\nNot approved\" ;\n\treturn 0;\n}*/\n\n#ifndef PERSON_CPP\n\t#define PERSON_CPP\n\t#include \"Person.cpp\"\n#endif\n\nclass Consultant : public Person{\n\n\tpublic :\n\tConsultant (string name){\n\t\tthis->setName(name);\n\t}\n\t\n\t\n\tstring introduce(){\n\t\n\t\tstring s;\n\t\ts.append(\"Hey!My name is \");\n\t\ts.append(getName());\n\t\ts.append(\"I am a consultant.\");\n\t\treturn s;\n\t}\n\n};\n#ifndef PERSON_CPP\n\t#define PERSON_CPP\n\t#include \"Person.cpp\"\n#endif\n#include \"Manager.cpp\"\n#include \"Consultant.cpp\"\nusing namespace std;\n\nclass Director : public Manager{\n\n\tpublic:\n\t\t\n\t\tDirector(string name) : Manager(name) {\n\t\t\tthis->designation = \"Director\";\n\t\t}\n\t\t\n\t\tbool approveInvoice(double amount){\n\t\t\tbool result = false;\n\t\t\tif (amount>=0 && amount <= 1000)\n\t\t\t\tresult = true;\t\n\t\t\treturn result;\n\t\t}\n};\n\n\nint main(){\n\n\tClerk myClerk(\"ABC\");\n\tcout << myClerk.introduce() << endl;\n\tManager myManager(\"DEF\");\n\tcout << myManager.introduce() << endl;\n\tDirector myDirector(\"DEF\");\n\tcout << myDirector.introduce() << endl;\n\tConsultant myConsultant(\"GHI\");\n\tcout << myConsultant.introduce() << endl;\n\t\n\tdouble amount;\n\tcout << \"\\nEnter amount\" ;\n\tcin >> amount;\n\t\n\t//int flag=0;\n\t\n\tcout << myClerk.introduce() << endl;\n\tif(myClerk.approveInvoice(amount))\n\t{\n\t\tcout << \"Your Invoice is approved\" ;\n\t}\n\telse {\n\t\tcout << \"I am unable to approve. Redirecting to Manager.\" << endl;\n\t\tcout << myManager.introduce() << endl;\n\t\tif(myManager.approveInvoice(amount))\n\t\t\tcout << \"Your Invoice is approved\" ;\n\t\telse{\n\t\t\tcout << \"I am unable to approve. redirecting to Director. \" << endl;\n\t\t\tcout << myDirector.introduce() << endl;\n\t\t\tif(myDirector.approveInvoice(amount)){\n\t\t\t\tcout << \"Your Invoice is approved\" ;\n\t\t\t}\n\t\t\telse{\n\t\t\t\t\n\t\t\t\tcout << \"Your Invoice is not approved :-( \" ;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\t\n\t\n\t\n\t\n\t\t\n\treturn 0;\n\n}\n#include<iostream>\nusing namespace std;\n\nclass Clerk{\n\n\tpublic: \n\tstring name;\n\tstring designation;\n\t\n\t\n\tClerk(string name){\n\t\tthis->setName(name);\n\t\tthis->designation = \"Clerk\";\n\t}\n\t\n\t\n\tvoid setName(string name){\n\t\tthis->name = name;\n\t\n\t}\n\n\tvoid setDesignation(string designation){\n\t\tthis->designation = designation;\n\t}\n\t\n\tstring getName(){\n\t\treturn name;\n\t}\n\t\n\tstring getDesignation(){\n\t\treturn designation;\n\t}\n\t\n\tstring introduce(){\n\t\t\n\t\tstring s;\n\t\ts.append(\"Hello!\\nMy name is \");\n\t\ts.append(getName());\n\t\ts.append(\"\\nMy designation is \");\n\t\ts.append(getDesignation());\t\n\t\treturn s;\n\t}\n\t\n\tbool approveInvoice(double amount){\n\t\tbool result = false;\n\t\tif (amount <= 100){\n\t\t\tresult =true;\n\t\t}\n\t\treturn result;\t\n\t}\n\t\n};\n\n\nint main(){\n\n\tClerk myClerk(\"ABC\");\n\tcout << myClerk.introduce();\n\tif(myClerk.approveInvoice(192))\n\t\tcout << \"\\nApproved\" ;\n\telse \n\t\tcout << \"\\nNot approved\" ;\n\treturn 0;\n}\n\n#ifndef PERSON_CPP\n\t#define PERSON_CPP\n\t#include \"Person.cpp\"\n#endif\n#include \"Clerk.cpp\"\nclass Manager : public Clerk{\n\t\n\tpublic :\n\t\n\t\tManager(string name) : Clerk(name){\n\t\t\tthis->designation = \"Manager\";\t\n\t\t}\n\t\n\t\tbool approveInvoice(double amount){\n\t\t\tbool result = false;\n\t\t\tif (amount>=0 && amount <= 500)\n\t\t\t\tresult = true;\t\n\t\t\treturn result;\n\t\t}\n};\n\n/*int main(){\n\n\tClerk myClerk(\"ABC\");\n\tcout << myClerk.introduce();\n\tif(myClerk.approveInvoice(192))\n\t\tcout << \"\\nApproved\" ;\n\telse \n\t\tcout << \"\\nNot approved\" ;\n\t\n\tManager myManager(\"DEF\");\n\tcout << myManager.introduce();\n\tif(myManager.approveInvoice(192))\n\t\tcout << \"\\nApproved\" ;\n\telse \n\t\tcout << \"\\nNot approved\" ;\t\n\t\t\n\t\t\n\t\t\t\n\t\t\n\treturn 0;\n}*/\n#include <iostream>\nusing namespace std;\n\nclass Person{\n\n\tprivate: \n\t\tstring name;\n\t\n\tpublic: \n\t\tstring getName(){\n\t\t\treturn name;\n\t\t}\n\t\n\t\tvoid setName(string name){\n\t\t\tthis->name = name;\n\t\t} \t \n\tvirtual string introduce() = 0;\n\n};\n#include <iostream>\n#ifndef PERSON_CPP\n\t#define PERSON_CPP\n\t#include \"Person.cpp\"\n#endif\nusing namespace std;\n\nclass Clerk: public Person {\n\n\tprivate:\n\t\tstring designation;\t\t\n\n\tpublic:\n\t\t// constructor with parameters name and id\t\t\n/*\t\tClerk(string name, string id) {} */\n\t\t\n\t\tClerk(string name) {\n\t\t\tthis->setName(name);\n\t\t\tthis->designation = \"CLERK\";\n\t\t\t//this->id = id; // compilation error, id is private attribute of Person\n\t\t}\t\t\t\t\n\n\t\t// pure virtual method from Resource\n\t\tstring getDesc() {\n\t\t\treturn designation;\n\t\t}\n\n\t\tstring getDesignation() {\n\t\t\treturn designation;\n\t\t}\n\n\t\tvoid setDesignation(string designation) {\n\t\t\tthis->designation = designation;\n\t\t}\n\t\tstring approveInvoice() {\n\t\t\treturn \"approval limit = $100\";\n\t\t}\n\n\t\tstring introduce() {\n\t\t\tstring result = \"hello, \";\n\t\t\tresult.append(\"name = \").append(getName());\n\t\t\tresult.append(\", \");\n\t\t\tresult.append(\"designation = \").append(designation);\n\n\t\t\treturn result;\n\t\t}\n\t\n};\n\n\n\n\n\n#include <iostream>\n#ifndef PERSON_CPP\n\t#define PERSON_CPP\n\t#include \"Person.cpp\"\n#endif\nusing namespace std;\n\nclass Consultant : public Person {\n\n\tpublic:\n\t\tConsultant(string name) {\n\t\t\tthis->setName(name);\n\t\t}\n\n\t\tstring introduce() {\n\t\t\tstring result = \"hello, \";\n\t\t\tresult.append(\"name = \").append(getName());\n\t\t\tresult.append(\", consultant\");\n\t\t\treturn result;\n\t\t}\n\n\t\t// pure virtual method from Resource\n\t\tstring getDesc() {\n\t\t\treturn \"Consultant\";\n\t\t}\n};\n#include \"Manager.cpp\"\n\nclass Director : public Manager{\n\n\tpublic:\n\t\tDirector(string name) : Manager(name) {\n\t\t\tthis->setDesignation(\"DIRECTOR\");\n\t\t}\n\n\t\tstring approveInvoice() {\n\t\t\treturn \"approval limit = $1000\";\n\t\t}\n};\n\n\n#include <iostream>\n#include \"Director.cpp\"\n#include \"Consultant.cpp\"\n#include \"Hardware.cpp\"\nusing namespace std;\n\nconst int NUM_RESOURCE = 10;\n\nint main() {\n\n\tHardware myHardware(\"H000000001\", SERVER);\n\tResource* pHardware = &myHardware;\n\tcout << pHardware->getDesc() << endl;\t\n\n\tClerk myClerk(\"anand\");\n\tResource* pClerk = &myClerk;\n\tcout << pClerk->getDesc() << endl;\n\t\n\tConsultant myConsultant(\"deepak\");\n\tResource* pConsultant = &myConsultant;\n\tcout << pConsultant->getDesc() << endl;\n\n\tResource* resourceList[NUM_RESOURCE];\n\tresourceList[0] = pHardware;\n\tresourceList[1] = pClerk;\n\tresourceList[2] = pConsultant;\n\tfor (int i=0; i<3; i++) {\n\t\tcout << resourceList[i]->getDesc() << endl;\n\t}\n\n/*\n\tClerk myClerk(\"anand\");\n\tcout << myClerk.introduce() << endl;\n\tcout << myClerk.approveInvoice() << endl;\n\n\tManager myManager(\"baishaiki\");\n\tcout << myManager.introduce() << endl;\n\tcout << myManager.approveInvoice() << endl;\n\n\tDirector myDirector(\"chandana\");\n\tcout << myDirector.introduce() << endl;\n\tcout << myDirector.approveInvoice() << endl;\n\n\tConsultant myConsultant(\"deepak\");\n\tcout << myConsultant.introduce() << endl;\n*/\n\treturn 0;\n}\n#include <iostream>\n#ifndef RESOURCE_CPP\n\t#define RESOURCE_CPP\n\t#include \"Resource.cpp\"\n#endif\n\nconst string SERVER = \"server\";\nconst string DESKTOP = \"desktop\";\nconst string LAPTOP = \"laptop\";\n\nclass Hardware : public Resource {\n\n\tprivate:\n\t\tstring type; // SERVER, DESKTOP, LAPTOP\n\t\tstring id;\n\n\tpublic:\n\t\tHardware(string id, string type) {\n\t\t\tthis->id = id;\n\t\t\tthis->type = type;\n\t\t}\n\n\tstring getDesc() {\n\t\treturn type;\n\t}\n\t\n\tstring getId() {\n\t\treturn id;\n\t}\n};\n#include \"Clerk.cpp\"\n\nclass Manager : public Clerk {\n\n\tpublic:\n\t\tManager(string name) : Clerk(name) {\n\t\t\tthis->setDesignation(\"MANAGER\");\n\t\t}\n\n\t\tstring approveInvoice() {\n\t\t\treturn \"approval limit = $500\";\n\t\t}\n\n};\n\n\n\n\n#include <iostream>\n#ifndef RESOURCE_CPP\n\t#define RESOURCE_CPP\n\t#include \"Resource.cpp\"\n#endif\nusing namespace std;\n\nclass Person : public Resource {\n\t\n\tprivate:\n\t\tstring name;\n\t\tstring id;\n\n\tpublic:\n\t\tstring getName() {return name;}\n\t\tvoid setName(string name) {\n\t\t\tthis->name = name;\n\t\t}\n\n\t\tstring getId() {\n\t\t\treturn id;\n\t\t}\t\t\t\n\t\tvoid setId(string id) {\n\t\t\tthis->id = id;\n\t\t}\n\n\t\tvirtual string introduce() = 0; \n\n};\n#include <iostream>\nusing namespace std;\n\nclass Resource {\n\n\tpublic:\n\tvirtual string getDesc() = 0;\n\tvirtual string getId() = 0;\n\n};\n//\n//  main.c\n//  lab 8\n//\n//  Created by Agnik Saha on 11/5/19.\n//  Copyright \u00a9 2019 Agnik Saha. All rights reserved.\n//\n\n#include <stdio.h>\n\nint main(int argc, const char * argv[]) {\n    // insert code here...\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\n//\n//  q2.cpp\n//  lab 8\n//\n//  Created by Agnik Saha on 11/5/19.\n//  Copyright \u00a9 2019 Agnik Saha. All rights reserved.\n//\n\n#include <iostream>\n#include<algorithm>\nusing namespace std;\n\nenum VehicleType {SCOOTER, AUTO, CAR, BUS};\n\nclass Vehicle {\n\npublic:\nVehicleType type;\n\nVehicle() {\nthis->type = SCOOTER;\n}\nVehicle(VehicleType type) {\nthis->type = type;\n}\n\n\nVehicleType getType() {\nreturn type;\n}\n\n\n\nstring getTypeString() {\nstring result = \"\";\n\nswitch (this->type) {\ncase BUS: result = \"bus\"; break;\ncase CAR: result = \"car\"; break;\ncase AUTO: result = \"auto\"; break;\ncase SCOOTER: result = \"scooter\"; break;\ndefault: result = \"Vehicle not found\";\n}\nreturn result;\n}\n\n\n\n};\n\nbool compare (Vehicle v1,Vehicle v2) {\nbool result = false;\nif (v1.type > v2.type)\nresult = true;\nreturn result;\n}\n\n\nint main() {\n\nVehicle myBus(BUS);\nVehicle myCar(CAR);\nVehicle myScooter(SCOOTER);\nVehicle myAuto(AUTO);\nVehicle myArray[4];\nmyArray[0]=myBus;\nmyArray[1]=myCar;\nmyArray[2]=myScooter;\nmyArray[3]=myAuto;\n\nsort(myArray,myArray+4,compare);\ncout<<\"The increasing order of vehicle \";\nfor(int i=0;i<4;i++)\ncout<<myArray[i].getTypeString()<<\" \";\n\nreturn 0;\n}\n//\n//  q3.cpp\n//  lab 8\n//\n//  Created by Agnik Saha on 11/5/19.\n//  Copyright \u00a9 2019 Agnik Saha. All rights reserved.\n//\n#include<iostream>\n#include<string>\nusing namespace std;\nclass rectangle{\n    private:\n        int length;\n        int width;\n        string color;\n    public:\n        //default constructor\n        rectangle(){\n            length=0;\n            width=0;\n            color=\"red\";\n        }\n        //param constructor\n        rectangle(int len,int wid,string col);\n        //methods\n        int getArea(){\n            return length*width;\n        }\n        int compare(rectangle r1){\n            if(getArea() == r1.getArea())\n                    return 0;\n            else if(getArea() <r1.getArea())\n                    return 1;\n            else\n                return -1;\n            }\n        string print(){\n            return(\"\\n the rectangle has length = \"+to_string(length) + \" width= \"+to_string(width)+\", its color is \"+color + \" and area is \"+to_string(getArea())+\"\\n\");\n            }\n};\n        rectangle :: rectangle(int len,int wid,string col){\n            length=len;\n            width=wid;\n            color=col;\n        }\nint main()\n    {\n        int l1,l2,w1,w2;\n        string c1,c2;\n        cout<<\"Enter the length,width and colour of rectancle1: \";\n        cin>>l1>>w1>>c1;\n        cout<<\"Enter the legth,width and colour of rectangle 2 : \";\n        cin>>l2>>w2>>c2;\n        if(l1<=0 ||l2<=0 ||w1<=0 ||w2<=0)\n\n            cout<<\"invalid input\"<<endl;\n\n        else{\n\n            rectangle myrect1(l1,w1,c1);\n\n            rectangle myrect2(l2,w2,c2);\n\n            cout<<\"area of rectangle1 \"<<myrect1.getArea()<<endl;\n\n            cout<<\"area of rectangle2 \"<<myrect2.getArea()<<endl;\n\n            cout<<\"comparison  \"<<myrect1.compare(myrect2)<<endl;\n\n            cout<<myrect1.print()<<endl;\n\n            cout<<myrect2.print()<<endl;\n\n        }\n\n        return 0;\n\n    }\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() { \n\n\tint i=3; \n\tvector<int> v(i); // Declare a vector of 3 elements. \n\tv[0] = 7; \n\tv[1] = v[0] + 3; \n\tv[2] = v[0] + v[1]; \n\tfor (int i=0;i<3;i++) \n\t\tcout << \"[\" << i << \"]=\" << v[i] << endl;\n\t \n}\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n\tint a[5]; \n\ta[0] = 5; \n\ta[1] = 3; \n\ta[2] = 7; \n\ta[3] = 9; \n\ta[4] = 1; \n\t\n\tsort(a, a+5); \n\n\tfor (int i = 0; i < 5; i++) cout << a[i] << endl;\n\n}\n// sample code taken from http://www-h.eng.cam.ac.uk/help/tpl/languages/C++/1BComputingOO/\n\n#include <iostream>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nbool myFavouriteChar(char c) {\n\t\tbool result = false;\n\t\tif (c=='g')\n\t\t\tresult = true;\n\t\treturn result;\n}\n\nint main() {\n  \tstring s = \"a long string\";\n\n\t// replacing characters\n\treplace(s.begin(), s.end(), 's', 'S');\n\tcout << s << endl;\n\n\t// now reverse the whole string from the beginning to the end\n  \treverse(s.begin(), s.end());\n  \tcout << s << endl;\n \n\t// count the number of times 'n' appears in the string s\n\tcout << \"n is in string s \"  << count(s.begin(), s.end(), 'n') << \" times\" << endl;\n\n\t// count my favourite character\n\tcout << count_if(s.begin(), s.end(), myFavouriteChar) << \" times\" << endl;\n\n\tstring::iterator it;\n  \tit = find (s.begin(), s.end(), 'w');\n  \tif (it == s.end())\n    \tcout << \"w not found \" << endl;\n  \telse\n    \tcout << \"w is in string s \" << endl;\n\n\n}\n#include <iostream>\nusing namespace std;\n\nenum VehicleType {SCOOTER, AUTO, CAR, BUS};\n\nclass Vehicle {\n\t\t\n\tprivate:\n\t\tVehicleType type;\n\n\tpublic:\n\t\tVehicle(VehicleType type) {\n\t\t\tthis->type = type;\n\t\t}\n\n\t\tVehicle() {\n\t\t\tthis->type = SCOOTER;\n\t\t}\t\t\n\n\t\tVehicleType getType() {\n\t\t\treturn type;\n\t\t}\n\n\t\tbool operator > (Vehicle vOther) {\n\t\t\tbool result = false;\n\t\t\tif (this->type > vOther.getType())\n\t\t\t\tresult = true;\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\tstring getTypeString() {\n\t\t\tstring result = \"\";\n\t\t\t\n\t\t\tswitch (this->type) {\n\t\t\t\tcase BUS: result = \"bus\"; break;\n\t\t\t\tcase CAR: result = \"car\"; break;\n\t\t\t\tcase AUTO: result = \"auto\"; break;\n\t\t\t\tcase SCOOTER: result = \"scooter\"; break;\n\t\t\t\tdefault: result = \"Vehicle not found\";\n\t\t\t}\t\t\t\n\t\t\treturn result;\n\t\t}\n\n\t\tfriend ostream& operator<<(ostream &out, const Vehicle& v) {\n\t\t\tstring result = \"\";\n\t\t\t\n\t\t\tswitch (v.type) {\n\t\t\t\tcase BUS: result = \"bus\"; break;\n\t\t\t\tcase CAR: result = \"car\"; break;\n\t\t\t\tcase AUTO: result = \"auto\"; break;\n\t\t\t\tcase SCOOTER: result = \"scooter\"; break;\n\t\t\t\tdefault: result = \"Vehicle not found\";\n\t\t\t}\n\n\t\t\tout << result;\n\t\t\treturn out;\n\t\t}\n\t\n};\n\n\n\n\n/*\nint main() {\n\n\tVehicle myBus(BUS);\n\tVehicle myCar(CAR);\n\tcout << myBus.getTypeString() << endl;\n\n\tif (myBus > myCar) {\n\t\tcout << \"larger\" << endl;\n\t} else {\n\t\tcout << \"not larger\" << endl;\n\t}\n\n\n\treturn 0;\n}\n*/\n", "https://github.com/agnik2019/Data-Structure-Algorithm": "class NumArray {\npublic:\n     vector<int> tree;\n    vector<int> a;\n    void build(int node, int st, int en)\n    {\n        if(st == en)\n        {\n            tree[node] = a[st];\n            return;\n        }\n        int mid = (st+en)/2;\n        build(2*node, st,mid);\n        build(2*node+1,mid+1,en);\n\n        tree[node] = tree[2*node]+tree[2*node+1];\n    }\n    \n     void updater(int index, int update_left , int update_right, int node_left , int node_right, int val) \n    {\n        if(update_left > node_right || update_right < node_left)    return;     // completely excluded\n        if(node_left == node_right)                                             // reached leaf node \n        { \n            tree[index] = val; \n            a[node_left] = val;         // this line can be skipped, we dont give a fuck to vector a once tree has been made\n            return; \n        };\n        int mid = (node_left + node_right)/2;                                       \n        updater(index*2 , update_left , update_right , node_left , mid       , val);\n        updater(index*2+1,update_left , update_right , mid+1     , node_right, val);\n        tree[index] = tree[index*2] + tree[index*2+1];\n        return;\n    }\n    int query(int node, int st, int en, int l, int r)\n    {\n        if(st>r || en<l)\n            return 0;\n        if(l <= st && en <= r)\n            return tree[node];\n        int mid = (st+en) /2;\n\n        int q1 = query(2*node, st, mid, l, r);\n        int q2 = query(2*node+1,mid+1,en,l,r);\n\n        return q1+q2;\n    }\n    NumArray(vector<int>& arr) {\n        int n = arr.size();                                                     \n        tree = vector<int> (4*n+1); \n        a = vector<int>(arr.begin() , arr.end());                              \n        build(1,0,n-1);  \n        \n    }\n    \n    void update(int i, int val) {\n        updater(1,i,i,0,a.size()-1 , val);      \n    }\n    \n    int sumRange(int left, int right) {\n        return query(1,0,a.size()-1,left,right);\n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * obj->update(index,val);\n * int param_2 = obj->sumRange(left,right);\n */#include <iostream>\nstruct TreeNode {\n      int data;\n      int height;\n      TreeNode *lchild;\n      TreeNode *rchild;\n      TreeNode() : data(0), lchild(nullptr), rchild(nullptr) {}\n      TreeNode(int x) : data(x), lchild(nullptr), rchild(nullptr) {}\n      TreeNode(int x, TreeNode *lchild, TreeNode *rchild) : data(x), lchild(lchild), rchild(rchild) {}\n  };\nTreeNode *root=NULL;\nint NodeHeight(struct TreeNode *p)\n{\n    int hl,hr;\n    hl=p && p->lchild?p->lchild->height:0;\n    hr=p && p->rchild?p->rchild->height:0;\n    return hl>hr?hl+1:hr+1;\n}\nint BalanceFactor(struct TreeNode *p)\n{\n    int hl,hr;\n    hl=p && p->lchild?p->lchild->height:0;\n    hr=p && p->rchild?p->rchild->height:0;\n    return hl-hr;\n}\nTreeNode * LLRotation(struct TreeNode *p)\n{\n    TreeNode *pl=p->lchild;\n    TreeNode *plr=pl->rchild;\n    pl->rchild=p;\n    p->lchild=plr;\n    p->height=NodeHeight(p);\n    pl->height=NodeHeight(pl);\n    if(root==p)\n        root=pl;\n    return pl;\n}\nTreeNode * LRRotation( TreeNode *p)\n{\n    TreeNode *pl=p->lchild;\n    TreeNode *plr=pl->rchild;\n    pl->rchild=plr->lchild;\n    p->lchild=plr->rchild;\n    plr->lchild=pl;\n    plr->rchild=p;\n    pl->height=NodeHeight(pl);\n    p->height=NodeHeight(p);\n    plr->height=NodeHeight(plr);\n    if(root==p)\n         root=plr;\n    return plr;\n}\nTreeNode * RRRotation(TreeNode *p)\n{\n    return NULL;\n}\nTreeNode * RLRotation(TreeNode *p)\n{\n    return NULL;\n}\nTreeNode *RInsert(TreeNode *p,int key)\n{\n    TreeNode *t=NULL;\n    if(p==NULL)\n    {\n        t=new TreeNode();\n        t->data=key;\n        t->height=1;\n        t->lchild=t->rchild=NULL;\n        return t;\n    }\n    if(key < p->data)\n        p->lchild=RInsert(p->lchild,key);\n    else if(key > p->data)\n        p->rchild=RInsert(p->rchild,key);\n    p->height=NodeHeight(p);\n    if(BalanceFactor(p)==2 && BalanceFactor(p->lchild)==1)\n        return LLRotation(p);\n    else if(BalanceFactor(p)==2 && BalanceFactor(p->lchild)==-1)\n        return LRRotation(p);\n    else if(BalanceFactor(p)==-2 && BalanceFactor(p->rchild)==-1)\n        return RRRotation(p);\n    else if(BalanceFactor(p)==-2 && BalanceFactor(p->rchild)==1)\n        return RLRotation(p);\n    return p;\n}\nint main()\n{\n    root=RInsert(root,50);\n    RInsert(root,10);\n    RInsert(root,20);\n    return 0;\n}#include<iostream>\nusing namespace std;\n\nconst int N = 1e5+2;\nint a[N],tree[4*N];\n\nvoid build(int node, int st, int en)\n{\n    if(st == en)\n    {\n        tree[node] = a[st];\n        return;\n    }\n    int mid = (st+en)/2;\n    build(2*node, st,mid);\n    build(2*node+1,mid+1,en);\n\n    tree[node] = tree[2*node]+tree[2*node+1];\n}\n\nint query(int node, int st, int en, int l, int r)\n{\n    if(st>r || en<l)\n        return 0;\n    if(l <= st && en <= r)\n        return tree[node];\n    int mid = (st+en) /2;\n\n    int q1 = query(2*node, st, mid, l, r);\n    int q2 = query(2*node+1,mid+1,en,l,r);\n\n    return q1+q2;\n}\n\n// st.....en  l....r\n// l    st  en   r\n// st   l  en    r      // l  st   r  en\nint main(){\n    int n;\n    cin>>n;\n    for(int i = 0; i<n; i++)\n        cin>> a[i];\n    build(1,0,n-1);\n   while(1){\n       int type;\n       cin>> type;\n       if(type == -1)\n         break;\n        if(type == 1){\n            int l,r;\n            cin>>l>>r;\n            int ans = query(1,0,n-1,l,r);\n            cout<<ans<<endl;\n        }\n   }\n    return 0;\n}#include<iostream>\n#include<vector>\nusing namespace std;\n#include<algorithm>\n// 1299. Replace Elements with Greatest Element on Right Side\n\n\n    vector<int> replaceElements(vector<int>& arr) {\n        int mx = -1;\n        for(int i = arr.size()-1; i>=0; i--)\n        {\n            int temp = arr[i];\n            arr[i] = mx;\n            mx = max(mx,temp);\n        }\n        return arr;\n    }\n\n    int main(){\n        vector<int> arr = {17,18,5,4,6,1};\n        vector<int> res = replaceElements(arr);\n        for(int i = 0; i< res.size(); i++)\n            cout<< res[i]<<\" \";\n        return 0;\n    }    #include<iostream>>\n    using namespace std;\n    #include<vector>\n    #include<set>\n    #include <numeric> \n\n    vector<int> kWeakestRows(vector<vector<int>>& mat, int k) {\n        set<pair<int,int>> mp;\n        for(int i = 0; i< mat.size(); i++)\n        {\n            int sum = accumulate(mat[i].begin(), mat[i].end(),0);\n            mp.insert({sum,i});\n        }\n         vector<int> res;\n        for(auto it= mp.begin(); k > 0;it++,k--)\n            res.push_back(it->second);\n        \n        return res;\n        \n    }class Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        \n       int count[101] = {0};\n        vector<int> ans;\n        for(int i = 0; i<nums.size(); i++)\n            count[nums[i]]++;\n        \n        for(int i = 1; i<101; i++)\n            count[i] += count[i-1];\n        \n        for(int i = 0; i<nums.size(); i++)\n        {\n            if(nums[i] == 0)\n                ans.push_back(0);\n            else\n                ans.push_back(count[nums[i]-1]);\n        }\n        \n        return ans;\n    }\n};\n\n// Approach 2: USING HASHMAP\nclass Solution {\npublic:\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        vector<int> res;\n        for(auto x : nums)\n            mp[x]++;\n        for(auto num : nums)\n        {\n            int temp = 0;\n            \n            for(auto j : mp)\n            {\n                if(j.first < num)\n                    temp+= j.second;\n            }\n            res.push_back(temp);\n        }\n        return res;\n    }\n};class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        // using bit manipulation\n        int ans = nums[0];\n        for(int i = 1; i<nums.size(); i++)\n            ans  = ans^ nums[i];\n        return ans;\n        \n    }\n};// Brute Force solution \n\nclass Solution {\npublic:\n    vector<int> createTargetArray(vector<int>& nums, vector<int>& index) {\n        vector<int> target = nums;\n        for(int i = 0; i< nums.size(); i++)\n        {\n            for(int j = index.size()-2; j>= index[i]; j-- )\n                target[j+1] = target[j];\n            target[index[i]] = nums[i];\n        }\n        return target;\n    }\n};\n\n// Efficient Solution using c++ stl insert\nclass Solution {\npublic:\n    vector<int> createTargetArray(vector<int>& nums, vector<int>& index) {\n        \n        vector<int> res;\n        for(int i = 0; i< nums.size(); i++)\n        {\n            res.insert(res.begin()+ index[i], nums[i]);\n        }\n        return res;\n    }\n};class Solution {\npublic:\n    void rev(vector<int> &arr, int l, int r)\n    {\n        while(l<r)\n        {\n            int temp = arr[l];\n            arr[l] = arr[r];\n            arr[r] = temp;\n            l++; r--;\n        }\n    }\n    void rotate(vector<int>& nums, int k) {\n         int n = nums.size();\n        k = k%n;\n        rev(nums,0,n-k-1);\n        rev(nums,n-k,n-1);\n        rev(nums,0,n-1);\n        // reverse(nums.begin(), nums.begin()+n-k);\n        // reverse(nums.begin()+n-k, nums.end());\n        // reverse(nums.begin(), nums.end());   \n    }\n};class Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n    int j = 0;\n    for(int i = 0; i< nums.size(); i++)\n    {\n        if(nums[i] != 0)\n            nums[j++] = nums[i];\n    }\n        for(;j<nums.size(); j++)\n            nums[j] = 0;\n    }\n};class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        if(nums.size() == 1) return;\n        // find the peak element\n        int lastinc = -1;\n        for(int i = 1; i<nums.size(); i++)\n        {\n            if(nums[i] > nums[i-1])\n                lastinc = i;\n        }\n        // if the array is in descending order\n        if(lastinc == -1)\n        {\n            for(int i = 0; i<nums.size()/2; i++)\n                swap(nums[i], nums[nums.size()-i-1]);\n            return;\n        }\n        int index = lastinc;\n        for(int  i = lastinc; i<nums.size(); i++)\n            if(nums[i]>nums[lastinc-1] and nums[i]<nums[index])\n                index = i;\n        // swapping\n        swap(nums[lastinc-1], nums[index]);\n        sort(nums.begin()+lastinc, nums.end());\n        \n    }\n};class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n    int rows[9][9] = {0};\n    int cols[9][9] = {0};\n    int blocks[3][3][9] = {0};\n    \n    for(int r=0;r<9;r++)\n    {\n        for(int c=0;c<9;c++)\n        {\n            if(board[r][c]=='.')continue;\n            int num = board[r][c]-'1';\n            if(cols[num][c]++ || rows[r][num]++ || blocks[r/3][c/3][num]++)\n                return false;\n        }\n    }\n    \n    return true;\n        \n    }\n};#include<iostream>\n#include<vector>\nusing namespace std;\nvoid rev(vector<int> &v)\n{\n    int i = 0;\n    int j = v.size() -1;\n    while( i< j)\n    {\n        swap(v[i], v[j]);\n        i++;\n        j--;\n    }\n}\n    void rotate(vector<vector<int>>& matrix) {\n\n            \n        for(int i = 0; i< matrix.size(); i++)\n            for(int j = i; j < matrix[0].size(); j++)\n                swap(matrix[i][j] , matrix[j][i]);\n                        \n        for(int i = 0; i< matrix.size(); i++)\n            rev(matrix[i]);\n        \n        return;\n        \n    }\nint main(){\n    vector<vector<int>> arr = {{1,2,3},\n                                {4,5,6},\n                                {7,8,9}};\n    rotate(arr);\n    for(int i = 0; i< arr.size(); i++)\n    {\n        for(int j = 0; j<arr[0].size(); j++)\n            cout<< arr[i][j]<<\" \";\n        cout<<endl;\n    }\n    return 0;\n}class Solution {\npublic:\n    int findUnsortedSubarray(vector<int>& nums) {\n        vector<int> sorted = nums;\n        sort(sorted.begin(), sorted.end());\n        int i = 0, j = nums.size()-1;\n        while(i < nums.size() && nums[i] == sorted[i])\n            i++;\n        while(j> i && nums[j] == sorted[j])\n            j--;\n        return j-i+1;\n        \n    }\n};class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        unordered_set<int> row;\n        unordered_set<int> col;\n        for(int i = 0; i<matrix.size(); i++)\n        {\n            for(int j = 0; j<matrix[0].size(); j++)\n            {\n                if(matrix[i][j] == 0)\n                {\n                    row.insert(i);\n                    col.insert(j);\n                }\n            }\n        }\n        \n        for(int i = 0; i<matrix.size(); i++)\n        {\n            for(int j = 0; j<matrix[0].size(); j++)\n            {\n                if(row.find(i) != row.end() || col.find(j) != col.end())\n                {\n                    matrix[i][j]= 0;\n                }\n            }\n        }\n        \n        \n    }\n};class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int low = 0;\n        int high = nums.size()-1;\n        int mid = 0;\n        while(mid<= high)\n        {\n           if(nums[mid] == 0){\n               swap(nums[low],nums[mid]); \n               low++; mid++;\n           }\n          else if(nums[mid] == 1){\n                mid++;\n           }\n            else {\n               swap(nums[mid],nums[high]); \n               high --; \n           }\n        }\n        \n    }\n};class Solution {\npublic:\n    vector<int> sortArrayByParity(vector<int>& nums) {\n        vector<int> res;\n        for(int i = 0; i<nums.size(); i++)\n        {\n            if(nums[i] %2 == 0) res.push_back(nums[i]);\n        }\n        for(int i = 0; i<nums.size(); i++)\n        {\n            if(nums[i] %2 != 0) res.push_back(nums[i]);\n        }\n        return res;\n    }\n};// Problem Description\n\n// Given an integer array A containing N distinct integers, you have to find all the leaders\n// in the array A.\n\n// An element is leader if it is strictly greater than all the elements to its right side.\n\nvector<int> Solution::solve(vector<int> &nums) {\n   int rmax = 0;\n    vector<int>res;\n    for(int i=nums.size()-1;i>=0;i--)\n    {\n        if(nums[i]>rmax)\n            res.push_back(nums[i]);\n        rmax = max(rmax, nums[i]);\n    }\n    return res;\n}\n#include<iostream>>\nusing namespace std;\n#include<vector>\n#include<algorithm>\nint LongesrArithmeticSubarray(const vector<int> &A) {\n    int ans = 2;\n    int pd = A[1]-A[0];\n    int j = 2;\n    int curr = 2;\n    while(j<A.size())\n    {\n        if(pd == A[j]-A[j-1])\n            curr++;\n        else\n        {\n            pd = A[j]-A[j-1];\n            curr = 2;\n        }\n        ans = max(ans, curr);\n        j++;\n    }\n    return ans;\n}\n#include<unordered_map>\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        \n        unordered_map<int, int> mp(nums.size());\n        \n        for(int i = 0; i<nums.size(); i++)\n            mp[nums[i]]++;\n        \n        for(int i = 0; i<nums.size(); i++)\n        {\n            if(mp[nums[i]] > nums.size()/2)\n                return nums[i];\n        }\n        return -1;\n    }\n};using namespace std;\n#include<iostream>\n\nvoid bubble(int arr[], int n)\n{\n    for(int counter = 1; counter<n; counter++)\n    {\n        for(int i = 0; i<n-counter; i++)\n        {\n            if(arr[i]>arr[i+1])\n                swap(arr[i], arr[i+1]);        \n        }\n    }\n\n}\nint main()\n{\n    int n;\n    cin>>n;\n    int arr[n];\n    for(int i=0; i<n; i++)\n        cin>> arr[i];\n    bubble(arr,n);\n    for(int i =0; i<n; i++)\n        cout<<arr[i]<<\" \";\n}#include<iostream>\nusing namespace std;\n\n/* \n    insert an element from unsorted array to its correct position in sorted array\n*/\nvoid insertionSort(int arr[], int n){\n    for(int i = 1; i<n; i++)\n    {\n        int current = arr[i];\n        int j = i-1;\n        while(arr[j]> current && j>=0)\n        {\n            arr[j+1] = arr[j];\n            j--;\n        }\n        arr[j+1] = current;\n    }\n}\nint main(){\n    int n;\n    cin>>n;\n    int arr[n];\n    for(int i= 0; i<n; i++)\n        cin>> arr[i];\n    insertionSort(arr,n);\n    for(int i= 0; i<n; i++)\n        cout<< arr[i]<<\" \";\n}#include <vector>\n#include<algorithm>\n\nusing namespace std;\n// O(n) time | O(1) space\nint kadanesAlgorithm(vector<int> array) {\n    int maxEndingHere = array[0];\n    int maxSoFar = array[0];\n    for (int i = 1; i < array.size(); i++) {\n        int num = array[i];\n        maxEndingHere = max(num, maxEndingHere + num);\n        maxSoFar = max(maxSoFar, maxEndingHere);\n    }\n    return maxSoFar;\n}class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int n = nums.size();\n                \n        unordered_map<int,int> mp(n);\n        \n        for(int i = 0; i<n ; i++)\n            mp[nums[i]]++;\n        \n        for(int i = 0; i<n+1; i++)\n        {\n            if(mp.find(i) == mp.end()) // if the number not present in array\n                return i;\n        }\n        return -1;\n        \n    }\n};class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        \n        int missing = nums.size();\n        \n        for(int i = 0; i<nums.size(); i++)\n            missing = missing ^i^nums[i];\n        \n        return missing;\n        \n    }\n};#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<int> repeatedNumber(const vector<int> &A) {\n    long n = A.size();\n    long S1 = 0, S2 = 0;\n    for(int i:A)\n    {\n        S1 += i;\n        S2 += ((long)i)*i;\n    }\n    \n    long E1 = n*(n+1)/2;\n    long E2 = n*(n+1)*(2*n+1)/6;\n    \n    long D1 = S1-E1;\n    long D2 = S2-E2;\n    \n    long DIF = D1;\n    long SUM = D2/D1;\n    \n    long repeat = (SUM+DIF)/2;\n    long miss = (SUM-DIF)/2;\n    \n    return {(int)repeat,(int)miss};\n    \n}\nint main(){\n    \n}\n// [1 2]\n// [3 4]\n\n// [3 1]\n// [4 2]\n#include<iostream>\n#include<vector>\nusing namespace std;\nvoid reverse(vector<int> v)\n{\n    int i = 0;\n    int j = v.size() -1;\n    while( i< j)\n    {\n        swap(v[i], v[j]);\n        i++;\n        j--;\n    }\n}\nint main(){\n    vector<vector<int>> a;\n    int row, col;\n    cin>>row;\n    cin>> col;\n    for(int i = 0; i<row; i++)\n      for(int j = 0; j<col; j++)\n            cin>> a[i][j];\n\n    //so a[i][j] is our array\n    //find transpose of the matrix\n    // reverse each row\n    for(int i = 0; i< row; i++)\n    {\n        for(int j = i; j< col; j++)\n        {\n            swap(a[i][j], a[j][i]);\n        }\n    }\n    for(int i = 0; i< row; i++){\n        reverse(a[i]);\n    }\n    for(int i = 0; i<row; i++)\n    {\n      for(int j = 0; j<col; j++)\n      {\n        cout<< a[i][j];\n      }\n      cout<<endl;\n    }\n    return 0;      \n}using namespace std;\n#include<iostream>\nvoid selection(int arr[], int n)\n{\n    for(int i=0; i<n-1; i++)\n    {\n        for(int j= i+1; j<n; j++)\n        {\n            if(arr[j]<arr[i])\n                swap(arr[j],arr[i]);\n        }\n    }\n}\nint main()\n{\n    int n;\n    cin>>n;\n    int arr[n];\n    for(int i= 0; i<n; i++)\n        cin>> arr[i];\n    selection(arr,n);\n    for(int i = 0; i<n; i++)\n        cout<<arr[i]<<\" \";\n}class Solution {\n\npublic:\n    bool palindrome(string &str, int i,int j)\n    {\n        while(i<j)\n        {\n            if(str[i] == str[j])\n            {\n                i++;\n                j--;\n            }\n            else return false;\n        }\n        return true;\n    }\n    void backtrack(string &s, int index,vector<vector<string>> &res, vector<string> &part )\n    {\n        if(index == s.length()) {\n            res.push_back(part); //base contd\n            return;\n        }\n        for(int i = index; i< s.length(); i++)\n        {\n            \n            if(palindrome(s,index,i))\n            {\n                //choose --> explore---> unchoose\n                part.push_back(s.substr(index, i-index+1));\n                backtrack(s, i+1,res, part);\n                part.pop_back();\n            }\n        }\n        \n    }\n    vector<vector<string>> partition(string s) {\n        vector<vector<string>> res;\n        vector<string> part;\n        backtrack(s,0,res,part);\n        return res;\n    }\n};\n\nclass Solution {\npublic:\n    void solve(string &digits,int index,vector<string>& ip, vector<string>& res, string &curr)\n    {\n        if(index == digits.size())\n        {\n            res.push_back(curr);\n            return;\n        }\n        string c = ip[digits[index]-'0'];\n        for(int i = 0; i< c.size(); i++)\n        {\n                    curr.push_back(c[i]);\n                    solve(digits, index+1, ip,res,curr);\n                    curr.pop_back();\n        }\n        return;\n        \n    }\n    vector<string> letterCombinations(string digits) {\n        if(digits.size() == 0) return {};\n        vector<string> ip ={\"0\",\"1\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"};\n        vector<string> res;\n        string curr;\n        solve(digits,0,ip,res,curr);\n        return res;\n    }\n};class Solution {\npublic:\n    bool check(vector<vector<char>> &board, int i, int j, char val)\n    {\n        int row = i/3*3, column = j/3*3;\n        for(int x=0; x<9; x++) if(board[x][j] == val) return false;\n        for(int y=0; y<9; y++) if(board[i][y] == val) return false;\n        for(int x=0; x<3; x++)\n        for(int y=0; y<3; y++)\n            if(board[row+x][column+y] == val) return false;\n        return true;\n    }\n    bool solveSudoku(vector<vector<char>> &board, int i, int j)\n    {\n        if(i==9) return true;  // row end reached\n        if(j==9) return solveSudoku(board, i+1, 0); // col end reacher so next row\n        if(board[i][j] != '.') return solveSudoku(board, i, j+1);\n\n        for(char c='1'; c<='9'; c++)\n        {\n            if(check(board, i, j, c))\n            {\n                board[i][j] = c;   //choose \n                if(solveSudoku(board, i, j+1)) return true; // explore\n                board[i][j] = '.';  // unchoose\n            }\n        }\n\n        return false;\n    }    \n    void solveSudoku(vector<vector<char>>& board) {\n         solveSudoku(board,0,0);\n    }\n};class Solution {\npublic:\n    void findcombinations(vector<int>& candidates, int index,int target,vector<int> &combos,vector<vector<int>> &result )\n    {\n        //base contd.\n        if(target == 0) \n        {\n            result.push_back(combos);\n            return;\n        }\n        if(target < 0) return;\n        for(int i = index; i< candidates.size(); i++)\n        {\n             combos.push_back(candidates[i]);\n             findcombinations(candidates,i,target-candidates[i],combos,result);\n            combos.pop_back();\n        }\n    }\n    \n    \n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        vector<vector<int>> result;\n        vector<int> combos;\n        findcombinations(candidates,0, target,combos,result);\n        return result;\n    }\n};class Solution {\npublic:\n        void findcombinations(vector<int>& candidates, int index,int target,vector<int> &combos,vector<vector<int>> &result )\n    {\n        //base contd.\n        if(target == 0) \n        {\n            result.push_back(combos);\n            return;\n        }\n        if(target < 0) return;\n        for(int i = index; i< candidates.size(); i++)\n        {\n           if(i > index && candidates[i] == candidates[i-1]) continue; \n             combos.push_back(candidates[i]);\n             findcombinations(candidates,i+1,target-candidates[i],combos,result);\n            combos.pop_back();\n            \n        }\n    }\n    \n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<vector<int>> result;\n        vector<int> combos;\n        sort(candidates.begin(), candidates.end());\n        findcombinations(candidates,0, target,combos,result);\n        return result;\n    }\n};class Solution {\npublic:\n    void solve(vector<int> &nums,int l, int h, vector<vector<int>> &chosen)\n    {\n        if(l == h) { chosen.push_back(nums); return; }\n        for(int i = l; i< h; i++)\n        {\n            swap(nums[l],nums[i]);\n            solve(nums,l+1,h,chosen);\n            swap(nums[l], nums[i]);\n        }\n        return;\n\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> chosen;\n        solve(nums,0,nums.size(),chosen);\n        return chosen;\n    }\n};\n\n\n\n\n\n// Approach 2\nclass Solution {\npublic:\n    void solve(vector<int> &nums, vector<vector<int>> &chosen, vector<int> &result)\n    {\n        if(nums.size() == 0) { chosen.push_back(result); }\n        for(int i = 0; i< nums.size(); i++)\n        {\n            int digit = nums[i];\n            nums.erase(nums.begin()+i);\n            result.push_back(digit);\n            solve(nums,chosen,result);\n            result.pop_back();\n            nums.insert(nums.begin()+i, digit);\n        }\n        \n\n    }\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> chosen;\n        vector<int> result;\n        solve(nums,chosen, result);\n        return chosen;\n    }\n};class Solution {\npublic:\n    void solve(vector<int> &nums, int l, int h, set<vector<int>> &chosen)\n    {\n        if(l == h)\n        {\n            chosen.insert(nums);\n            return;\n        }\n        for(int i = l ; i< h; i++)\n        {\n            swap(nums[i], nums[l]);\n            solve(nums, l+1,h,chosen);\n            swap(nums[i], nums[l]);\n        }      \n        return;\n    }\n    \n    \n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        set<vector<int>> chosen;\n        solve(nums,0, nums.size(), chosen);\n        vector<vector<int>> result(chosen.begin(), chosen.end());\n        return result;\n    }\n};class Solution {\npublic:\n    vector<vector<string>> sol;\n    \n    bool place(vector<string> &board,int row, int col)\n    {\n        int i,j;\n        int n = board.size();\n        for(int i = 0; i< col; i++)\n            if(board[row][i]=='Q') return false;\n        //check left sided diagonal\n        for(int i = row, j = col; i<n && j>=0; i++,j--)\n            if(board[i][j]=='Q') return false;\n        //check right sided diagonal\n        for(int i = row, j = col; i>=0 && j>=0; i--,j--)\n            if(board[i][j]=='Q') return false;\n        \n        return true;\n    }\n    void solve(vector<string> &board,int col,int n)\n    {\n        if(col == n)\n        {\n            sol.push_back(board);\n            return;\n        }\n        for(int row = 0; row<n; row++)\n        {\n            if(place(board,row,col))\n            {\n                board[row][col] ='Q';\n                solve(board,col+1,n);\n                board[row][col]='.';\n            }\n        }\n        \n    }\n    \n    vector<vector<string>> solveNQueens(int n) {\n        vector<string> board(n,string(n,'.'));\n        solve(board,0,n);\n        return sol;\n    }\n};class Solution {\npublic:\n    void permute(int pos,int n, vector<bool>& visited, int &count)\n    {\n        if(pos>n) count++;\n        for(int i = 1; i<= n; i++)\n        {\n            if(!visited[i] && (pos%i == 0 || i%pos ==0))\n            {\n                visited[i] = true;\n                permute(pos+1,n,visited, count);\n                visited[i] = false;\n            }\n        }\n    }\n    int countArrangement(int n) {\n        vector<bool> visited(n+1,false);\n        int count = 0;\n        permute(1,n,visited,count);\n        return count;\n    }\n};class Solution {\npublic:\n    void solve(vector<int>& nums,int ind,vector<int> &curr,vector<vector<int>> &res)\n    {\n        res.push_back(curr);\n        for(int i = ind; i< nums.size(); i++)\n        {\n            curr.push_back(nums[i]);\n            solve(nums, i+1, curr, res);\n            curr.pop_back();\n        }\n        return ;\n\n    }\n    \n    \n    vector<vector<int>> subsets(vector<int>& nums) {\n\n        vector<vector<int>> res;\n        vector<int> curr;\n        solve(nums,0,curr,res);\n        return res;\n    }\n};class Solution {\npublic:\n  //  set<vector<in>>\n    void solve(vector<int>& nums, int ind,vector<int> &curr, set<vector<int>> &res)\n    {\n        res.insert(curr);\n        for(int i = ind; i<nums.size(); i++)\n        {\n            curr.push_back(nums[i]);\n            solve(nums, i+1, curr, res);\n            curr.pop_back();\n        }\n        return;\n    }\n    \n    \n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        vector<int> curr;\n        set<vector<int>> res;\n        sort(nums.begin(), nums.end());\n        solve(nums, 0 , curr, res);\n        vector<vector<int>> ans(res.begin(), res.end());\n        return ans;\n        \n    }\n};#include<iostream>\n#include<vector>\nusing namespace std;\n// private recursive helper to implement diceRolls logic\nvoid diceRollHelper(int dice, vector<int>& chosen) \n{\n    if (dice == 0) \n    {\n        cout<<'[';\n        for(auto num: chosen)\n         cout<< num<< \" \"; // base case\n        cout<<']';\n    } \n    else \n    {\n        for (int i = 1; i <= 6; i++) \n        {\n            chosen.push_back(i); // choose\n            diceRollHelper(dice - 1, chosen); // explore\n            chosen.pop_back(); // un-choose\n        }\n    }\n}\n// Prints all possible outcomes of rolling the given\n// number of six-sided dice in {#, #, #} format.\nvoid diceRolls(int dice) \n{\n    vector<int> chosen;\n    diceRollHelper(dice, chosen);\n}\nint main(){\n    int n; \n    cout<<\"Enter the available dice numbers \";\n    cin>>n;\n    diceRolls(n);\n    return 0;\n}\n\n\n\n\n\n/*\nEnter the available dice numbers 3\n[1 1 1 ][1 1 2 ][1 1 3 ][1 1 4 ][1 1 5 ][1 1 6 ][1 2 1 ][1 2 2 ][1 2 3 ][1 2 4 ][1 2 5 ][1 2 6 ][1 3 1 ][1 3 2 ][1 3 3 ][1 3 4 ][1 3 5 ][1 3 6 ][1 4 1 ][1 4 2 ][1 4 3 ][1 4 4 ][1 4 5 ][1 4 6 ][1 5 1 ][1 5 2 ][1 5 3 ][1 5 4 ][1 5 5 ][1 5 6 ][1 6 1 ][1 6 2 ][1 6 3 ][1 6 4 ][1 6 5 ][1 6 6 ][2 1 1 ][2 1 2 ][2 1 3 ][2 1 4 ][2 1 5 ][2 1 6 ][2 2 1 ][2 2 2 ][2 2 3 ][2 2 4 ][2 2 5 ][2 2 6 ][2 3 1 ][2 3 2 ][2 3 3 ][2 3 4 ][2 3 5 ][2 3 6 ][2 4 1 ][2 4 2 ][2 4 3 ][2 4 4 ][2 4 5 ][2 4 6 ][2 5 1 ][2 5 2 ][2 5 3 ][2 5 4 ][2 5 5 ][2 5 6 ][2 6 1 ][2 6 2 ][2 6 3 ][2 6 4 ][2 6 5 ][2 6 6 ][3 1 1 ][3 1 2 ][3 1 3 ][3 1 4 ][3 1 5 ][3 1 6 ][3 2 1 ][3 2 2 ][3 2 3 ][3 2 4 ][3 2 5 ][3 2 6 ][3 3 1 ][3 3 2 ][3 3 3 ][3 3 4 ][3 3 5 ][3 3 6 ][3 4 1 ][3 4 2 ][3 4 3 ][3 4 4 ][3 4 5 ][3 4 6 ][3 5 1 ][3 5 2 ][3 5 3 ][3 5 4 ][3 5 5 ][3 5 6 ][3 6 1 ][3 6 2 ][3 6 3 ][3 6 4 ][3 6 5 ][3 6 6 ][4 1 1 ][4 1 2 ][4 1 3 ][4 1 4 ][4 1 5 ][4 1 6 ][4 2 1 ][4 2 2 ][4 2 3 ][4 2 4 ][4 2 5 ][4 2 6 ][4 3 1 ][4 3 2 ][4 3 3 ][4 3 4 ][4 3 5 ][4 3 6 ][4 4 1 ][4 4 2 ][4 4 3 ][4 4 4 ][4 4 5 ][4 4 6 ][4 5 1 ][4 5 2 ][4 5 3 ][4 5 4 ][4 5 5 ][4 5 6 ][4 6 1 ][4 6 2 ][4 6 3 ][4 6 4 ][4 6 5 ][4 6 6 ][5 1 1 ][5 1 2 ][5 1 3 ][5 1 4 ][5 1 5 ][5 1 6 ][5 2 1 ][5 2 2 ][5 2 3 ][5 2 4 ][5 2 5 ][5 2 6 ][5 3 1 ][5 3 2 ][5 3 3 ][5 3 4 ][5 3 5 ][5 3 6 ][5 4 1 ][5 4 2 ][5 4 3 ][5 4 4 ][5 4 5 ][5 4 6 ][5 5 1 ][5 5 2 ][5 5 3 ][5 5 4 ][5 5 5 ][5 5 6 ][5 6 1 ][5 6 2 ][5 6 3 ][5 6 4 ][5 6 5 ][5 6 6 ][6 1 1 ][6 1 2 ][6 1 3 ][6 1 4 ][6 1 5 ][6 1 6 ][6 2 1 ][6 2 2 ][6 2 3 ][6 2 4 ][6 2 5 ][6 2 6 ][6 3 1 ][6 3 2 ][6 3 3 ][6 3 4 ][6 3 5 ][6 3 6 ][6 4 1 ][6 4 2 ][6 4 3 ][6 4 4 ][6 4 5 ][6 4 6 ][6 5 1 ][6 5 2 ][6 5 3 ][6 5 4 ][6 5 5 ][6 5 6 ][6 6 1 ][6 6 2 ][6 6 3 ][6 6 4 ][6 6 5 ][6 6 6 ]\n*/#include<iostream>\n#include<vector>\nusing namespace std;\n// private recursive helper to implement diceRolls logic\nint sumAll(const vector<int>& v) \n{\n    int sum = 0;\n    for (int k : v) { sum += k; }\n    return sum;\n}\nvoid diceRollHelper(int dice, int desiredSum, vector<int>& chosen,vector<vector<int>> &res) \n{\n    if (dice == 0){\n        if(sumAll(chosen) == desiredSum) \n        {\n            res.push_back(chosen);\n            return ;\n        }\n    } \n    else \n    {\n        for (int i = 1; i <= 6; i++) \n        {\n            chosen.push_back(i); // choose\n            diceRollHelper(dice - 1, desiredSum,chosen,res); // explore\n            chosen.pop_back(); // un-choose\n        }\n    }\n}\n// Prints all possible outcomes of rolling the given\n// number of six-sided dice in {#, #, #} format.\nvoid diceRolls(int dice,int desiredSum,vector<vector<int>> &res) \n{\n    vector<int> chosen;\n    diceRollHelper(dice, desiredSum,chosen,res);\n}\nint main(){\n    int n,sum; \n    cout<<\"Enter the available dice numbers \";\n    cin>>n;\n    cout<<\" desired sum \";\n    cin>>sum;\n    vector<vector<int>> res;\n    diceRolls(n,sum,res);\n    cout<<\"[\";\n    for(int i = 0; i<res.size(); i++)\n    {\n        cout<<'[';\n        for(int j = 0; j<res[i].size(); j++)\n        {\n            cout<<res[i][j]<<\" \";\n        }\n        cout<<']';\n    }\n    cout<<']';\n    return 0;\n}#include <iostream>\nusing namespace std;\n\nvoid permute(string a, int l, int r)\n{\n\t// Base case\n\tif (l == r)\n\t\tcout<<a<<endl;\n\telse\n\t{\n\t\tfor (int i = l; i <= r; i++)\n\t\t{\n\n\t\t\tswap(a[l], a[i]);\n\t\t\tpermute(a, l+1, r);\n            swap(a[l], a[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tstring str = \"ABC\";\n\tint n = str.size();\n\tpermute(str, 0, n-1);\n\treturn 0;\n}\n\n#include<iostream>\nusing namespace std;\nvoid printAllBinaryHelper(int digit, string sofar){\n    if(digit == 0)\n        cout<<sofar<<endl;\n    else{\n        printAllBinaryHelper(digit-1, sofar+\"0\");\n        printAllBinaryHelper(digit-1, sofar+\"1\");\n    }\n}\nvoid printAllBinary(int numDigits)\n{\n    printAllBinaryHelper(numDigits,\"\");\n}\nint main(){\n    int n; \n    cout<<\"Enter the length of binary strings to generate \";\n    cin>>n;\n    printAllBinary(n);\n}/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* construct_tree_from_arr(vector<int>& nums, int left, int right)\n    {\n        if(left>right) return NULL;\n        int mid = right +(left - right)/2;\n        TreeNode* node = new TreeNode(nums[mid]);\n        node->left = construct_tree_from_arr(nums,left,mid-1);\n        node->right = construct_tree_from_arr(nums,mid+1,right);              \n        return node;\n        \n    }\n    \n    \n    \n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        if(nums.size() == 0) return NULL;\n        else return construct_tree_from_arr(nums, 0, nums.size()-1);\n        \n    }\n};/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode *sortedListToBSThelper(ListNode *head, ListNode *tail)\n    {\n    \tif( head == tail )\n    \t\treturn NULL;\n    \tif( head->next == tail )    \n    \t{\t\n    \t\tTreeNode *root = new TreeNode( head->val );\n    \t\treturn root;\n    \t}\n    \tListNode *mid = head, *temp = head;\n    \twhile( temp != tail && temp->next != tail )  \n    \t{\n    \t\tmid = mid->next;\n    \t\ttemp = temp->next->next;\n    \t}\n    \tTreeNode *root = new TreeNode( mid->val );\n    \troot->left = sortedListToBSThelper( head, mid );\n    \troot->right = sortedListToBSThelper( mid->next, tail );\n    \treturn root;\n    }\n    TreeNode* sortedListToBST(ListNode* head) {\n            return sortedListToBSThelper(head,NULL);\n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> in;\n    void inorder(TreeNode* root){\n        if(!root) return;\n        inorder(root->left);\n        in.push_back(root);\n        inorder(root->right);\n    }\n    TreeNode* constructTree(int start , int end)\n    {\n        if(start>end) return NULL;\n        int mid = (start+end)/2;\n        TreeNode* root = in[mid];\n        root->left = constructTree(start,mid-1);\n        root->right = constructTree(mid+1,end);\n        return root;\n        \n    }\n    TreeNode* balanceBST(TreeNode* root) {\n        if(!root) return NULL;\n        inorder(root);\n        root = constructTree(0, in.size()-1);\n        return root;       \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n int count = 0 ;\n    int kthSmallest(TreeNode* root, int k) {\n        TreeNode* res = kthsmall(root,k);\n        return res->val;\n        \n    }\n    TreeNode* kthsmall(TreeNode* root, int k)\n    {\n        if(!root) return NULL;\n        \n        TreeNode* left = kthsmall(root->left,k);\n        if(left) return left;\n        count++;\n        if(count == k) return root;\n        return kthsmall(root->right,k);\n           \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(p->val < root->val && q->val < root->val)\n                return lowestCommonAncestor(root->left, p ,q);\n        else if(p->val > root->val && q->val > root->val)\n                return lowestCommonAncestor(root->right, p ,q);\n        else return root;\n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (!root) return root;    \n        if (root->val > key)\n            root->left = deleteNode(root->left, key);\n        else if (root->val < key)\n            root->right = deleteNode(root->right, key);\n        else {\n            if (!root->left) {\n                TreeNode* right = root->right;\n                delete root;\n                return right;\n            }\n            else if (!root->right) {\n                TreeNode* left = root->left;\n                delete root;\n                return left;\n            }\n            else {\n                TreeNode* successor = findMinNode(root->right); // find the inorder successor (the minimal node in                                                                              right subtree)\n                root->val = successor->val;\n                root->right = deleteNode(root->right, successor->val);\n            }\n        }\n        return root;\n    }\nprivate:\n    TreeNode* findMinNode(TreeNode* root) {\n        if (root->left) return findMinNode(root->left);\n        return root;\n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if(!root){\n            TreeNode* newnode = new TreeNode(val);\n            return newnode;\n        }\n        if(val<=root->val) \n            root->left = insertIntoBST(root->left,val);\n        else\n            root->right = insertIntoBST(root->right,val);\n        return root;\n    }\n};#include<iostream>\n#include<vector>\nusing namespace std;\n// BRute forece solution\nint countsetBit(int n){\n    int count = 0;\n    while(n){\n        n &= (n-1);\n        count++;\n    }\n    return count;\n}\nint cntBits(vector<int> &A) {\n    int res = 0;\n    for(int i = 0; i<A.size(); i++)\n    {\n        for(int j = 0; j<A.size(); j++)\n        {\n           int x = A[i]^A[j];\n           res+= countsetBit(x);\n        }\n    }\n    return res;\n}\n\n// Efficient solution\nint cntBits2(vector<int> &A) {\n        long long int ans=0,n=A.size();\n        long long int count;\n        for(int i=0;i<31;i++){\n            count=0;\n            for(int j=0;j<n;j++){\n                if(A[j]&(1<<i))\n                 count++;\n            }\n            ans=(ans+count*(n-count)*2)%1000000007;\n        }\n        return ans;\n}\n\nint main(){\n    vector<int> ip={1,3,5};\n    int res = cntBits(ip);\n    cout<< res<<endl;\n    return 0;\n}\n#include<iostream>\nusing namespace std;\nint getBit(int n, int pos)\n{\n    return (n&(1<<pos) != 0);\n}\nint setBit(int n, int pos)\n{\n    return n | (1<<pos);\n}\nint clearBit(int n, int pos)\n{\n    int mask = ~(1<<pos);\n    return n& mask;\n}\nint updateBit(int n, int pos, int value){\n    //we first clear the bit and then set the bit\n    int mask = ~(1<<pos);\n    n= n& mask;\n    return n|(value<<pos);\n}\nint main(){\n    cout<<getBit(5,2)<<endl;\n}int Solution::solve(int A) {\n    if(A==0)return 0;\n    long long int mx = log2(A);\n    long long int x = pow(2,mx);\n    x%=1000000007;\n    return (x/2*mx+(A-x+1)+solve(A-x))%1000000007;\n}\nint Solution::divide(int A, int B) {\n   if(A==INT_MIN&&B==-1)\n    return INT_MAX;\n    long long int a=A,b=B;\n    int sign = ((A < 0) ^ (B < 0)) ? -1 : 1;\n    a=abs(a);b=abs(b);\n    int ans=0;\n    while(a>=b)\n    { a=a-b;\n    ans++;\n    }\n    return ans*sign;\n}\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int z = x ^ y;\n        int count = 0;\n        while(z){\n            z &= (z-1);\n            count++;\n        }\n    return count;\n    }\n};int Solution::findMinXor(vector<int> &A) {\n    sort(A.begin(), A.end());\n    int mn = INT_MAX;\n    for(int i = 0; i< A.size()-1; i++){\n        int xx = A[i]^A[i+1];\n        mn = min(xx,mn);\n    }\n    return mn;\n}\nint Solution::numSetBits(unsigned int n) {\n  unsigned int count = 0;\n  while(n){\n      n &= (n-1);\n      count++;\n  }\n  return count;\n}\n//Reverse the bits of an 32 bit unsigned integer A.\n\nunsigned int Solution::reverse(unsigned int n) {\n   unsigned int reverse = 0;\n   int pos = 31;\n   while(pos >= 0 && n){\n       if(n&1) reverse = reverse | (1<<pos);\n       n>>= 1;\n       pos--;\n   }\n   return reverse;\n}\nint Solution::singleNumber(const vector<int> &A) {\n    int xr = A[0];\n    for(int i = 1; i< A.size(); i++)\n    {\n        xr ^= A[i];\n    }\n    return xr;\n}\nint Solution::singleNumber(const vector<int> &A) {\n    vector<int> f(32,0);\n    for(int e : A)\n    {\n        for(int i = 0;i<32;i++)\n            if(e & (1<<i)) f[i]++;\n    }\n    int res = 0; \n    for(int i =0;i<32;i++)\n        if(f[i] % 3 == 1) res+= (1<<i);\n    return res;\n}\nint Solution::solve(int A) {\n    int count =0;\n    while(!(A&1)){\n        count++;\n        A=A>>1;\n    }\n    return count;\n}int Solution::solve(vector<int> &A) {\n    int n = A.size();\n    int res = 0;\n    for(int i = 0; i<n; i++)\n    {\n        int freq = (i+1)* (n-i);\n        if(freq %2 == 1) \n              res = res^A[i];\n    }\n    return res;\n}\nclass Solution {\npublic:\n\tvoid merge(vector<int>& nums, int l, int m, int r){\n        vector<int> tmp(r - l + 1);\n        int i = l; // index for left subarray\n        int j = m + 1; // index for right subarray\n        int k = 0; // index for temporary array\n        while(i <= m && j <= r){\n            if(nums[i] <= nums[j]) tmp[k++] = nums[i++]; \n            else tmp[k++] = nums[j++];\n        }\n        while(i <= m) tmp[k++] = nums[i++];\n        while(j <= r) tmp[k++] = nums[j++]; \n        for(i = 0; i < k; i++) nums[l + i] = tmp[i];\n    }\n\t\n\t// mergeSort(nums, 0, nums.size() - 1);\n    void mergeSort(vector<int>& nums, int l, int r){\n        if(l >= r) return;\n        int m = l + (r - l) / 2; //middle index, same as (l+r)/2\n        mergeSort(nums, l, m);\n        mergeSort(nums, m + 1, r);\n        merge(nums, l, m, r);\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums,0, nums.size()-1);\n        return nums;\n        \n    }\n};class Solution {\npublic:\n    // int partitionIndex(vector<int>& nums, int low, int high){\n    //     int index = low-1;\n    //     for (int j=low;j<=high;j++){\n    //         if (nums[j]<= nums[high]){\n    //             index++;\n    //             swap(nums[index], nums[j]);\n    //         }\n    //     }\n    //     return index;\n    // }\n    int partitionIndex(vector<int>& nums, int low, int high){\n        int randIndex = low + rand()%(high-low+1);\n        swap(nums[randIndex], nums[high]);\n        int index = low-1;\n        for (int j=low;j<=high;j++){\n            if (nums[j]<= nums[high]){\n                index++;\n                swap(nums[index], nums[j]);\n            }\n        }\n        return index;\n    }\n    void quickSortHelper(vector<int>& nums, int low, int high){\n        if (low<high){\n            int p = partitionIndex(nums, low, high);\n            quickSortHelper(nums, low, p-1);\n            quickSortHelper(nums, p+1, high);\n        }\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        quickSortHelper(nums,0,nums.size()-1);\n        return nums;\n    }\n};#include<iostream>\n#include<vector>\nusing namespace std;\nclass Graph\n{\n    int nodes;\n    vector<vector<int>> adjList;\n    void dfs_recursion(int start, vector<bool>& visited)\n    {\n        visited[start] = true;\n        cout<<start<<endl;\n        for(int u: adjList[start])\n        {\n            if(!visited[u]) dfs_recursion(u,visited);\n        }\n    }\n    public:\n    Graph(int n): nodes(n), adjList(n){}\n    void addEdge(int src, int dest)\n    {\n        adjList[src].push_back(dest);\n    }\n    void DFS()\n    {\n        vector<bool> visited(nodes, false);\n        for(int i = 0; i< nodes; i++)\n        {\n            if(!visited[i]) dfs_recursion(i,visited);\n        }\n    }\n};\nint main()\n{\n    Graph G(5);\n    G.addEdge(0,1);\n    G.addEdge(1,2);\n    G.addEdge(0,3);\n    G.addEdge(3,4);\n    G.addEdge(4,0);\n    G.addEdge(4,2);\n    G.DFS();\n    return 0;\n}\n #include<iostream>\n#include<vector>\n\nusing namespace std;\n    void change(vector<vector<char>>& A,int x, int y)\n    {\n        A[x][y]='#';\n        int dx[] = {0,0,-1,1};\n        int dy[] = {1,-1,0,0};\n        for(int i = 0; i<4; i++)\n        {\n            int cx = x+dx[i];\n            int cy = y+dy[i];\n            if(cx>=0 && cx<A.size() && cy>=0 && cy<A[0].size() && A[cx][cy] == 'O')\n                change(A,cx,cy);\n        }\n    }\n    void solve(vector<vector<char>>& board) {\n        for(int i=0; i< board.size(); i++)\n        {\n            for(int j = 0; j<board[0].size(); j++)\n            {\n               if(i==0 || i== board.size()-1 || j==0 || j== board[0].size()-1) \n                if(board[i][j]=='O' )\n                    change(board,i,j);\n            }\n        }\n         for(int i=0; i< board.size(); i++)\n        {\n            for(int j = 0; j<board[0].size(); j++)\n            {\n                if(board[i][j]== 'O')\n                    board[i][j]='X';\n            }\n        }\n\n        for(int i=0; i< board.size(); i++)\n        {\n            for(int j = 0; j<board[0].size(); j++)\n            {\n                if(board[i][j]=='#')\n                    board[i][j]='O';\n            }\n        }\n        \n        \n    }\n    int main(){\n        int n,m; cin>>n>>m;\n        vector<vector<char>> graph(n,vector<char>(m));\n        for(int i = 0; i<n; i++)\n            for(int j = 0; j<m; j++)\n                cin>>graph[i][j];\n        solve(graph);\n        for(int i = 0; i<n; i++){\n            for(int j = 0; j<m; j++){\n                cout<<graph[i][j]<<\" \";\n            }\n            cout<<endl;\n        }\n    }class Solution {\npublic:\n    void dfs(unordered_map<int,vector<int>>& connections,int start,vector<bool> &visited)\n    {\n        if(visited[start]) return;\n        visited[start] = true;\n        for(auto child:connections[start])\n            if(!visited[child]) dfs(connections,child,visited);\n        \n    }\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        if(connections.size() < n-1) return -1;\n        unordered_map<int,vector<int>> graph;\n          vector<bool> visited(n,false);\n        int components = 0;\n        for(auto e : connections){\n            graph[e[0]].push_back(e[1]);\n            graph[e[1]].push_back(e[0]);\n        }\n        for(int i=0; i< n; i++){\n            if(!visited[i]){\n            dfs(graph,i,visited);\n            components++;\n            }\n        }\n        return components-1;\n    }\n};class Solution {\npublic:\n    const int N = 1e5;\n    vector<int> parent = vector<int>(N);\n    vector<int> sz = vector<int>(N);\n    void makeset(int i)\n    {\n        parent[i] = i;\n        sz[i] = 1;\n    }\n    int find_set(int v)\n    {\n        if(v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n    void union_set(int u,int v){\n        int a = find_set(u);\n        int b = find_set(v);\n        if(a!=b){\n            if(sz[a]<sz[b])\n                swap(a,b);\n            parent[b] = a;\n            sz[a]+=sz[b];\n        }\n            \n    }\n    int makeConnected(int n, vector<vector<int>>& connections) {\n        if(connections.size() < n-1) return -1;\n        for(int i = 0; i<N; i++)\n            makeset(i);\n        int groups = n;\n        for(int i = 0; i< connections.size(); i++)\n        {\n            int x = find_set(connections[i][0]);\n            int y = find_set(connections[i][1]);\n            if(x!=y){\n                groups--;\n                union_set(x,y);\n            }\n        }\n        return groups-1;\n    }\n};#include<iostream>\n#include<vector>\nusing namespace std;\nenum node_states{\n    UNVISITED,  \n    INSTACK,\n    VISITED        \n};\nclass Graph\n{\n    int nodes;\n    vector<vector<int>> adjList;\n    bool dfs_recursion(int start, vector<node_states>& visited)\n    {\n        visited[start] = INSTACK;\n        for(int u: adjList[start])\n        {\n            if(visited[u] == INSTACK) return true;\n            if(visited[u] == UNVISITED && dfs_recursion(u,visited)) \n                return true;\n        }\n        visited[start] = VISITED;\n        return false;\n    }\n    public:\n    Graph(int n): nodes(n), adjList(n){}\n    void addEdge(int src, int dest)\n    {\n        adjList[src].push_back(dest);\n    }\n    bool hasCycle()\n    {\n        vector<node_states> visited(nodes, UNVISITED);\n        for(int i = 0; i< nodes; i++)\n        {\n            if(visited[i]==UNVISITED && dfs_recursion(i,visited))\n                return true;\n        }\n        return false;\n    }\n};\nint main()\n{\n    Graph G(5);\n    G.addEdge(0,1);\n    G.addEdge(1,2);\n    G.addEdge(0,3);\n    G.addEdge(3,4);\n    G.addEdge(0,4);\n    G.addEdge(4,2);\n    cout<< G.hasCycle()<< endl;\n    return 0;\n}\nclass Solution {\npublic:\n    void dfs(vector<vector<char>>& grid, int i, int j)\n    {\n        if(i<0 || i>= grid.size() || j<0 || j>= grid[0].size() || grid[i][j] == '0')\n            return;\n        grid[i][j] = '0';\n        dfs(grid, i-1,j);\n        dfs(grid,i+1,j);\n        dfs(grid, i, j-1);\n        dfs(grid, i, j+1);\n            \n    }\n    \n    int numIslands(vector<vector<char>>& grid) \n    {\n        int count = 0; \n        for(int i = 0; i< grid.size(); i++)\n        {\n            for(int j = 0; j< grid[0].size(); j++)\n            {\n                if(grid[i][j] =='1')\n                {\n                    dfs(grid, i, j);   \n                    count++;\n                }\n            }\n        }\n        return count;\n        \n    }\n};class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& edges){\n        vector<int> sortedorder;\n        if(numCourses <= 0)\n            return false;\n    //initialization\n        unordered_map<int, int> indegree;\n        unordered_map<int, vector<int>> graph;\n        for(int i = 0; i< numCourses; i++)\n        {\n            indegree[i] = 0;\n            graph[i] = vector<int>();\n        }\n    //Build the graph\n    for(int i = 0; i<edges.size(); i++)\n    {\n        int parent = edges[i][0], child = edges[i][1];\n        graph[parent].push_back(child);\n        indegree[child]++;\n    }\n    queue<int> q;\n    for (auto i: indegree){\n        if(i.second == 0)\n            q.push(i.first);\n    }\n    while(!q.empty())\n    {\n        int vertex = q.front();\n        q.pop();\n        sortedorder.push_back(vertex);\n        vector<int> children= graph[vertex];\n        for(auto child: children)\n        {\n            indegree[child]--;\n            if(indegree[child] == 0)\n                q.push(child);\n        }\n    }\n      return sortedorder.size() == numCourses;    \n    }\n};class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& edges) {\n        vector<int> sortedorder;\n        if(numCourses <= 0)\n            return sortedorder;\n    //initialization\n        unordered_map<int, int> indegree;\n        unordered_map<int, vector<int>> graph;\n        for(int i = 0; i< numCourses; i++)\n        {\n            indegree[i] = 0;\n            graph[i] = vector<int>();\n        }\n    //Build the graph\n    for(int i = 0; i<edges.size(); i++)\n    {\n        int child = edges[i][0], parent = edges[i][1];\n        graph[parent].push_back(child);\n        indegree[child]++;\n    }\n    queue<int> q;\n    for (auto i: indegree){\n        if(i.second == 0)\n            q.push(i.first);\n    }\n    while(!q.empty())\n    {\n        int vertex = q.front();\n        q.pop();\n        sortedorder.push_back(vertex);\n        vector<int> children= graph[vertex];\n        for(auto child: children)\n        {\n            indegree[child]--;\n            if(indegree[child] == 0)\n                q.push(child);\n        }\n    }\n      if (sortedorder.size() != numCourses)\n          return vector<int>();  \n       return sortedorder;\n        \n    }\n};/*\nThere is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.\nExample 1:\nGiven the following words in dictionary,\n[\n  \"wrt\",\n  \"wrf\",\n  \"er\",\n  \"ett\",\n  \"rftt\"\n]\nThe correct order is: \"wertf\".\nExample 2:\nGiven the following words in dictionary,\n[\n  \"z\",\n  \"x\"\n]\nThe correct order is: \"zx\".\nExample 3:\nGiven the following words in dictionary,\n[\n  \"z\",\n  \"x\",\n  \"z\"\n]\nThe order is invalid, so return \"\".\nNote:\nYou may assume all letters are in lowercase.\nYou may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\nIf the order is invalid, return an empty string.\nThere may be multiple valid order of letters, return any one of them is fine.\n\nThought process:\nTopological sort:\nBuild graph: \na map of character -> set of character.\nAlso get in-degrees for each character. In-degrees will be a map of character -> int.\nTopological sort:\nLoop through in-degrees. Offer the characters with in-degree of 0 to queue.\nWhile queue is not empty:\nPoll from queue. Append to character to result string.\nDecrease the in-degree of polled character's children by 1.\nIf any child's in-degree decreases to 0, offer it to queue.\nAt last, if result string's length is less than the number of vertices, that means there is a cycle in my graph. The order is invalid.\n*/\n#include<iostream>\nusing namespace std;\n#include<vector>\n#include<unordered_map>\n#include<queue>\n#include<algorithm>\n#include<list>\n\nstring alienOrder(vector<string>& words)\n{\n    //create 2 unordered_maps one for adjacency list and one for indegree\n    unordered_map<char, list<char>> adjList;\n    unordered_map<char, int> indegree;\n    //initialize\n    for(string &str: words)\n    {\n        for(char &ch : str)\n        {\n            indegree[ch] = 0;\n            list<char> li;\n            adjList[ch] = li;\n        }\n    }\n    //we pick the words in pair and traverse all its character and get dependency graph\n    for(int i = 0; i<words.size()-1; i++)\n    {\n        string w1 = words[i];\n        string w2= words[i+1];\n        //if w2 is prefix of w1,then we return \"\"\n        auto res = mismatch(w2.begin(), w2.end(), w1.begin());\n        if(w1.size() > w2.size() && res.first == w2.end()) \n                return \"\";\n        //now we build the dependency graph\n        for(int j = 0; j< min(w1.size(), w2.size()); j++)\n        {\n            if(w1[j] != w2[j])\n            {\n                adjList[w1[j]].push_back(w2[j]);\n                indegree[w2[j]]+=1;\n                break;\n            }\n        }\n    }\n    // now we apply topological sort :D\n    //bfs traversal method\n    string str = \" \";\n    queue<char> q;\n    //first push all the \n    for(auto it = indegree.begin(); it != indegree.end(); it++)\n    {\n        if(indegree[it->first] == 0)\n            q.push(it->first);\n    }\n    while(!q.empty())\n    {\n        char ch = q.front(); q.pop();\n        str+= ch;\n        for(char &neighbour : adjList[ch])\n        {\n            indegree[neighbour] -= 1;\n            if(indegree[neighbour] == 0)\n                q.push(neighbour);\n        }\n    }\n    if(str.size() < indegree.size()) return \"\"; //cycle so no topo sort\n    return str;\n}\nint main()\n{\n    vector<string> s = {\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"};\n    cout<< alienOrder(s)<<endl;\n    return 0;\n}#include<iostream>\n#include<vector>\nusing namespace std;\nclass Graph\n{\n    int nodes;\n    vector<vector<int>> adjList;\n    bool hasCycle_recursion(int start, vector<bool>& visited,int parent)\n    {\n        visited[start] = true;\n        for(int u: adjList[start])\n        {\n            if(visited[u] && u!=parent) return true;\n            if(!visited[u] && hasCycle_recursion(u,visited,start)) return true;\n        }\n        return false;\n    }\n    public:\n    Graph(int n): nodes(n), adjList(n){}\n    void addEdge(int src, int dest)\n    {\n        adjList[src].push_back(dest);\n        adjList[dest].push_back(src);\n    }\n    bool hasCycle()\n    {\n        vector<bool> visited(nodes, false);\n        for(int i = 0; i< nodes; i++)\n        {\n            if(!visited[i] && hasCycle_recursion(i,visited,-1)) \n                return true;\n        }\n        return false;\n    }\n};\nint main()\n{\n    Graph G(5);\n    G.addEdge(0,1);\n    G.addEdge(1,2);\n    G.addEdge(0,3);\n    G.addEdge(3,4);\n    G.addEdge(4,0);\n    G.addEdge(4,2);\n    cout<<boolalpha<<G.hasCycle()<<endl; //true\n    return 0;\n}\n#include<iostream>\n#include<vector>\n#include<stack>\nusing namespace std;\nclass Graph\n{\n    int nodes;\n    vector<vector<int>> adjList;\n    void TS_recursion(int start, vector<bool>& visited, stack<int>& st)\n    {\n        visited[start] = true;\n        for(int u: adjList[start])\n        {\n            if(!visited[u]) TS_recursion(u,visited,st);\n        }\n        st.push(start);\n    }\n    public:\n    Graph(int n): nodes(n), adjList(n){}\n    void addEdge(int src, int dest)\n    {\n        adjList[src].push_back(dest);\n    }\n    void topologicalSort()\n    {\n        vector<bool> visited(nodes, false);\n        stack<int> st;\n        for(int i = 0; i< nodes; i++)\n        {\n            if(!visited[i]) TS_recursion(i,visited,st);\n        }\n        while(!st.empty())\n         {\n             cout<<st.top()<<\" \";\n             st.pop();\n         }\n    }\n};\nint main()\n{\n    Graph G(5);\n    G.addEdge(0,1);\n    G.addEdge(1,2);\n    G.addEdge(0,3);\n    G.addEdge(3,4);\n    G.addEdge(4,0);\n    G.addEdge(4,2);\n    G.topologicalSort();\n    return 0;\n}\nusing namespace std;\n#include<unordered_map>\n#include<queue>\n#include<vector>\n#include<iostream>\nclass TopologicalSort {\npublic:\n    static vector<int> Toposort(int vertices, const vector<vector<int>>& edges){\n        vector<int> sortedorder;\n        if(vertices <= 0)\n            return sortedorder;\n    //initialization\n        unordered_map<int, int> indegree;\n        unordered_map<int, vector<int>> graph;\n        for(int i = 0; i< vertices; i++)\n        {\n            indegree[i] = 0;\n            graph[i] = vector<int>();\n        }\n    //Build the graph\n    for(int i = 0; i<edges.size(); i++)\n    {\n        int parent = edges[i][0], child = edges[i][1];\n        graph[parent].push_back(child);\n        indegree[child]++;\n    }\n    queue<int> q;\n    for (auto i: indegree){\n        if(i.second == 0)\n            q.push(i.first);\n    }\n    while(!q.empty())\n    {\n        int vertex = q.front();\n        q.pop();\n        sortedorder.push_back(vertex);\n        vector<int> children= graph[vertex];\n        for(auto child: children)\n        {\n            indegree[child]--;\n            if(indegree[child] == 0)\n                q.push(child);\n        }\n    }\n      if(sortedorder.size() != vertices)\n        return vector<int>();   \n    return sortedorder;\n    }\n};\n\nint main(){\n    vector<int> result = TopologicalSort::Toposort(4,vector<vector<int>>{vector<int>{3,2},\n           vector<int>{3,0},\n           vector<int>{2,0},\n           vector<int>{2,1} });\n        for(auto num : result)\n            cout<<num<<\" \";\n}class Solution {\npublic:\n    vector<int> parent = vector<int>(200);\n    vector<int> sz = vector<int>(200);\n    void make_set(int v)\n    {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n    int find_set(int v)\n    {\n        if(v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n    void union_set(int a, int b)\n    {\n        a = find_set(a);\n        b = find_set(b);\n        if(a != b)\n        {\n            if(sz[a] < sz[b])\n                swap(a,b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        } \n    }\n    int findCircleNum(vector<vector<int>>& M) {\n        for(int i = 0; i< 200; i++)\n             make_set(i);\n        int groups = M.size();\n        for(int i = 0; i<M.size(); i++)\n        {\n            for(int j= 0; j<M.size(); j++)\n            {\n                if(M[i][j]){\n                    int u = find_set(i);\n                    int v = find_set(j);\n                    if(u!=v)\n                    {\n                        groups--;\n                        union_set(u,v);\n                    }\n                }\n            }\n        }\n        \n        return groups;\n    }\n};class Solution {\npublic:\n    void dfs_helper(unordered_map<int,vector<int>> &mp, int src, vector<bool>& visited)\n    {\n        visited[src]=true;\n        for(auto child: mp[src])\n        {\n            if(!visited[child]) dfs_helper(mp,child,visited);\n        }\n    }\n    int dfs(unordered_map<int,vector<int>> &mp, int n)\n    {\n        vector<bool> visited(n,false);\n         int component = 0;\n        for(int i = 0; i< n; i++)\n        {\n           if(!visited[i]) \n           {\n                dfs_helper(mp,i,visited);\n                component++;\n            }\n        }\n        return component;\n    }\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        //1. convert the adjacency matrix to adjacency list\n        //2. then implement dfs helper method using start node and then explore children\n        //3. run for loop and inside dfs_helper\n        unordered_map<int, vector<int>> mp;\n        int vertices = isConnected.size();\n        for(int i = 0; i< isConnected.size(); i++){\n            for(int j = 0; j< isConnected.size(); j++)\n            {\n                if(isConnected[i][j]) mp[i].push_back(j);\n            }\n        }\n        return dfs(mp, vertices);\n        \n    }\n};const int N = 2000;\nclass Solution {\npublic:  \n    vector<int> parent{vector<int>(2000)};\n    vector<int> sz{vector<int>(2000)};\n    void make_set(int v)\n    {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n    int find_set(int v)\n    {\n        if(v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n    void union_set(int a, int b)\n    {\n        a = find_set(a);\n        b = find_set(b);\n        if(a != b)\n        {\n            if(sz[a] < sz[b])\n                swap(a,b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        } \n    }\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        vector<int> res;\n        for(int i = 0; i< 2000; i++)\n             make_set(i);\n        for(auto i: edges)\n        {\n            int u = i[0];\n            int v = i[1];\n            int x = find_set(u);\n            int y = find_set(v);\n            if(x==y){\n              res.push_back(u);\n              res.push_back(v);\n            }\n            else \n                union_set(u,v);\n        }\n        return res;\n        \n    }\n};class Solution {\npublic:\n    void dfs(vector<vector<int>>& image, int i, int j, int color,int newColor)\n    {\n        if(i<0 || j<0 || i>=image.size() || j>= image[0].size() || image[i][j] != color)\n                return;\n        image[i][j] = newColor;\n        dfs(image,i-1,j,color,newColor);\n        dfs(image,i,j-1,color,newColor);\n        dfs(image,i+1,j,color,newColor);\n        dfs(image,i,j+1,color,newColor);\n\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\n        if(image[sr][sc] != newColor)\n            dfs(image,sr,sc,image[sr][sc],newColor);\n        return image;\n    }\n};class Solution {\npublic:\n    int openLock(vector<string>& deadends, string target) {\n        unordered_set<string> dds(deadends.begin(), deadends.end());\n        unordered_set<string> visited;\n        queue<string> bfs;\n        string init = \"0000\";\n        if (dds.find(init) != dds.end()) return -1;\n        visited.insert(\"0000\");\n        bfs.push(\"0000\");\n        int res = 0;\n        while (!bfs.empty()) {\n            int sz = bfs.size();\n            for (int i = 0; i < sz; i++) {\n                string t = bfs.front(); bfs.pop();\n                if(t == target) return res;\n                vector<string> nbrs = move(nbrStrs(t));\n                for (auto s : nbrs) {\n                    if (visited.find(s) == visited.end() && dds.find(s) == dds.end()) {\n                        bfs.push(s);\n                        visited.insert(s);\n                    }\n                }\n            }\n            ++res;\n        }\n        return -1;\n    }\n    \n    \n    vector<string> nbrStrs(string key) {\n        vector<string> res;\n        for (int i = 0 ; i < 4; i++) {\n            string tmp = key;\n            tmp[i] = (key[i] - '0' + 1) % 10 + '0';\n            res.push_back(tmp);\n            tmp[i] = (key[i] - '0' - 1 + 10) % 10 + '0';\n            res.push_back(tmp);\n         }\n        return res;\n    }\n};class Solution {\npublic:\n    vector<vector<int>> visited;\n    int R,C;\n    void dfs(vector<vector<int>> &grid, int mid, int x, int y)\n    {\n        if(!visited[x][y] && grid[x][y]<= mid)\n        {\n            visited[x][y] = true;\n            if(x-1>= 0) dfs(grid,mid,x-1,y);\n            if(x+1<R)  dfs(grid,mid,x+1,y);\n            if(y-1>=0) dfs(grid,mid,x,y-1);\n            if(y+1<C) dfs(grid,mid,x,y+1);\n        }\n    }\n    int swimInWater(vector<vector<int>>& grid) {\n        int l = 0;\n        int r = 50*50;\n        R = grid.size();\n        C = grid[0].size();\n        while(l<r)\n        {\n            int mid = (l+r)/2;\n            visited = vector<vector<int>>(R,vector<int>(C,0));\n            dfs(grid,mid,0,0);\n            if(visited[R-1][C-1])\n                r = mid;\n            else l = mid+1;\n        }\n        return l;\n    }\n};class Solution {\npublic:\n/*\n    Connected stones can be reduced to 1 stone,\n    the maximum stones can be removed = stones number - islands number.\n    so just count the number of \"islands\".\n*/\n    vector<int> parent = vector<int>(1000);\n    vector<int> sz = vector<int>(1000);\n    void make_set(int v)\n    {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n    int find_set(int v)\n    {\n        if(v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n    void union_set(int a, int b)\n    {\n        a = find_set(a);\n        b = find_set(b);\n        if(a != b)\n        {\n            if(sz[a] < sz[b])\n                swap(a,b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        } \n    }\n    int removeStones(vector<vector<int>>& stones) {\n         for(int i = 0; i< 1000; i++)\n             make_set(i);\n        int groups = stones.size();\n        int n = stones.size();\n        for(int i=0;i<n;i++){\n            for(int j=0;j<i;j++){\n                if(stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1])\n                {\n                    int u = find_set(i);\n                    int v = find_set(j);\n                    if(u!=v)\n                    {\n                        groups--;\n                        union_set(u,v);\n                    }\n                }\n            }            \n        }\n        \n        return stones.size()-groups;\n        \n    }\n};class Solution {\npublic:\n    vector<int> parent= vector<int>(26);\n    vector<int> sz = vector<int>(26);\n    void make_set(int v)\n    {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n    int find_set(int v)\n    {\n        if(v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n    void union_set(int a, int b)\n    {\n        a = find_set(a);\n        b = find_set(b);\n        if(a != b)\n        {\n            if(sz[a] < sz[b])\n                swap(a,b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        } \n    }\n    bool equationsPossible(vector<string>& equations) {\n        for(int i = 0; i<26; i++)\n            make_set(i);\n        for(auto eqn: equations)\n        {\n            int x = eqn[0]-'a';\n            int y = eqn[3]-'a';\n            if(eqn[1] == '=')\n                union_set(x,y);\n        }\n        for(auto eqn: equations)\n        {\n            int x = find_set(eqn[0]-'a');\n            int y = find_set(eqn[3]-'a');\n            if(eqn[1] == '!')\n                if(x==y) return false;;\n        }\n        return true;\n    }\n};class Solution {\npublic:\n    bool dfs(int s,vector<int> & visited,vector<vector<int>>& adjList)\n    {\n        visited[s] = 1;\n        for(int u: adjList[s])\n        {\n            if(visited[u]==1) return true;\n            if(visited[u]==0 && dfs(u,visited,adjList))\n                return true;\n        }\n        visited[s]=2;\n        return false;\n        \n    }\n     \n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> adjList(numCourses);\n        for(auto pre : prerequisites)\n                 adjList[pre[0]].push_back(pre[1]);\n        vector<int> visited(numCourses, 0);\n        for(int i = 0; i<numCourses; i++)\n        {\n            if(visited[i] == 0 && dfs(i,visited,adjList))\n                return false; //cycle contains --> true so can finish -> false\n        } \n    return true;     \n        \n    }\n};class Solution {\npublic:\n    void dfs_helper(unordered_map<int,vector<int>> &mp, int src, vector<bool>& visited)\n    {\n        visited[src]=true;\n        for(auto child: mp[src])\n        {\n            if(!visited[child]) dfs_helper(mp,child,visited);\n        }\n    }\n    int dfs(unordered_map<int,vector<int>> &mp, int n)\n    {\n        vector<bool> visited(n,false);\n         int component = 0;\n        for(int i = 0; i< n; i++)\n        {\n           if(!visited[i]) \n           {\n                dfs_helper(mp,i,visited);\n                component++;\n            }\n        }\n        return component;\n    }\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        //1. convert the adjacency matrix to adjacency list\n        //2. then implement dfs helper method using start node and then explore children\n        //3. run for loop and inside dfs_helper\n        unordered_map<int, vector<int>> mp;\n        int vertices = isConnected.size();\n        for(int i = 0; i< isConnected.size(); i++){\n            for(int j = 0; j< isConnected.size(); j++)\n            {\n                if(isConnected[i][j]) mp[i].push_back(j);\n            }\n        }\n        return dfs(mp, vertices);\n        \n    }\n};class Solution {\npublic:\n    void dfs(vector<vector<char>>& grid, int i, int j)\n    {\n        if(i<0 || i>= grid.size() || j<0 || j>= grid[0].size() || grid[i][j] == '0')\n            return;\n        grid[i][j] = '0';\n        dfs(grid, i-1,j);\n        dfs(grid,i+1,j);\n        dfs(grid, i, j-1);\n        dfs(grid, i, j+1);\n            \n    }\n    \n    int numIslands(vector<vector<char>>& grid) \n    {\n        int count = 0; \n        for(int i = 0; i< grid.size(); i++)\n        {\n            for(int j = 0; j< grid[0].size(); j++)\n            {\n                if(grid[i][j] =='1')\n                {\n                    dfs(grid, i, j);   \n                    count++;\n                }\n            }\n        }\n        return count;\n        \n    }\n};class Solution {\npublic:\n    struct elem {\n        int row;\n        int col;\n        int depth;\n    };\n    vector<int> row_index = {0,0,-1,1};\n    vector<int> col_index = {1,-1,0,0};\n    int orangesRotting(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = grid[0].size();\n        queue<elem> q;\n        for(int i = 0; i<grid.size() ; i++)\n        {\n            for(int j=0; j<grid[0].size(); j++)\n            {\n                if(grid[i][j] == 2)\n                    q.push({i,j,0});\n            }\n        }\n        int ans = 0;\n        while(!q.empty())\n        {\n            elem x = q.front();\n            q.pop();\n            int row = x.row;\n            int col = x.col;\n            int depth = x.depth;\n            ans = max(ans,depth);\n            for(int i =0; i<4; i++)\n            {\n                int new_row = row+row_index[i];\n                int new_col = col+col_index[i];\n                if(new_row >= 0 && new_row<r && new_col>=0 && new_col<c && grid[new_row][new_col] == 1)\n                {\n                    grid[new_row][new_col] = 2;\n                    q.push({new_row,new_col,depth+1});\n                }\n            }\n        }\n         for(int i = 0; i< grid.size(); i++)\n         {\n            for(int j = 0; j< grid[0].size(); j++)\n            {\n                if(grid[i][j] == 1) \n                    return  -1;\n             }\n         }\n        return ans;\n    }\n};#include<iostream>\n#include<vector>\n#include <queue>\n#include<algorithm>\nusing namespace std;\nconst int INF = 1000000000;\n\nvoid bellman_ford(vector<vector<int>> &graph, int src,int nodes)\n{\n    vector<int> dist(nodes, INF);\n    dist[src] = 0;\n    for(int i = 0; i<nodes-1; i++)\n    {\n        for (auto it : graph)\n        {\n           int u = it[0]; \n           int v = it[1];\n           int w = it[2];\n           dist[v] = min(dist[v], w+dist[u]);\n         }\n     }\n    cout<<\"bellman ford single source shortest path \"<<endl;\n        for(auto i : dist)\n        {\n           cout<<i<<\" \";\n        }\n}\nint main()\n{\n    //Enter the no od nodes and edges \n    int node, edge,src;\n    cin>>node>>edge;\n    vector<vector<int>> graph;\n    for(int i = 0; i< edge; i++)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        graph.push_back({u,v,w});\n    }\n    cin>>src;\n    bellman_ford(graph,src,node);\n    return 0;\n}\nclass Solution {\npublic:\n    \n    bool bipartitehelper(vector<vector<int>> &adj, int startnode,vector<int> &color)\n    {\n        queue<int> q;\n\n        q.push(startnode);\n        color[startnode]=1;\n        while(!q.empty())\n        {\n            int curr = q.front();\n            q.pop();\n            for(auto e : adj[curr])\n            {\n                    //check color\n                    //visit other nodes and assign color and add to queue\n                if(color[e] == color[curr])\n                    return false;\n                if(color[e] == -1) //-1 for unvisited\n                {\n                    color[e]= 1-color[curr]; //1 or 0\n                    q.push(e);\n                }\n            }\n        }\n        \n        return true;\n        \n    }\n    \n    bool isBipartite(vector<vector<int>>& graph) {\n        vector<int> color(graph.size(), -1);\n        for(int i = 0; i<graph.size(); i++) //multicomponent\n        {\n              if(color[i] == -1 && !bipartitehelper(graph, i, color)) return false;\n        }\n        return true;      \n    }\n};//DFS solution\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    unordered_map<Node*, Node*> mp;\n    Node* cloneGraph(Node* node) {\n        if(!node) return NULL;\n        if(mp.find(node) == mp.end())\n        {\n            mp[node] = new Node(node->val, {});\n            for(Node* neighbor: node->neighbors)\n            {\n                mp[node] -> neighbors.push_back(cloneGraph(neighbor));\n            }\n        }\n        return mp[node];\n        \n    }\n};\n\n\n//BFS solution\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    unordered_map<Node*, Node*> mp;\n    Node* cloneGraph(Node* node) {\n        if(!node) return NULL;\n        Node* copy = new Node(node->val, {});\n        mp[node] = copy;\n        queue<Node*> q;\n        q.push(node);\n        while(!q.empty())\n        {\n            Node* cur = q.front();\n            q.pop();\n            for(Node* neighbor : cur-> neighbors)\n            {\n                if(mp.find(neighbor) == mp.end())\n                {\n                    mp[neighbor] = new Node(neighbor->val, {});\n                    q.push(neighbor);\n                }\n                mp[cur]-> neighbors.push_back(mp[neighbor]);\n            }\n        }\n        return copy;\n    }\n};#include<iostream>\n#include<vector>\n#include <queue>\nusing namespace std;\nconst int INF = 1000000000;\nvector<vector<int>> graph[1000];\nvoid dijkstra(int src,int nodes)\n{\n    priority_queue< pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>> > pq;\n    vector<int> dist(nodes, INF);\n    dist[src] = 0;\n    pq.push(make_pair(0, src));\n    while (!pq.empty())\n    {\n        int u = pq.top().second;\n        pq.pop();      \n\n        for (auto it : graph[u])\n        {\n           int v = it[0];\n           int weight = it[1];\n            if (dist[v] > dist[u]+weight)\n                {\n                    dist[v] = dist[u]+weight;\n                    pq.push(make_pair(dist[v], v));\n                }\n         }\n     }\n    cout<<\"Djkstra single source shortest path \"<<endl;\n        for(int i=1;i<=nodes;i++)\n        {\n            if(dist[i] <INF)\n              cout<<dist[i]<<\" \";\n            else cout<<-1<<\" \";\n        cout<<endl;\n        }\n}\nint main()\n{\n    //Enter the no od nodes and edges \n    int node, edge,src;\n    cin>>node>>edge;\n    // vector<vector<int>> graph[edge];\n    for(int i = 0; i< edge; i++)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        graph[u].push_back({v,w});\n        graph[v].push_back({u,w});\n    }\n    cin>>src;\n    dijkstra(src,node);\n    return 0;\n}\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int N = 1e5+6;\nvector<int> parent(N);\nvector<int> sz(N);\nvoid make_set(int v)\n{\n    parent[v] = v;\n    sz[v] = 1;\n}\nint find_set(int v)\n{\n    if(v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\nvoid union_set(int a, int b)\n{\n    a = find_set(a);\n    b = find_set(b);\n    if(a != b)\n    {\n        if(sz[a] < sz[b])\n            swap(a,b);\n        parent[b] = a;\n        sz[a] += sz[b];\n    } \n}\nint main()\n{\n    bool cycle;\n    for(int i = 0; i< N; i++)\n        make_set(i);\n    int n, m; cin>>n>>m;\n    vector<vector<int>> edges;\n    for(int i = 0; i<m; i++)\n    {\n        int u,v; cin>>u>>v;\n        edges.push_back({u,v});\n    }\n    for(auto i: edges)\n    {\n        int u = i[0];\n        int v = i[1];\n        int x = find_set(u);\n        int y = find_set(v);\n        if(x==y)\n            cycle = true;\n        else \n            union_set(u,v);\n    }\n    if(cycle) cout<<\"cycle is found \";\n    else cout<<\"cycle not found\"<<endl;\n    return 0;\n}using namespace std;\n#include<iostream>\n#include<vector>\n#include<stack>\n#define pb push_back\n#include<unordered_map>\nunordered_map<int, vector<int>> adj,rev;\nvoid DFS1(int i,vector<bool> &visited, stack<int>& st){\n    visited[i] = true;\n    for(auto j: adj[i])\n        if(!visited[j]) DFS1(j,visited,st);\n    st.push(i);\n}\nvoid reverse(int nodes){\n    for(int i = 0; i< nodes; i++)\n    {\n        for(int j : adj[i])\n            rev[j].pb(i);\n    }   \n}\nvoid DFS2(int i, vector<bool> &visited)\n{\n    cout<<i<<\" \";\n    visited[i] = true;\n    for(int j : rev[i])\n        if(!visited[j]) DFS2(j,visited);\n}\nvoid findSCC(int nodes){\n    stack<int> st;\n    vector<bool> visited(nodes,false);\n    for(int i = 0; i<nodes; i++)\n        if(!visited[i]) DFS1(i,visited,st);\n    reverse(nodes);\n    for(int i = 0; i<nodes; i++)\n        visited[i] = false;\n    cout<<\"Strongly components are \"<<endl;\n    while(!st.empty()){\n        int curr = st.top();\n        st.pop();\n        if(!visited[curr])\n        {\n            DFS2(curr,visited);\n            cout<<endl;\n        }\n    }    \n}\nint main(){\n    int node, edge;\n    cin>>node>>edge;\n    // vector<vector<int>> graph[edge];\n    for(int i = 0; i< edge; i++)\n    {\n        int u,v;\n        cin>>u>>v;\n        adj[u].pb(v);\n    }\n    findSCC(node);\n    return 0;\n}#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N = 1e5+6;\nvector<int> parent(N);\nvector<int> sz(N);\nvoid make_set(int v)\n{\n    parent[v] = v;\n    sz[v] = 1;\n}\nint find_set(int v)\n{\n    if(v == parent[v])\n        return v;\n    return parent[v] = find_set(parent[v]);\n}\nvoid union_set(int a, int b)\n{\n    a = find_set(a);\n    b = find_set(b);\n    if(a != b)\n    {\n        if(sz[a] < sz[b])\n            swap(a,b);\n        parent[b] = a;\n        sz[a] += sz[b];\n    } \n}\nint main()\n{\n    bool cycle;\n    for(int i = 0; i< N; i++)\n        make_set(i);\n    int n, m; cin>>n>>m;\n    vector<vector<int>> edges;\n    for(int i = 0; i<m; i++)\n    {\n        int u,v,w; cin>>u>>v>>w;\n        edges.push_back({w,u,v});\n    }\n    sort(edges.begin(), edges.end());\n    int cost = 0;\n    for(auto i: edges)\n    {\n        int w = i[0];\n        int u = i[1];\n        int v = i[2];\n        int x = find_set(u);\n        int y = find_set(v);\n        if(x==y)\n            continue;\n        else {\n            cout<<u<<\" \"<<v<<endl;\n            cost += w;\n            union_set(u,v);\n        }\n    }\n    if(cycle) cout<<\"cycle is found \";\n    else cout<<\"cycle not found\"<<endl;\n    return 0;\n}#include<iostream>\n#include<vector>\n#include <queue>\nusing namespace std;\nconst int INF = 1000000000;\nvector<vector<int>> graph[1000];\nvoid prims(int nodes){\n     priority_queue< pair<int,int>, vector <pair<int,int>> , greater<pair<int,int>> > pq;\n     int src = 0; // Taking vertex 0 as source\n     int cost = 0;\n     vector<int> dist(nodes, INF);\n      vector<int> parent(nodes, -1);\n       vector<bool> visited(nodes, false);\n        pq.push(make_pair(0, src));\n        dist[src] = 0;\n        while (!pq.empty())\n        {\n           int u = pq.top().second;\n            pq.pop();      \n           visited[u] = true;  \n\n            for (auto it : graph[u])\n            {\n\n                int v = it[0];\n                int weight = it[1];\n                cout<<u<<\"-->\"<<v<<\": weight \"<<weight<<endl;\n                cost+= weight;\n                if (visited[v] == false && dist[v] > weight)\n                {\n                    dist[v] = weight;\n                    pq.push(make_pair(dist[v], v));\n                    parent[v] = u;\n                }\n            }\n        }\n        cout<<\"total cost of paths using prim \"<<cost<<endl;\n\n}\nint main()\n{\n    //Enter the no od nodes and edges \n    int node, edge;\n    cin>>node>>edge;\n    // vector<vector<int>> graph[edge];\n    for(int i = 0; i< edge; i++)\n    {\n        int u,v,w;\n        cin>>u>>v>>w;\n        graph[u].push_back({v,w});\n    }\n    prims(node);\n    return 0;\n}\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++)\n        {\n            if(mp.find(target-nums[i]) != mp.end())\n                return {mp[target-nums[i]],i};\n            \n             mp[nums[i]]=i;\n        }\n        return {};\n    }\n};// { Driver Code Starts\n#include <bits/stdc++.h>\nusing namespace std;\n\nstring isSubset(int a1[], int a2[], int n, int m) ;\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n, m;\n        cin >> n >> m;\n        int a1[n], a2[m];\n\n        for (int i = 0; i < n; i++) {\n            cin >> a1[i];\n        }\n        for (int i = 0; i < m; i++) {\n            cin >> a2[i];\n        }\n\n        cout << isSubset(a1, a2, n, m) << endl;\n    }\n    return 0;\n}\n// } Driver Code Ends\n\n\nstring isSubset(int a1[], int a2[], int n, int m) {\n    unordered_map<int,int> mp;\n    for(int i = 0; i<n; i++)\n        mp[a1[i]]++;\n        \n    for(int i = 0; i<m; i++){\n        if(mp.find(a2[i]) == mp.end()) return \"No\";\n    }\n        \n    return \"Yes\";\n}class Solution {\npublic:\n    int nthUglyNumber(int n) {\n        set<long long> s;\n        n--;\n        long long x = 1;\n        while(n--)\n        {\n            s.insert(x*2);\n            s.insert(x*3);\n            s.insert(x*5);\n            x = *(s.begin());\n            s.erase(s.begin());\n        }\n        return (int)x;\n    }\n};#define in pair<int,char>\nclass Solution {\npublic:\n    string frequencySort(string s) {\n        string ans = \"\";\n        unordered_map<char, int> mp;\n        for(char c: s) mp[c]++;\n        priority_queue<in> maxh;\n        for(auto i = mp.begin(); i!= mp.end(); i++)\n        {\n            maxh.push({i->second, i-> first});\n        }\n        while(!maxh.empty())\n        {\n            char c = maxh.top().second;\n            int freq = maxh.top().first;\n            maxh.pop();\n            while(freq--)\n                ans+= c;\n        }\n        return ans;\n    }\n};class Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        //tasks--> A,A,A,B,B\n        unordered_map<char, int> count;\n        for(auto t: tasks)\n            count[t]++;    //count[A] = 3\n                            //count[B] = 2\n        priority_queue<int> pq;\n        for(auto c: count) pq.push(c.second); //pq->3,2\n        int result=0; \n        while(!pq.empty())\n        {\n            vector<int> tmp;\n            int time=0;\n            for(int i=0;i<(n+1);i++)\n            {\n                if(!pq.empty())\n                {\n                    tmp.push_back(pq.top()-1);\n                    pq.pop();\n                    time++;\n                }\n            }\n            for(auto t: tmp)\n                if(t) pq.push(t);\n        result+= pq.empty() ? time : (n+1);\n        }\n        return result;\n     }\n};class Solution {\npublic:\n    vector<int> findClosestElements(vector<int>& arr, int k, int x) {\n        priority_queue<pair<int,int>> maxh;\n        for(auto a : arr)\n        {\n            if(maxh.size()<k)\n            {\n                maxh.push({abs(a-x),a});\n            }\n            else{\n                if(maxh.top().first > abs(a-x))\n                {\n                    maxh.pop();\n                    maxh.push({abs(a-x),a});\n               }\n            }\n        }\n        vector<int> ans;\n        while(!maxh.empty())\n        {\n            ans.push_back(maxh.top().second);\n            maxh.pop();\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};class KthLargest {\npublic:\n    priority_queue<int, vector<int>, greater<int>> minh;\n    int k;\n    KthLargest(int k, vector<int>& nums) {\n        this-> k = k;\n        for(int i = 0; i< nums.size(); i++)\n            minh.push(nums[i]);\n        while(minh.size()>k) minh.pop();\n    }\n    \n    int add(int val) {\n        minh.push(val);\n        while(minh.size()>k) minh.pop();\n        return minh.top();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj->add(val);\n */#include<iostream>\n#include <vector>\nusing namespace std;\n\nclass MaxHeap \n{\npublic:\nvector<int> heap;\nint leftchild(int i)\n{\n    return 2*i+1;\n}\nint rightchild(int i)\n{\n    return 2*i+2;\n}\nint parent(int i){\n    return (i-1)/2;\n}\nvoid heapify_down(int currentIdx) {\n    int leftchildidx = leftchild(currentIdx);\n    int rightchildidx = rightchild(currentIdx);\n    int parentidx = parent(currentIdx);\n    int largest = currentIdx;\n    int size = heap.size();\n    if(leftchildidx< size && heap[leftchildidx]>heap[currentIdx])\n        largest = leftchildidx;\n    if(leftchildidx< size && heap[rightchildidx]>heap[currentIdx])\n        largest = rightchildidx;\n    if(largest != currentIdx){\n        swap(heap[currentIdx], heap[largest]);\n        heapify_down(largest);\n    }\n}\nvoid heapify_up(int currentIdx) {\n    if(currentIdx && heap[parent(currentIdx)]> heap[currentIdx])\n    {\n        swap(heap[currentIdx], heap[parent(currentIdx)]);\n        heapify_up(parent(currentIdx));\n    }\n}\nunsigned int size()\n    {\n        return heap.size();\n    }\n \n    // function to check if heap is empty or not\n    bool empty()\n    {\n        return size() == 0;\n    }\n    \n    // insert key into the heap\n    void push(int key)\n    {\n        // insert the new element to the end of the vector\n        heap.push_back(key);\n \n        // get element index and call heapify-up procedure\n        int index = size() - 1;\n        heapify_up(index);\n    }\n \n    // function to remove element with highest priority (present at root)\n    void pop()\n    {\n        try {\n            // if heap has no elements, throw an exception\n            if (size() == 0)\n                throw out_of_range(\"Vector<X>::at() : \"\n                        \"index is out of range(Heap underflow)\");\n \n            // replace the root of the heap with the last element\n            // of the vector\n            heap[0] = heap.back();\n            heap.pop_back();\n \n            // call heapify-down on root node\n            heapify_down(0);\n        }\n        // catch and print the exception\n        catch (const out_of_range& oor) {\n            cout << \"\\n\" << oor.what();\n        }\n    }\n \n    // function to return element with highest priority (present at root)\n    int top()\n    {\n        try {\n            // if heap has no elements, throw an exception\n            if (size() == 0)\n                throw out_of_range(\"Vector<X>::at() : \"\n                        \"index is out of range(Heap underflow)\");\n \n            // else return the top (first) element\n            return heap.at(0);    // or return A[0];\n        }\n        // catch and print the exception\n        catch (const out_of_range& oor) {\n            cout << \"\\n\" << oor.what();\n        }\n    }\n};\n \n// Max Heap C++ implementation\nint main()\n{\n    MaxHeap pq;\n    \n    // Note - Priority is decided by element's value\n    \n    pq.push(3);\n    pq.push(2);\n    pq.push(15);\n    \n    cout << \"Size is \" << pq.size() << endl;    \n    \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    pq.push(5);\n    pq.push(4);\n    pq.push(45);\n \n    cout << endl << \"Size is \" << pq.size() << endl;\n    \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << endl << std::boolalpha << pq.empty();\n    \n    pq.top();    // top operation on an empty heap\n    pq.pop();    // pop operation on an empty heap\n \n    return 0;\n}\n\n//Output\n// Size is 3\n// 2 15\n// Size is 4\n// 3 45 5 4\n// true\n// Vector<X>::at() : index is out of range(Heap underflow)\n// Vector<X>::at() : index is out of range(Heap underflow)#include<iostream>\n#include <vector>\nusing namespace std;\n\nclass MinHeap \n{\npublic:\nvector<int> heap;\nint leftchild(int i)\n{\n    return 2*i+1;\n}\nint rightchild(int i)\n{\n    return 2*i+2;\n}\nint parent(int i){\n    return (i-1)/2;\n}\nvoid heapify_down(int currentIdx) {\n    int leftchildidx = leftchild(currentIdx);\n    int rightchildidx = rightchild(currentIdx);\n    int parentidx = parent(currentIdx);\n    int smallest = currentIdx;\n    int size = heap.size();\n    if(leftchildidx< size && heap[leftchildidx]<heap[currentIdx])\n        smallest = leftchildidx;\n    if(leftchildidx< size && heap[rightchildidx]<heap[currentIdx])\n        smallest = rightchildidx;\n    if(smallest != currentIdx){\n        swap(heap[currentIdx], heap[smallest]);\n        heapify_down(smallest);\n    }\n}\nvoid heapify_up(int currentIdx) {\n    if(currentIdx && heap[parent(currentIdx)]> heap[currentIdx])\n    {\n        swap(heap[currentIdx], heap[parent(currentIdx)]);\n        heapify_up(parent(currentIdx));\n    }\n}\nunsigned int size()\n    {\n        return heap.size();\n    }\n \n    // function to check if heap is empty or not\n    bool empty()\n    {\n        return size() == 0;\n    }\n    \n    // insert key into the heap\n    void push(int key)\n    {\n        // insert the new element to the end of the vector\n        heap.push_back(key);\n \n        // get element index and call heapify-up procedure\n        int index = size() - 1;\n        heapify_up(index);\n    }\n \n    // function to remove element with highest priority (present at root)\n    void pop()\n    {\n        try {\n            // if heap has no elements, throw an exception\n            if (size() == 0)\n                throw out_of_range(\"Vector<X>::at() : \"\n                        \"index is out of range(Heap underflow)\");\n \n            // replace the root of the heap with the last element\n            // of the vector\n            heap[0] = heap.back();\n            heap.pop_back();\n \n            // call heapify-down on root node\n            heapify_down(0);\n        }\n        // catch and print the exception\n        catch (const out_of_range& oor) {\n            cout << \"\\n\" << oor.what();\n        }\n    }\n \n    // function to return element with highest priority (present at root)\n    int top()\n    {\n        try {\n            // if heap has no elements, throw an exception\n            if (size() == 0)\n                throw out_of_range(\"Vector<X>::at() : \"\n                        \"index is out of range(Heap underflow)\");\n \n            // else return the top (first) element\n            return heap.at(0);    // or return A[0];\n        }\n        // catch and print the exception\n        catch (const out_of_range& oor) {\n            cout << \"\\n\" << oor.what();\n        }\n    }\n};\n \n// Max Heap C++ implementation\nint main()\n{\n    MinHeap pq;\n    \n    // Note - Priority is decided by element's value\n    \n    pq.push(3);\n    pq.push(2);\n    pq.push(15);\n    \n    cout << \"Size is \" << pq.size() << endl;    \n    \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    pq.push(5);\n    pq.push(4);\n    pq.push(45);\n \n    cout << endl << \"Size is \" << pq.size() << endl;\n    \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << pq.top() << \" \";\n    pq.pop();\n \n    cout << endl << std::boolalpha << pq.empty();\n    \n    pq.top();    // top operation on an empty heap\n    pq.pop();    // pop operation on an empty heap\n \n    return 0;\n}\n\n\n// Size is 3\n// 2 3\n// Size is 4\n// 4 5 15 45\n// true\n// Vector<X>::at() : index is out of range(Heap underflow)\n// Vector<X>::at() : index is out of range(Heap underflow)\tusing namespace std;\n    #include<vector>\n    #include<iostream>\n    \n    void siftDown(vector<int>& nums, int n, int i){\n        int biggest = i;\n        int l = 2 * i + 1;\n        int r = 2 * i + 2;\n        if(l < n && nums[biggest] < nums[l])\n            biggest = l;\n        if(r < n && nums[biggest] < nums[r])\n            biggest = r;\n        if(biggest != i){\n            swap(nums[i], nums[biggest]);\n            siftDown(nums, n, biggest);\n        }\n    }\n    \n\t// heapSort(nums);\n    void heapSort(vector<int>& nums){\n        // heapify stage (bottom up approach)\n        for(int i = nums.size() / 2 - 1; i >= 0; i--)\n            siftDown(nums, nums.size(), i);\n        // sorting stage\n        for(int i = nums.size() - 1; i > 0; i--){\n            swap(nums[0], nums[i]);\n            siftDown(nums, i, 0);\n        }\n    }\n\n    int main(){\n        vector<int> a = {5,9,0,12,87,3,2,99,56,3};\n        heapSort(a);\n        for(int i = 0; i<a.size(); i++)\n            cout<<a[i]<<\" \";\n        return 0;\n    }/*\nProblem Description\n\nGiven an 2D integer array A of size N x 2 denoting time intervals of different meetings.\n\nWhere:\n\nA[i][0] = start time of the ith meeting.\nA[i][1] = end time of the ith meeting.\nFind the minimum number of conference rooms required so that all meetings can be done.\n\n*/\nbool compare (vector<int> a,vector<int> b)\n{\n    return a[0]<b[0];\n}\nint Solution::solve(vector<vector<int> > &A)\n{\n    sort(A.begin(),A.end(),compare); //sort according to starting time\n    priority_queue<int,vector<int>,greater<int>> pq; //min heap\n    pq.push(A[0][1]);  //insert ending time in minheap\n    for(int i=1;i<A.size();i++)\n    {\n        int top = pq.top();\n        if(A[i][0]>=top){\n            pq.pop();\n        }\n        pq.push(A[i][1]);\n    }\n    return pq.size();\n}\n#define in pair<int,int>\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int,int> mp;\n        vector<int> result;\n        for(int i = 0; i< nums.size(); i++)\n            mp[nums[i]]++;\n        priority_queue<in,vector<in>,greater<in>> minh;\n        for(auto i = mp.begin(); i!= mp.end(); i++)\n        {\n            minh.push({i->second, i->first});\n            if(minh.size() > k)\n                minh.pop();\n        }\n        while(!minh.empty())\n        {\n            result.push_back(minh.top().second);\n            minh.pop();\n        }\n        return result;\n    }\n};/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next)\n            return head;\n        ListNode* nextnode = head->next;\n        head->next = swapPairs(nextnode->next);\n        nextnode->next = head;\n        return nextnode;\n        \n    }\n};\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int length(ListNode * head)\n    {\n        int count = 0;\n        ListNode* temp = head;\n        while(temp){\n            temp = temp->next;\n            count++;\n        }\n        return count;\n    }\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(length(head) < k) return head;\n        ListNode* prev = NULL;\n        ListNode* curr = head;\n        ListNode* next = NULL;\n        for(int i = 0; i<k; i++)\n        {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        head->next = reverseKGroup(curr, k);\n        return prev;\n        \n    }\n};/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(!head || k<0)\n            return NULL;\n        ListNode* lastnode = head;\n        int length = 1;\n        while(lastnode->next){\n            lastnode = lastnode->next;\n            length++;\n        }\n        lastnode->next = head;\n        k = k %length; // if k>length\n        int skiplength = length-k;\n        ListNode* lastnodePrev = head;\n        for(int i = 0; i<skiplength-1; i++){\n            lastnodePrev = lastnodePrev->next;\n        }\n        head = lastnodePrev->next;\n        lastnodePrev->next = nullptr;\n        return head;\n    }\n};/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int m, int n) {\n        ListNode* current = head, *prev = nullptr;\n        // after skipping m-1 nodes current will pe pointing to mth node\n        for(int i = 0; current && i<m-1; i++)\n        {\n            prev = current;\n            current = current->next;\n        }\n        ListNode* lastnodeoffirstpart = prev; // points to the node at index m-1\n        ListNode* next = nullptr;\n        ListNode* lastnodeofsublist = current; // after reversing current will be the last node of sublist\n        for(int i = 0; current && i<n-m+1; i++)\n        {\n            next = current->next;\n            current->next = prev;\n            prev = current;\n            current = next;\n        }\n        //connect with the first part\n        if(lastnodeoffirstpart) lastnodeoffirstpart->next = prev;\n        else head = prev;\n        \n        //connect with last part\n        \n        lastnodeofsublist->next = current;\n        return head;\n    }\n};#include<iostream>\nusing namespace std;\n\nclass node{\n    public:\n        int val;\n        node* next;\n        node(int data){\n            val = data;\n            next = NULL;\n        }\n};\nvoid insertAtHead(node* &head,int val)\n{\n    node* n = new node(val);\n    n->next = head;\n    head = n;\n}\nvoid insert_at_tail(node* &head, int val)\n{\n    node* n = new node(val);\n    if(!head){\n        head = n;\n        return;\n    }\n    node *temp = head;\n    while(temp->next)\n        temp = temp->next;\n    temp->next = n;\n}\nvoid deleteAtHead(node* &head)\n{\n    node* todelete = head;\n    head = head->next;\n    delete todelete;   \n}\nvoid deletion(node* &head, int val)\n{\n    if(!head) return;\n    if(!head->next) deleteAtHead(head);\n    node* temp = head;\n    while(temp->next->val != val)\n    {\n        temp = temp->next;\n    }\n    node* todelete = temp->next;\n    temp->next = temp->next->next;\n    delete todelete;\n}\nnode* reverse(node* &head)\n{\n    node* prevptr = NULL;\n    node* currptr = head;\n    node* nextptr;\n    while(currptr)\n    {\n        nextptr = currptr -> next;\n        currptr -> next = prevptr;\n        prevptr = currptr;\n        currptr = nextptr;\n    }\n    return prevptr;\n}\nnode* recursive_reverse(node* &head)\n{\n    if(!head || !head->next) return head;\n    node* newhead = recursive_reverse(head->next);\n    head ->next ->next = head;\n    head->next = NULL;\n    return newhead;\n}\n//reverse k nodes\nnode* reverseknodes(node* &head, int k)\n{\n    node* prevptr = NULL;\n    node* currptr = head;\n    node* nextptr;\n    int count = 0;\n    while(currptr && count<k)\n    {\n        nextptr = currptr->next;\n        currptr->next = prevptr;\n        prevptr = currptr;\n        currptr = nextptr;\n        count++;\n    }\n    if(nextptr)\n    {\n        head->next = reverseknodes(nextptr,k);\n    }\n    return prevptr;\n}\nvoid makeCycle(node* &head, int pos)\n{\n    node* temp = head;\n    node* startnode;\n    int count = 1;\n    while(temp->next != NULL)\n    {\n        if(count == pos) startnode = temp;\n        temp = temp->next;\n        count++;\n    }\n    temp->next = startnode;\n}\n\nbool detectCycle(node* &head)\n{\n    node* slow = head;\n    node* fast = head;\n    while(fast && fast->next)\n    {\n        slow = slow-> next;\n        fast = fast->next->next;\n        if(fast == slow) return true;\n    }\n    return false;\n}\n\nvoid removeCycle(node* &head)\n{\n    node* slow = head;\n    node* fast = head;\n    do{\n        slow = slow->next;\n        fast = fast ->next->next;\n    }while(slow!= fast);\n    fast = head;\n    while(slow ->next != fast->next)\n    {\n        slow = slow->next;\n        fast = fast->next;\n    }\n    slow->next = NULL;\n}\n//find intersection point\nvoid makeintersection(node* &head1, node* &head2, int pos)\n{\n    node* temp1 = head1;\n    pos--;\n    while(pos--) temp1 = temp1->next;\n    node* temp2 = head2;\n    while(temp2->next) temp2 = temp2->next;\n    temp2->next = temp1;\n}\nint length(node* head)\n{\n    int l = 0;\n    while(head){\n        head = head->next;\n        l++;\n    }\n    return l;\n}\nnode* intersection(node* &head1, node* &head2)\n{\n int l1 = length(head1);\n    int l2 = length(head2);\n    int d = abs(l1-l2);\n    node* ptr1;\n    node* ptr2;\n    ptr1 = (l1>l2)? head1: head2;\n    ptr2 = (l1>l2)? head2: head1;\n    while(d)\n    {\n        ptr1 = ptr1->next;\n       if(ptr1==NULL) return NULL;\n        d--;\n    }\n    while(ptr1 && ptr2)\n    {\n        if(ptr1 == ptr2) return ptr1;\n        ptr1 = ptr1->next;\n        ptr2 = ptr2->next;\n    }\n    return NULL;\n}\nvoid display(node* head)\n{\n    node* temp = head;\n    while(temp)\n    {\n        cout<< temp->val << \"->\";\n        temp = temp->next;\n    }\n    cout<<\"NULL\"<<endl;\n}\nint main()\n{\n    node* head = NULL;\n    insert_at_tail(head,1);\n    insert_at_tail(head,2);\n    insert_at_tail(head,3);\n    insert_at_tail(head,4);\n    insert_at_tail(head,5);\n    insert_at_tail(head,6);\n    makeCycle(head,3);\n    //\n    cout<<detectCycle(head)<<endl;\n    removeCycle(head);\n    display(head); \n    // node* reversednode = reverseknodes(head,2); \n    // display(reversednode);\n    return 0;\n}\n\n/*\n * Complete the 'reverse' function below.\n *\n * The function is expected to return an INTEGER_SINGLY_LINKED_LIST.\n * The function accepts INTEGER_SINGLY_LINKED_LIST llist as parameter.\n */\n\n/*\n * For your reference:\n *\n * SinglyLinkedListNode {\n *     int data;\n *     SinglyLinkedListNode* next;\n * };\n *\n */\n\nSinglyLinkedListNode* reverse(SinglyLinkedListNode* llist) {\n    if( !llist) return nullptr;\n    SinglyLinkedListNode* previous = nullptr;\n    SinglyLinkedListNode* current  = llist;\n    SinglyLinkedListNode* next = nullptr;\n    while(current)\n    {\n        next = current->next;\n        current->next = previous;\n        previous = current;\n        current = next;\n    }\n    return previous;\n}\n\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if (n==0 || n==1) return 0;\n        vector<bool> prime(n, true);\n        prime[0] = false, prime[1] = false;\n        for(int i = 0; i< sqrt(n); i++){\n            if(prime[i])\n            {\n                for(int j = i*i; j<n; j+=i)\n                {\n                    prime[j] = false;\n                }\n            }\n        }\n        return count(prime.begin(), prime.end(), true);        \n    }\n};class Solution {\npublic:\n    string addBinary(string a, string b) {\n         int n = a.size(), m = b.size();\n        string sum;\n        int carry = 0;\n        \n        int i = n - 1, j = m - 1;\n        while (i >= 0 || j >= 0 || carry > 0){\n            if (i >= 0) {\n                carry += a[i] - '0';\n                i -= 1;\n            }\n            if (j >= 0) {\n                carry += b[j] - '0';\n                j -= 1;\n            }\n            sum += (carry % 2) + '0';\n            carry /= 2;\n        }\n        reverse(sum.begin(), sum.end());\n        return sum;\n        \n    }\n};class Solution {\npublic:\n    int reverse(int x) {\n        long long res = 0;\n        while(x)\n        {\n            res = res*10+(x%10);\n            x = x/10;\n        }\n        return (res<INT_MIN || res>INT_MAX) ? 0 : res;\n    }\n};class Solution {\npublic:\n    bool isPalindrome(int x) {\n        if(x<0|| (x!=0 &&x%10==0)) return false;\n        int sum=0;\n        while(x>sum)\n        {\n            sum = sum*10+x%10;\n            x = x/10;\n        }\n        return (x==sum)||(x==sum/10);\n    }\n};#include<iostream>\nusing namespace std;\n#define int long long\nconst int N = 1e5+2, MOD = 1e9+7;\n// ax+by = gcd(a,b)\nstruct triplet{\n    int x,y,gcd;\n};\n\ntriplet extended_euclid(int a, int b)\n{\n    if(b == 0)\n    {\n        triplet ans;\n        ans.x = 1;\n        ans.gcd = 1;\n        ans.y = 0;\n        return ans;\n    }\n    triplet smallAns = extended_euclid(b,a%b);\n    triplet ans;\n    ans.gcd = smallAns.gcd;\n    ans.x = smallAns.y;\n    ans.y = smallAns.x - (a/b)*smallAns.y;\n    return ans;\n}\n\nsigned main(){\n    int a,b;\n    cin>>a>>b;\n    triplet ans = extended_euclid(a,b);\n    cout<<ans.gcd <<\" \"<<ans.x<<\" \"<<ans.y<<endl;\n    return 0;\n}class Solution {\npublic:\n    int rotate(vector<int>& arr) {\n        int start = 0;\n        int end = arr.size()-1;\n        while(start < end)\n        {\n            int mid = start + (end- start)/2;\n            if(start<mid  && arr[mid-1]>arr[mid])\n                return arr[mid];\n            if(mid < end && arr[mid] > arr[mid+1])\n                return arr[mid+1];\n            if(arr[start]<arr[mid])\n                start = mid+1;\n            else \n                end = mid-1;\n        }\n        return -1; // the array is not rotated\n    }\n    \n     int findMin(vector<int>& arr) {\n         if(arr.size()==1) return arr[0];\n         int r = rotate(arr);\n         if(r == -1) {\n             if(arr[0] < arr[arr.size()-1]) return arr[0];\n             if(arr[0] > arr[arr.size()-1]) return arr[arr.size()-1];\n         }\n         else\n              return r;\n         return r;\n     }\n};class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n        if (nums.size()==1){\n            return 0;\n        }\n        int start = 0;\n        int end = nums.size()-1;\n        while(start <= end)\n        {\n            int mid = start + (end-start)/2;\n            if(mid>0 && mid<nums.size()-1)\n            {\n                if(nums[mid]> nums[mid-1] && nums[mid] > nums[mid+1])\n                    return mid;\n                else if(nums[mid-1] < nums[mid])\n                    start = mid+1;\n                else  end = mid-1;\n            }\n            else if(mid == 0) \n                return (nums[0]>nums[1]) ? 0: 1;\n            else if(mid == nums.size()-1) \n                return (nums[nums.size()-1]> nums[nums.size()-2]) ? nums.size()-1:nums.size()-2;\n        }\n        return -1;\n    }\n};class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int i = 0;\n        int j = col-1;\n        while(i>= 0 && i<row && j>= 0 && j<col)\n        {\n            if(matrix[i][j] == target)\n                return true;\n            else if(matrix[i][j] < target)\n                i++;\n            else j--;\n        }\n        return false;\n        \n    }\n};class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int start = 0; \n        int end = nums.size()-1;\n        while(start <= end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid] == target) return mid;\n            if(nums[start] <= nums[mid])\n            {\n                if(target >= nums[start] && target < nums[mid])\n                    end = mid -1;\n                else\n                   start = mid+1; \n            }\n           else\n            {\n                if(target > nums[mid] && target <= nums[end])\n                    start = mid +1;\n                else\n                   end = mid - 1; \n            }\n        \n        }    \n        return -1;\n    }\n};class Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int firstoccur = -1;\n        int lastoccur = -1;\n        vector<int> res;\n        int start = 0;\n        int end = nums.size()-1;\n        while(start <= end)\n        {\n            int mid = start +(end - start)/2;\n            if(nums[mid] == target)\n            {\n                firstoccur = mid;\n                end = mid-1;\n            }\n            else if(nums[mid] > target) end = mid-1;\n            else start = mid+1;\n        }\n        res.push_back(firstoccur);\n        start = 0;\n         end = nums.size()-1;\n        while(start <= end)\n        {\n            int mid = start +(end - start)/2;\n            if(nums[mid] == target)\n            {\n                lastoccur = mid;\n                start = mid+1;\n            }\n            else if(nums[mid] > target) end = mid-1;\n            else start = mid+1;\n        }\n        res.push_back(lastoccur);\n        return res;\n    }\n};class Solution {\npublic:\n    char nextGreatestLetter(vector<char>& letters, char target) {\n        int l = 0;\n        int h = letters.size()-1;\n        while(l<= h)\n        {\n            int mid = l + (h-l)/2;\n            if(letters[mid] > target){\n                h = mid-1;\n            }\n            else \n                l = mid+1;                \n        }\n        return letters[l % letters.size()];\n    }\n};class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int row = matrix.size();\n        int col = matrix[0].size();\n        int i = 0;\n        int j = col-1;\n        while(i>= 0 && i<row && j>= 0 && j<col)\n        {\n            if(matrix[i][j] == target)\n                return true;\n            else if(matrix[i][j] < target)\n                i++;\n            else j--;\n        }\n        return false;\n        \n    }\n};/*\nGiven an array of integers A of size N and an integer B.\n\nCollege library has N bags,the ith book has A[i] number of pages.\n\nYou have to allocate books to B number of students so that maximum number of pages alloted to a student is minimum.\n\nA book will be allocated to exactly one student.\nEach student has to be allocated at least one book.\nAllotment should be in contiguous order, for example: A student cannot be allocated book 1 and book 3, skipping book 2.\nCalculate and return that minimum possible number.\n\nNOTE: Return -1 if a valid assignment is not possible.\n\n\nInput 1:\n    A = [12, 34, 67, 90]\n    B = 2\nOutput 1:\n    113\nExplanation 1:\n    There are 2 number of students. Books can be distributed in following fashion : \n        1) [12] and [34, 67, 90]\n        Max number of pages is allocated to student 2 with 34 + 67 + 90 = 191 pages\n        2) [12, 34] and [67, 90]\n        Max number of pages is allocated to student 2 with 67 + 90 = 157 pages \n        3) [12, 34, 67] and [90]\n        Max number of pages is allocated to student 1 with 12 + 34 + 67 = 113 pages\n\n        Of the 3 cases, Option 3 has the minimum pages = 113.\n\nInput 2:\n    A = [5, 17, 100, 11]\n    B = 4\nOutput 2:\n    100\n*/\n\n#include<numeric>\nbool isValid(vector<int> v, int k, int mx) \n{ \n    int studentsRequired = 1; \n    int curr_sum = 0; \n  \n    int stu = 1;\n    int sum = 0;\n    for(int i =0;i<v.size();i++)\n    {\n        sum = sum + v[i];\n        if(sum > mx)\n        {\n            stu++;\n            sum = v[i];\n        }\n        if(stu>k) return false;\n    }\n    return true;\n}\nint Solution::books(vector<int> &arr, int m)\n{\n    int n = arr.size();\n    if (n < m) \n        return -1; \n    int low = *max_element(arr.begin(), arr.end()) ;\n    int  high = accumulate(arr.begin(), arr.end(),0); \n    int result = -1; \n     while (low <= high) \n    { \n        int mid = low+(high-low)/2;\n        if (isValid(arr,m, mid)) \n        { \n            \n            result =mid; \n            high = mid - 1; \n        } \n  \n        else\n            low = mid + 1; \n    } \n    return result; \n}\nusing namespace std;\n#include<iostream>\n#include<vector>\nint ceilOfArray(vector<int> &A, int B) {\n  \n    int l = 0;\n    int h = A.size()-1;\n    while(l<= h)\n    {\n        int mid = l+(h-l)/2;\n        if(A[mid] == B) return mid;\n        else if(A[mid]<B) l = mid+1;\n        else h = mid-1;\n    }\n    return l;\n}\nint floorOfArray(vector<int> &A, int B) {\n  \n    int l = 0;\n    int h = A.size()-1;\n    while(l<= h)\n    {\n        int mid = l+(h-l)/2;\n        if(A[mid] == B) return mid;\n        else if(A[mid]<B) l = mid+1;\n        else h = mid-1;\n    }\n    return h;\n}\nint main(){\n    vector<int> arr = {2,6,9,14,33};\n    cout<<\"Ceil of the array(index) \"<<ceilOfArray(arr,5)<<endl;\n    cout<<\"floor of the array(index) \"<<floorOfArray(arr,5)<<endl;;\n    return 0;\n}\n/*\nImplement pow(x, n) % d.\n\nIn other words, given x, n and d,\n\nfind (xn % d)\n\nNote that remainders on division cannot be negative.\nIn other words, make sure the answer you return is non negative.\n\n*/\n\nint Solution::pow(int x, int y, int d) {\n   \n    int res;\n    if(y == 0) \n        return 1; \n    else if(y % 2 == 0) {\n        res = pow(x, y / 2,d) * pow(x, y / 2,d); \n        return (res%d);\n    }\n    else\n        res =  x * pow(x, y / 2,d) * pow(x, y / 2,d);\n        return (res % d);\n}\n/*\nGiven 2 integers A and B and an array of integars C of size N.\n\nElement C[i] represents length of ith board.\n\nYou have to paint all N boards [C0, C1, C2, C3 \u2026 CN-1]. There are A painters available and each of them takes B units of time to paint 1 unit of board.\n\nCalculate and return minimum time required to paint all boards under the constraints that any painter will only paint contiguous sections of board.\n\n2 painters cannot share a board to paint. That is to say, a board\ncannot be painted partially by one painter, and partially by another.\nA painter will only paint contiguous boards. Which means a\nconfiguration where painter 1 paints board 1 and 3 but not 2 is\ninvalid.\nReturn the ans % 10000003\n\n\n\nInput Format\n\nThe first argument given is the integer A.\nThe second argument given is the integer B.\nThe third argument given is the integer array C.\nOutput Format\n\nReturn minimum time required to paint all boards under the constraints that any painter will only paint contiguous sections of board % 10000003.\nConstraints\n\n1 <=A <= 1000\n1 <= B <= 10^6\n1 <= C.size() <= 10^5\n1 <= C[i] <= 10^6\nFor Example\n\nInput 1:\n    A = 2\n    B = 5\n    C = [1, 10]\nOutput 1:\n    50\nExplanation 1:\n    Possibility 1:- same painter paints both blocks, time taken = 55units\n    Possibility 2:- Painter 1 paints block 1, painter 2 paints block 2, time take = max(5, 50) = 50\n    There are no other distinct ways to paint boards.\n    ans = 50%10000003\n\nInput 2:\n    A = 10\n    B = 1\n    C = [1, 8, 11, 3]\nOutput 2:\n    11\n\n\n    */\n   #include<numeric>\nint isValid(vector<int> v, int mx,int k) \n{ \n\n    int stu = 1;\n    int sum = 0;\n    for(int i =0;i<v.size();i++)\n    {\n        sum = sum + v[i];\n        if(sum > mx)\n        {\n            stu++;\n            sum = v[i];\n        }\n    }\n    return stu<=k;\n}\nint Solution::paint(int A, int B, vector<int> &arr) {\n\n    int low = *max_element(arr.begin(), arr.end()) ;\n    int  high = accumulate(arr.begin(), arr.end(),0); \n    long long result = -1; \n     while (low <= high) \n    { \n        int mid = low+(high-low)/2;\n        if(isValid(arr,mid,A))\n        { \n            result =mid; \n            high = mid - 1; \n        } \n  \n        else\n            low = mid + 1; \n    } \n    return (result*B)% 10000003; \n}\n/*\nProblem Description\n\nGiven a sorted array A and a target value B, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou may assume no duplicates in the array.\n\n\n\n**Problem Constraints**\n1 <= |A| <= 100000\n\n1 <= B <= 109\n\n\n\n**Input Format**\nFirst argument is array A.\n\nSecond argument is integer B.\n\n\n\n**Output Format**\nReturn an integer, the answer to the problem.\n\n*/\n\nint Solution::searchInsert(vector<int> &A, int B) {\n  \n    int l = 0;\n    int h = A.size()-1;\n    while(l<= h)\n    {\n        int mid = l+(h-l)/2;\n        if(A[mid] == B) return mid;\n        else if(A[mid]<B) l = mid+1;\n        else h = mid-1;\n    }\n    return l;\n}\nusing namespace std;\n#include<iostream>\n#include<vector>\n#include<string>\nint p = 31;\nconst int N = 1e5+7, mod = 1e9+7;\nvector<long long> power(N);\nint main(){\n\n    string t = \"agniksahannik\";\n    string s = \"nik\";\n    int T = t.size(), S= s.size();\n    power[0] = 1;\n    for(int i = 1; i<N; i++)\n        power[i] = (power[i-1]*p)%mod;\n\n    vector<long long> h(T+1,0);\n    for(int i = 0; i<T;i++)\n        h[i+1] = (h[i]+(t[i]-'a'+1)*power[i])%mod;\n    long long h_s = 0;\n    for(int i = 0; i<S; i++)\n        h_s = (h_s+(s[i]-'a'+1)*power[i])%mod;\n\n    for(int i = 0; i+S-1<T; i++)\n    {\n        long long cur_hash = (h[i+S]-h[i]+mod)%mod;\n        if(cur_hash == (h_s*power[i])%mod)\n            cout<<i<<\" \";\n    }\n    return 0;\n}class Solution {\npublic:\n    //we wil implement this using boyer moore algorithm\n    void fillHashTable(string s,int hashtable[256])\n    {\n        for(int i = 0; i< 256; i++)\n            hashtable[i] = -1;\n        for(int i = 0; i< s.length(); i++)\n            hashtable[(int)s[i]] = i;\n    }\n    int strStr(string haystack, string needle) {\n        int S = needle.length();\n        int T = haystack.length();\n        int i = 0;\n        int hashtable[256];\n        fillHashTable(haystack,hashtable);\n        while( i<= (T-S))  //n-m\n        {\n            int j = S-1;\n            while(j >= 0 && needle[j] == haystack[i+j])\n                j--;\n            if(j<0)\n            {\n                return i;\n                i += (i+S < T) ? S-hashtable[haystack[i+S]]:1;\n            } \n            else\n                i += max(1, j-hashtable[haystack[i+j]]);\n        }\n        return -1;\n    }\n};class Solution {\npublic:\n    void computeLPStable(string pat, int* lps)\n    {\n        int plen = pat.length();\n        int i = 1, len = 0;\n        lps[0] = 0;\n        while(i< plen)\n        {\n            if(pat[i] == pat[len])\n            {\n                len++;\n                lps[i++] = len;\n            }\n            else{\n                if(len) len = lps[len-1];\n                else lps[i++] = 0;\n            }\n        }\n    }\n    int kmp(string  text, string pattern)\n    {\n        int plen = pattern.length();\n        int tlen = text.length();\n        if(plen == 0) return 0;\n         int lps[100000];\n        computeLPStable(pattern, lps);\n        int tindex = 0;\n        int pindex = 0;\n        while(tindex < tlen)\n        {\n            if(pattern[pindex] == text[tindex])\n            {\n                pindex++;\n                tindex++;\n            }\n            if(pindex == plen)\n            {\n                return tindex-pindex;\n                pindex = lps[pindex-1];\n            }\n            else if(tindex<tlen && pattern[pindex] != text[tindex])\n            {\n                if(pindex) pindex = lps[pindex-1];\n                else tindex++;\n            }\n        }\n        return -1;\n    }\n    int strStr(string haystack, string needle) {\n        return kmp(haystack,needle);\n    }\n};#include<iostream>\nusing namespace std;\n#include<string>\n#include<vector>\n\nvector<int> prefix_fun(string s){\n    int n = s.size();\n    vector<int> pi(n,0);\n    for(int i = 1; i<s.size(); i++){\n        int j= pi[i-1];\n        while(j>0 && s[i] != s[j])\n            j = pi[j-1];\n        if(s[i] == s[j]) j++;\n        pi[i] = j;\n    }\n    return pi;\n}\nint kmpalgo(string text, string pat){\n    int pos = -1;\n    int i(0),j(0);\n    vector<int> pi = prefix_fun(pat);\n    while(i< text.length()){\n        if(text[i] == pat[j]){\n            i++; \n            j++;\n        }\n        else{\n            if(j) j = pi[j-1];\n            else i++;\n        }\n        if(j == pat.length()){\n            pos = i-pat.length();\n            break;\n        }\n    }\n    return pos;\n}\nint main(){\n    string t = \"agniksahagniss\";\n    string p = \"ks\";\n    cout<<kmpalgo(t,p)<<endl;\n    return 0;\n    \n}int Solution::strStr(const string A, const string B) {\nint m=A.length(),n=B.length();\n\nfor(int i=0;i<=m-n;i++)\n{   int j=0;\n    for(;j<n;j++)\n    if(B[j]!=A[i+j])break;\n    \n    if(j==n)\n    return i;\n}\nreturn -1;\n}class Solution {\npublic:\n    int longestOnes(vector<int>& nums, int k) {\n        int windowStart = 0, maxLength = 0, maxonecount = 0;\n        for(int windowEnd = 0; windowEnd < nums.size(); windowEnd++)\n        {\n            if(nums[windowEnd] == 1)\n                maxonecount++;\n            if(windowEnd-windowStart+1-maxonecount > k)\n            {\n                if(nums[windowStart] == 1)\n                    maxonecount--;\n                windowStart++;\n            }\n            maxLength = max(maxLength, windowEnd-windowStart+1);\n        }\n        return maxLength;\n    }\n};class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& arr) {\n        int windowSum = 0, minLength = INT_MAX;\n        int windowStart = 0;\n        for(int windowEnd = 0; windowEnd < arr.size(); windowEnd++)\n        {\n            windowSum += arr[windowEnd];\n            while(windowSum >= target)\n            {\n                minLength = min(minLength, windowEnd - windowStart+1);\n                windowSum -= arr[windowStart];\n                windowStart++;\n            }\n        }\n        return minLength == INT_MAX ? 0: minLength;\n        \n    }\n};\n\n\n/*\nSolution #\nThis problem follows the Sliding Window pattern and we can use a similar strategy as discussed in Maximum Sum Subarray of Size K. There is one difference though: in this problem, the size of the sliding window is not fixed. Here is how we will solve this problem:\n\nFirst, we will add-up elements from the beginning of the array until their sum becomes greater than or equal to \u2018S\u2019.\nThese elements will constitute our sliding window. We are asked to find the smallest such window having a sum greater than or equal to \u2018S\u2019. We will remember the length of this window as the smallest window so far.\nAfter this, we will keep adding one element in the sliding window (i.e. slide the window ahead), in a stepwise fashion.\nIn each step, we will also try to shrink the window from the beginning. We will shrink the window until the window\u2019s sum is smaller than \u2018S\u2019 again. This is needed as we intend to find the smallest window. This shrinking will also happen in multiple steps; in each step we will do two things:\nCheck if the current window length is the smallest so far, and if so, remember its length.\nSubtract the first element of the window from the running sum to shrink the sliding window.\n*/class Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string,int> mp;\n        vector<int> res;\n\n        for(auto word : words)\n            mp[word]++;\n        if(s.length()==0 || words.size() == 0)\n            return res;\n        int wordsCount = words.size();\n        int wordLength = words[0].length();\n        for(int i = 0; i< s.length()-wordsCount*wordLength+1; i++)\n        {\n            unordered_map<string,int> wordSeen;\n            for(int j = 0; j<wordsCount; j++)\n            {\n                int nextWordIndex = i+j*wordLength;\n                string word = s.substr(nextWordIndex, wordLength);\n                if(mp.find(word) == mp.end())\n                        break;\n                wordSeen[word]++;\n                if(wordSeen[word] > mp[word])\n                         break;\n                if(j+1 == wordsCount)\n                    res.push_back(i);\n                }\n            \n            }\n        return res;\n    }\n};class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int windowStart = 0, maxLength = 0;\n        unordered_map<char, int> mp;\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++)\n        {\n            char rightChar = s[windowEnd];\n            if(mp.find(rightChar) != mp.end())\n                windowStart = max(windowStart, mp[rightChar]+1);\n            mp[rightChar] = windowEnd;\n            maxLength = max(maxLength, windowEnd-windowStart+1);\n        }\n        return maxLength;\n    }\n};class Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> res;\n        unordered_map<char, int> mp;\n        for(char c: p) \n            mp[c]++;\n        int windowStart = 0, matched = 0;\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++)\n        {\n            char rightChar = s[windowEnd];\n            if(mp.find(rightChar) != mp.end())\n            {\n                mp[rightChar]--;\n                if(mp[rightChar] == 0)\n                    matched++;\n            }\n            if(matched == (int)mp.size())  //have we find the anagram\n                res.push_back(windowStart);\n            if(windowEnd >= p.length()-1)  // shrink the window\n            {\n                char leftChar = s[windowStart++];\n                if(mp.find(leftChar) != mp.end())\n                {\n                    if(mp[leftChar] == 0)\n                        matched --; //before putting the character back,decrement the match count\n                     \n                    mp[leftChar]++;  //put the character back\n                }\n              \n            }\n        }\n        return res;\n        \n    }\n};class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map<char, int> mp;\n        for(char c: t) \n            mp[c]++;\n        int windowStart = 0, matched = 0,substrStart = 0,minLength = s.length()+1;\n        \n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++)\n        {\n            char rightChar = s[windowEnd];\n            if(mp.find(rightChar) != mp.end())\n            {\n                mp[rightChar]--;\n                if(mp[rightChar] >= 0)\n                    matched++;\n            }\n            while(matched == t.length())\n            {\n                if(minLength > windowEnd - windowStart+1)\n                {\n                    minLength = windowEnd - windowStart+1;\n                    substrStart = windowStart;\n                }\n                char leftChar = s[windowStart++];\n                if(mp.find(leftChar) != mp.end())\n                {\n                    if(mp[leftChar] == 0)\n                        matched --; //before putting the character back,decrement the match count\n                     \n                    mp[leftChar]++;  //put the character back\n                }\n              \n            }\n        }\n        return minLength > s.length()?\"\":s.substr(substrStart, minLength);\n    }\n};using namespace std;\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<limits>\n#include<string>\n#include<unordered_map>\n\nclass LongestSubstringKDistinct\n{\n    public:\n        static int findLength(const string &str, int k)\n        {\n        int windowSum = 0, maxLength = 0;\n        int windowStart = 0;\n        unordered_map<char,int> mp;\n        for(int windowEnd = 0; windowEnd < str.length(); windowEnd++)\n        {\n            char rightChar = str[windowEnd];\n            mp[rightChar]++;\n            while(mp.size() > k)\n            {\n                char leftChar = str[windowStart];\n                mp[leftChar]--;\n                if(mp[leftChar] == 0)\n                    mp.erase(leftChar);\n                windowStart++;\n            }\n            maxLength = max(maxLength, windowEnd-windowStart+1);\n        }\n        return maxLength;\n        }\n};\n\n\nint main(){\n    cout <<\"Length of the longest substring \"<<LongestSubstringKDistinct:: findLength(\"araaci\",2)<<endl;\n    return 0;\n}using namespace std;\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<limits>\n\nclass MaxSumSubarrayOfSizeK\n{\n    public:\n    static int bruteforceSol(vector<int>& arr, int k)\n    {\n        int maxSum = 0, windowSum;\n        for(int i =0; i<= arr.size()-k; i++)\n        {\n            windowSum = 0;\n            for(int j = i; j< i+k; j++)\n                windowSum += arr[j];\n            maxSum = max(maxSum, windowSum);\n        }\n        return maxSum;\n    }\n    static int slidingWindow(vector<int>& arr, int k)\n    {\n        int windowSum = 0, maxSum = 0;\n        int windowStart = 0;\n        for(int windowEnd = 0; windowEnd < arr.size(); windowEnd++)\n        {\n            windowSum += arr[windowEnd];\n\n            if(windowEnd >= k-1){\n                maxSum = max(maxSum, windowSum);\n                windowSum -= arr[windowStart];\n                windowStart++;\n            }\n        }\n        return maxSum;\n    }\n};\n\nint main()\n{\n    cout << \"Maximum Sum of a subarray of sike k: \"<<\n        MaxSumSubarrayOfSizeK::bruteforceSol(vector<int>{2,1,5,1,3,2},3) <<endl;\n\n\n        cout << \"Maximum Sum of a subarray of sike k: \"<<\n        MaxSumSubarrayOfSizeK::slidingWindow(vector<int>{2,1,5,1,3,2},3) <<endl;\n        return 0;\n}class MinStack {\npublic:\n    /** initialize your data structure here. */\n    vector<int> a,b;\n    MinStack() {\n        a = b = {};\n        \n    }\n    \n    void push(int val) {\n        a.push_back(val);\n        if(b.empty()) b.push_back(val);\n        else {\n            int newMin = min(val,*b.rbegin());\n            b.push_back(newMin);\n        }\n        \n    }\n    \n    void pop() {\n        a.pop_back();\n        b.pop_back();\n        \n    }\n    \n    int top() {\n        return *a.rbegin();\n        \n    }\n    \n    int getMin() {\n        return *b.rbegin();\n        \n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */class Solution {\npublic:\n    bool isValid(string s) {\n    stack<char> temp;\n    map<char, char> m = { {']','['},{')','('},{'}','{'} };\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '[' || s[i] == '(' || s[i] == '{')\n            temp.push(s[i]);\n        else if (s[i] == ']' || s[i] == ')' || s[i] == '}')\n        {\n            if (temp.empty()||temp.top() != m[s[i]]) return false;\n            else temp.pop();\n        }\n    }\n    return temp.empty();\n        \n    }\n};class MyStack {\npublic:\n    /** Initialize your data structure here. */\n    MyStack() {\n        int x;\n      \n    }\n     queue<int> q1;\n     queue<int> q2;\n    \n    /** Push element x onto stack. */\n    void push(int x) \n    {\n        q2.push(x);\n        while(!q1.empty())\n        {\n            int top= q1.front();\n            q1.pop();\n            q2.push(top);\n       }\n            queue<int> temp = q1;\n            q1 = q2;\n            q2 = temp;\n    }\n    \n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n       int top= q1.front();\n        q1.pop();\n        return top;\n    }\n    \n    /** Get the top element. */\n    int top() {\n       return q1.front();\n        \n    }\n    \n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return (q1.empty());\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */class MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n        int x;\n    }\n    stack<int> s1;\n    stack<int> s2;\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        while(!s1.empty())\n        {\n            int y = s1.top();\n            s1.pop();\n            s2.push(y);\n        }\n        s1.push(x);\n        while(!s2.empty())\n        {\n            int y = s2.top();\n            s2.pop();\n            s1.push(y);\n        }\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        \n        int res = s1.top();\n        s1.pop();\n        return res;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        return s1.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return s1.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */// this is nlohn approach using multiset\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        multiset<int,greater<int>> mp;\n        vector<int> ans; \n        for(int i = 0; i<k; i++)\n            mp.insert(nums[i]);\n        ans.push_back(*mp.begin());\n        for(int i = k; i< nums.size(); i++)\n        {\n            mp.erase(mp.lower_bound(nums[i-k]));\n            mp.insert(nums[i]);\n            ans.push_back(*mp.begin());\n        }\n        return ans;\n    }\n};\n\n\n\n\n// o(n) solution using deque\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> res;\n        deque<int> q;\n        for(int i = 0; i<k; i++)\n        {\n            while(!q.empty() and nums[q.back()] < nums[i])\n                q.pop_back();\n            q.push_back(i);\n        }\n        res.push_back(nums[q.front()]);\n        for(int i = k; i< nums.size(); i++)\n        {\n            if(q.front() == i-k) q.pop_front();\n             while(!q.empty() and nums[q.back()] < nums[i])\n                q.pop_back();\n            \n            q.push_back(i);\n            res.push_back(nums[q.front()]);\n        }\n        return res;\n    }\n};class Solution {\npublic:\n    int trap(vector<int>& height) {\n        if(height.size() == 0) return 0;\n        vector<int> maxl(height.size());\n         vector<int> maxr(height.size());\n        maxl[0] = height[0];\n        for(int i = 1; i< height.size(); i++)\n        {\n            maxl[i] = max(maxl[i-1],height[i] );\n        }\n        maxr[height.size()-1] = height[height.size()-1];\n        for(int i = height.size()-2; i>=0; i--)\n        {\n            maxr[i] = max(maxr[i+1],height[i] );\n        }\n        vector<int> water(height.size());\n        for(int i = 0; i< height.size(); i++)\n        {\n            water[i] = min(maxl[i], maxr[i]) - height[i];\n        }\n        int total = 0;\n        for(int i = 0; i< height.size(); i++)\n        {\n            total+= water[i];\n        }\n        return total;\n    }\n};class Solution {\npublic:\n    \n    vector<int> NGR(vector<int> nums)\n    {\n        vector<int> res(nums.size());\n        stack<int> st;\n        for(int i = nums.size()-1; i>= 0; i--)\n        {\n            while(st.size() > 0 && st.top() < nums[i]) st.pop();\n            res[i] = st.size()>0 ? st.top() : -1;\n            st.push(nums[i]);\n        }\n        return res;\n    }\n\n    vector<int> nextGreaterElement(vector<int>& query, vector<int>& nums) {\n        unordered_map<int, int> mp;\n        vector<int> ng = NGR( nums );\n        for(int i = 0; i< nums.size(); i++)\n            mp[nums[i]] = ng[i];\n        \n        vector<int> res(query.size());\n        for(int i = 0; i< query.size(); i++)\n            res[i] = mp[query[i]];\n        return res;\n        \n    }\n};class Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        vector<int> res(nums.size());\n        stack<int> st;\n        for(int i = 2*nums.size()-1; i>= 0; i--)\n        {\n            while(!st.empty() and nums[st.top()]<= nums[i%nums.size()])\n                st.pop();\n            res[i % nums.size()] = (!st.empty())?nums[st.top()]:-1;\n            st.push(i% nums.size());\n        }\n        return res;\n    }\n};class Solution {\npublic:\n    vector<int> asteroidCollision(vector<int>& asteroids) {\n        stack<int> st;\n        for(int val : asteroids)\n        {\n            if(val>0) st.push(val);\n            else\n            {\n                while(!st.empty() and st.top()>0 and st.top() < abs(val))\n                    st.pop();\n                if(!st.empty() and st.top() == abs(val))\n                    st.pop();\n                else if(!st.empty() and st.top() > abs(val))\n                    continue;\n                else \n                    st.push(val);\n            }\n        }\n        vector<int> res(st.size());\n        for(int i = st.size()-1; i>=0; i--){\n            res[i] = st.top();\n            st.pop();\n        }\n        return res;\n        \n    }\n};class Solution {\npublic:\n    int largestRectangleArea(vector<int>& h) {\n        int n= h.size();\n        if(n==1)\n            return h[0];\n        vector<int> lb(n,-1); // next smaller element of left\n        vector<int> rb(n,n); //next smaller element on right\n        stack<int> st;    //Monotonic stack\n        for(int i=0;i<n;i++){\n            while(!st.empty() && h[st.top()] >=h[i])\n                st.pop();\n            if(!st.empty())\n                lb[i] = st.top();\n            st.push(i);\n        }\n        while(!st.empty()) st.pop();\n        for(int i=n-1;i>=0;i--){\n            while(!st.empty() && h[st.top()] >=h[i]){\n                st.pop();\n            }\n            if(!st.empty())\n                rb[i] = st.top();\n            st.push(i);\n        }\n        int maxi = INT_MIN;\n        for(int i=0;i<n;i++){\n            maxi = max(maxi,(rb[i]-lb[i]-1)*(h[i]));\n        }\n            \n        return maxi;\n    }\n};\n// OUR PATTERN POP-> ANS -> PUSH\n\n//Approach-1 (stack and using idx variable for trackign index)\n\n class StockSpanner {\npublic:\n    stack<pair<int,int>> st;\n    int index = -1;\n    StockSpanner() {\n        index = -1;\n    }\n    \n    int next(int price) \n    {\n      index++;\n      while(!st.empty() && st.top().first<= price )\n        st.pop();\n      int res = 1;\n      res = (st.empty())?index+1: index-st.top().second;\n      st.push({price, index});\n      return res;           \n    }\n};\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner* obj = new StockSpanner();\n * int param_1 = obj->next(price);\n */\n\n\n\n\n\n//Approach-2 (Stack and using count variable)\nclass StockSpanner {\npublic:\n    stack<pair<int, int>> st;\n    StockSpanner() {\n        \n    }\n    \n    int next(int price) {\n        int count = 1;\n        while(!st.empty() && st.top().first <= price) {\n            count += st.top().second;\n            st.pop();\n        }\n        \n        st.push({price, count});\n        \n        return count;\n        \n    }\n};using namespace std;\n#include<iostream>\n#include<vector>\n#include<stack>\n\nvector<int> NGR(vector<int> nums)\n{\n    vector<int> res(nums.size());\n    stack<int> st;\n    for(int i = nums.size()-1; i>= 0; i--)\n    {\n        while(st.size() > 0 && st.top() < nums[i]) st.pop();\n        res[i] = st.size()>0 ? st.top() : -1;\n        st.push(nums[i]);\n    }\n    return res;\n}\n\nint main(){\n    vector<int> v = {5,4,8,3,1,2};\n    cout<<\" Next Greater elements \" <<\" \";\n    vector<int> res =  NGR(v);\n    for(int r : res)\n        cout<< r<<\" \";\n    return 0;\n}vector<int> Solution::prevSmaller(vector<int> &A) {\n    stack<int> st;\n    vector<int> res(A.size());\n    for(int i=0;i<A.size();i++)\n    {\n        while(st.size()>0 && st.top() >= A[i])\n            st.pop();\n        res[i] = st.size()>0 ? st.top():-1;\n        st.push(A[i]);\n    }\n    return res;\n}\n// C++ program to find celebrity\n#include <iostream>\n#include <list>\n#include<vector>\n#include<stack>\nusing namespace std;\n\n// Max # of persons in the party\n#define N 8\n\n// Person with 2 is celebrity\nbool MATRIX[N][N] = {{0, 0, 1, 0},\n\t\t\t\t\t{0, 0, 1, 0},\n\t\t\t\t\t{0, 0, 0, 0},\n\t\t\t\t\t{0, 0, 1, 0}};\n\nbool knows(int a, int b)\n{\n\treturn MATRIX[a][b];\n}\n\n// Returns -1 if celebrity\n// is not present. If present,\n// returns id (value from 0 to n-1).\nint findCelebrity(int n)\n{\n\t// Handle trivial\n\t// case of size = 2\n\tstack<int> s;\n\n\t// Celebrity\n\tint C;\n\n\t// Push everybody to stack\n\tfor (int i = 0; i < n; i++)\n\t\ts.push(i);\n\n\t// Extract top 2\n\n\n\t// Find a potential celebrity\n\twhile (s.size() > 1)\n\t{ int A = s.top();\n\t\ts.pop();\n\t\tint B = s.top();\n\t\ts.pop();\n\t\tif (knows(A, B))\n\t\t{\n\t\ts.push(B);\n\t\t}\n\t\telse\n\t\t{\n\t\ts.push(A);\n\t\t}\n\t}\n\t// If there are only two people\n\t// and there is no\n\t// potential candicate\n\tif(s.empty())\n\t\treturn -1;\n\n\n\t// Potential candidate?\n\tC = s.top();\n\ts.pop();\n\n\t// Check if C is actually\n\t// a celebrity or not\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\t// If any person doesn't\n\t\t// know 'C' or 'C' doesn't\n\t\t// know any person, return -1\n\t\tif ( (i != C) &&\n\t\t\t\t(knows(C, i) ||\n\t\t\t\t!knows(i, C)) )\n\t\t\treturn -1;\n\t}\n\n\treturn C;\n}\n\n// Driver code\nint main()\n{\n\tint n = 4;\n\tint id = findCelebrity(n);\n\tid == -1 ? cout << \"No celebrity\" :\n\t\t\tcout << \"Celebrity ID \" << id;\n\treturn 0;\n}\n#include<string>\n\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n       int start=0, end=s.length()-1;\n\twhile(start<end) {\n\t\tif (!isalnum(s[start])) start++;\n\t\telse if (!isalnum(s[end])) end--;\n\t\telse {\n\t\t\tif (tolower(s[start++])!=tolower(s[end--])) return false;\n\t\t}\n\t}\n\treturn true;\n        \n    }\n};class Solution {\npublic:\n    int maxPower(string s) {\n        char prev = ' ';\n        int maxLength = 0;\n        int count = 0;\n        for(int i = 0; i<s.length(); i++)\n        {\n            if(s[i] == prev){\n                count++;\n            }\n            else {\n                count = 1;\n                prev = s[i];\n            }\n            maxLength = max(count, maxLength);\n        }\n        return maxLength;\n    }\n};class Solution {\npublic:\n    string reverseWords(string s) {\n        vector<string> tmp;\n        string f;\n        for(int i = 0; i<s.length(); i++)\n        {\n            if(s[i]!= ' ')\n                f += s[i];\n            else{\n                if(f.size() != 0)\n                {\n                    tmp.push_back(f);\n                    f.clear();\n                }\n            }\n                \n        }\n        if(f.size() != 0) tmp.push_back(f);\n        s.clear();\n        for(int i = tmp.size()-1; i>0 ; i--)\n        {\n            s+= tmp[i];\n            s+= \" \";\n        }\n        s+= tmp[0];\n         return s;\n        \n    }\n};class Solution {\npublic:\n    int compareVersion(string version1, string version2) {\n   int i = 0; \n    int j = 0;\n    int n1 = version1.size(); \n    int n2 = version2.size();\n    \n    int num1 = 0;\n    int num2 = 0;\n    while(i<n1 || j<n2)\n    {\n        while(i<n1 && version1[i]!='.'){\n            num1 = num1*10+(version1[i]-'0');\n            i++;\n        }\n        \n        while(j<n2 && version2[j]!='.'){\n            num2 = num2*10+(version2[j]-'0');\n            j++;\n        }\n        \n        if(num1>num2) return 1;\n        else if(num1 < num2) return -1;\n        \n        num1 = 0;\n        num2 = 0;\n        i++;\n        j++;\n    }\n    \n    return 0;\n    }\n};class Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        vector<int> mp(26);\n        vector<bool> visited(26,false);\n        stack<char> st;\n        for(int i = 0; i<s.length(); i++)\n        {\n            mp[s[i]-'a']++;\n        }\n        for(int i = 0; i<s.length(); i++)\n        {\n            mp[s[i]-'a']--;\n            if(visited[s[i]-'a']) continue;\n            while(st.size() > 0 && st.top()>s[i] && mp[st.top()-'a'] > 0)\n            {\n                char rem = st.top();st.pop();\n                visited[rem-'a'] = false;\n            }\n            st.push(s[i]);\n            visited[s[i]-'a'] = true;\n        }\n        string ans = \"\";\n        while(!st.empty()){\n            ans+= st.top();\n            st.pop();\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n            \n    }\n};class Solution {\npublic:\n    int firstUniqChar(string s) {\n        unordered_map<char,int> mp;\n        for(int i = 0; i< s.length(); i++)\n            mp[s[i]]++;\n        for(int i = 0; i<s.length(); i++)\n        {\n            if(mp[s[i]]== 1) return i;\n        }\n        return -1;\n        \n    }\n};class Solution {\npublic:\n    int compress(vector<char>& chars) {\n        int i=0;\n        int j = 0;\n        while(i<chars.size())\n        {\n            char now = chars[i];\n            chars[j++]= chars[i++];\n            int count = 1;\n                while(i<chars.size() && (now == chars[i])) \n                {\n                    i++;\n                    count++;\n                }\n            if(count > 1)  {\n                for(char digit : to_string(count))\n                chars[j++] = digit;\n            }  \n            \n        }\n        return j;\n        \n    }\n};class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> result;\n        unordered_map<string, vector<string>> mp;\n        string temp;\n        int n = strs.size();\n        for(int i = 0; i<n;i++)\n        {\n            temp =  strs[i];\n            sort(strs[i].begin(),strs[i].end());\n            mp[strs[i]].push_back(temp);\n        }\n        \n        //temp - stores sorted word of array\n        \n        for(auto it = mp.begin(); it != mp.end(); it++)\n        {\n            result.push_back(it->second);\n        }\n        return result;\n    }\n};class Solution {\npublic:\n    int myAtoi(string s) {\n        int i=0;\n        while (s[i] == ' ') { i++; }\n        int flag = 1;\n        if(s[i] == '-') {flag = 0; i++;}\n        else if(s[i] == '+') {flag = 1; i++;}\n        \n        long long int sum = 0;\n        for(; i<s.length(); i++)\n        {\n            if(s[i] >= '0' && s[i] <= '9' )\n                sum = sum*10 + (s[i]-'0');\n            else break;\n            if(sum>INT_MAX)\n                return flag==0?INT_MIN:INT_MAX;\n        }\n        \n      if(flag==0)return -1*(int)sum;\n        else return (int)sum;\n\n        \n    }\n};/*\nGiven a string A denoting a stream of lowercase alphabets. You have to make new string B.\n\nB is formed such that we have to find first non-repeating character each time a character is \ninserted to the stream and append it at the end to B. If no non-repeating character is found then \nappend '#' at the end of B.\n\n\nInput:   A = \"abadbc\"\nOutput:  \"aabbdd\"\n*/\nstring Solution::solve(string A) {\n    vector<char>v;\n    unordered_map<char, int>m;\n    string result;\n    int i = 0;\n    for(char c: A) {\n        v.push_back(c);\n        m[c]++;\n        for (; i < v.size(); i++) {\n            if (m[v[i]] == 1) {\n                result.push_back(v[i]);\n                break;\n            }\n        }\n        if (i >= v.size()) {\n            result.push_back('#');\n        }\n    }\n    return result;\n}\n//this tutorial will describe substr in c++\n#include<iostream>\nusing namespace std;\n#include<string>\n#include <sstream>\n\nstring fun(string s)\n{\n    return s.substr(2,2);\n}\nstring reverseWords(string s) \n{\n        string op=\"\";\n        istringstream ss(s);\n        string word;\n        while( ss>>word)\n        {\n            \n        op = word+\" \"+op;\n        }\n        //op.pop_back();\n        return op;\n    }\n int main()\n {\n     string s = \"Agnik is good boy\";\n     string res = reverseWords(s);\n     cout<<res<<endl;\n     return 0;\n }/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        if(!root) return res;\n        queue<TreeNode*> q;\n        q.push(root);\n        int level = 0;\n        while(!q.empty())\n        {\n            int size = q.size();\n            vector<int> temp;\n            for(int i = 0 ; i<size; i++)\n            {\n                TreeNode* node = q.front();\n                temp.push_back(node->val);\n                q.pop();\n                if(node->left) q.push(node->left);\n                if(node->right) q.push(node->right);\n            }\n\n            if(level % 2 == 1) reverse(temp.begin(), temp.end());\n             res.push_back(temp);\n             level++;\n        }\n        return res;\n        \n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n\nTreeNode* buildTreehelper(vector<int>& preorder, vector<int>& inorder,int start,int end,int &idx)\n{\n    if(start > end) return NULL;\n    int cur = preorder[idx],pos;\n    for(int i = start; i<=end; i++)\n        if(inorder[i] == cur) {\n            pos= i;\n            break;\n        }\n    idx++;\n    TreeNode* node = new TreeNode(cur);\n    node->left = buildTreehelper(preorder,inorder,start,pos-1,idx);\n    node->right = buildTreehelper(preorder,inorder,pos+1,end,idx);\n    return node;\n}\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int idx = 0;\n        return buildTreehelper(preorder,inorder,0,inorder.size()-1,idx);\n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* buildTreehelper(vector<int>& postorder, vector<int>& inorder,int start,int end,int &idx)\n{\n    if(start > end) return NULL;\n    int cur = postorder[idx],pos;\n    for(int i = start; i<=end; i++)\n        if(inorder[i] == cur) {\n            pos= i;\n            break;\n        }\n    idx--;\n    TreeNode* node = new TreeNode(cur);\n    node->right = buildTreehelper(postorder,inorder,pos+1,end,idx);\n     node->left = buildTreehelper(postorder,inorder,start,pos-1,idx);\n    return node;\n}\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n                int idx = inorder.size()-1;\n        return buildTreehelper(postorder,inorder,0,inorder.size()-1,idx);\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> res;\n        if(!root) return res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty())\n        {\n            int size = q.size();\n            vector<int> temp;\n            for(int i = 0 ; i<size; i++)\n            {\n                TreeNode* node = q.front();\n                temp.push_back(node->val);\n                q.pop();\n                if(node->left) q.push(node->left);\n                if(node->right) q.push(node->right);\n            }\n             res.push_back(temp);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if(!root) return 0;\n        queue<TreeNode*> q;\n        q.push(root);\n        int minDepth = 0;\n        while(!q.empty())\n        {\n            int levelsize = q.size();\n            minDepth++;\n            for(int i = 0; i<levelsize; i++)\n            {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                if(!currentNode->left && !currentNode->right)\n                    return minDepth;\n                if(currentNode->left) q.push(currentNode->left); \n                if(currentNode->right) q.push(currentNode->right); \n\n            }\n        }\n        return minDepth;\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n\n    bool hasPathSum(TreeNode* root, int sum) {\n        if(!root) return false;\n         if(root->val == sum && !root->left && !root->right) return true;\n        return  hasPathSum(root->left, sum - root->val) ||  hasPathSum(root->right, sum - root->val);     \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void dfs(TreeNode* root, int sum, vector<int>& path, vector<vector<int>> &paths )\n    {\n        if(!root) return ;  //BASE CASE\n        \n        path.push_back(root -> val); //WHAT SHOULD WE DO FIRST\n        \n        //GOAL STATE\n        if(root->val == sum && !root->left && !root->right)\n                     paths.push_back(path);\n        //MAGICAL RECUSIVE FUNCTION\n        dfs(root->left, sum - root->val, path, paths);\n        dfs(root->right,sum - root->val ,path, paths);\n        path.pop_back();  //BACKTRACK\n   \n    }\n    vector<vector<int>> pathSum(TreeNode* root, int sum) {\n        vector<int> path;\n        vector<vector<int>> paths;\n        dfs(root, sum, path, paths);\n        return paths;\n\n        \n    }\n};/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(!root) return NULL;\n        queue<Node*> q;\n        q.push(root);\n        root->next = NULL;\n        while(!q.empty())\n        {\n            int levelsize = q.size();\n            vector<Node*> level;\n            for(int i = 0; i<levelsize; i++)\n            {\n                Node* currentNode = q.front();\n                q.pop();\n                if(currentNode->left) {\n                    q.push(currentNode->left);\n                    level.push_back(currentNode->left);   \n                }\n                if(currentNode->right){\n                    q.push(currentNode->right);\n                    level.push_back(currentNode->right);  \n                }\n            }\n            for(int i = 0; i<level.size(); i++)\n            {\n                if(i+1 == level.size()){\n                    level[i]-> next = NULL;\n                    break;\n                }\n                level[i]->next = level[i+1];\n            }\n            \n        } \n        return root;\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int solve(TreeNode* currnode, int &globalMaximum)\n    {\n        if(!currnode) return 0;\n        int maxpathsumfromleft = solve(currnode->left, globalMaximum);\n        int maxpathsumfromright = solve(currnode->right, globalMaximum);\n        \n        maxpathsumfromleft = max(0,maxpathsumfromleft);\n        maxpathsumfromright = max(0, maxpathsumfromright);\n        \n        // ignore paths with negative sums\n        int localMaximum = maxpathsumfromleft+maxpathsumfromright+ currnode->val;\n        globalMaximum = max(localMaximum,globalMaximum);\n        \n        return max(maxpathsumfromleft,maxpathsumfromright)+currnode->val;\n        \n                \n    }\n    int maxPathSum(TreeNode* root) {\n            int globalMaximum = INT_MIN;\n            int x = solve(root, globalMaximum);\n            return globalMaximum;\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> res;\n        if(!root) return res;\n        queue<TreeNode*> q;\n        q.push(root);\n        res.push_back(root->val);\n        while(!q.empty())\n        {\n            int levelsize = q.size();\n            vector<TreeNode*> level;\n            for(int i = 0; i<levelsize; i++)\n            {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                if(currentNode->left) {\n                    q.push(currentNode->left);\n                    level.push_back(currentNode->left);   \n                }\n                if(currentNode->right){\n                    q.push(currentNode->right);\n                    level.push_back(currentNode->right);  \n                }\n            }\n            for(int i = 0; i<level.size(); i++)\n            {\n                if(i+1 == level.size()){\n                    res.push_back(level[i]-> val);\n                    break;\n                }\n            }\n            \n        } \n        return res;\n        \n    }\n};\n\n\n\n\n\n\n\n\n// Another same solution with little change\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> result;\n        if(!root) return {};\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty())\n        {\n            int size = q.size(), val =-1;\n            for(int i = 0 ;i<size; i++)\n            {\n                TreeNode* node = q.front();\n                q.pop();\n\n                if(i == size-1)   val = node->val;\n\n                if(node->left) q.push(node->left);\n                                \n                if(node->right) q.push(node->right);\n                               \n            } \n            result.push_back(val);\n        }\n        return result;\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void dfs(TreeNode* root, string path, vector<string> &paths)\n    {\n        path =path+ to_string(root->val);\n        if(!root->left && !root->right) paths.push_back(path);\n        if(root->left) dfs(root->left,path+ \"->\", paths);\n        if(root->right) dfs(root->right,path+ \"->\", paths);\n    }\n    \n    \n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector<string> paths;\n        string path=\"\";\n        if(!root) return paths;\n        else dfs(root, path, paths);\n        return paths;\n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int pathSumHelper(TreeNode* currnode, int S, vector<int> &paths)\n    {\n        if(!currnode) return 0;\n        paths.push_back(currnode->val);\n        int pathsum = 0, pathcount = 0;\n        for(vector<int>::reverse_iterator itr = paths.rbegin(); itr!= paths.rend(); itr++)\n        {\n            pathsum += *itr;\n            if(pathsum == S) pathcount++;\n        }\n        pathcount += pathSumHelper(currnode->left, S,paths);\n        pathcount += pathSumHelper(currnode->right, S,paths);\n        paths.pop_back();\n        return pathcount;\n\n    }\n    int pathSum(TreeNode* root, int targetSum) {\n        vector<int> paths;\n        return pathSumHelper(root, targetSum, paths);\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int calculateHeight(TreeNode* root, int &treeDiameter)\n    {\n        if(!root) return 0;\n        int lefttreeheight = calculateHeight(root->left, treeDiameter);\n        int righttreeheight = calculateHeight(root->right, treeDiameter);\n        \n        //diameter of the current node\n        int diameter = lefttreeheight+righttreeheight+1;\n        // update the global tree diameter\n        treeDiameter = max(treeDiameter,diameter);\n        \n        // height of the current node\n        return max(lefttreeheight,righttreeheight)+1;\n        \n        \n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        if(!root) return 0 ;\n        int treeDiameter = 0;\n        int x = calculateHeight(root, treeDiameter);\n        return treeDiameter-1;  //-1 because length = no of edges\n        \n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<double> averageOfLevels(TreeNode* root) {\n        vector<double> res;\n        if(!root) return res;\n        queue<TreeNode*> q;\n        q.push(root);\n        while(!q.empty())\n        {\n            int levelsize = q.size();\n            double levelSum = 0;\n            for(int i = 0; i<levelsize; i++)\n            {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                levelSum += currentNode->val;\n                if(currentNode->left) q.push(currentNode->left); \n                if(currentNode->right) q.push(currentNode->right); \n\n            }\n            res.push_back(levelSum/levelsize);\n        }\n        return res;\n    }\n};/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    void inorder(TreeNode* root,vector<int> &result)\n    {\n        if(!root) return ;\n        inorder(root->left, result);\n        result.push_back(root->val);\n        inorder(root->right, result);\n    }\n    bool isValidBST(TreeNode* root) {\n        \n        vector<int> in ;\n        inorder(root,in);\n        int temp = in[0];\n        for(int i = 1; i<in.size(); i++)\n        {\n            if(temp>=in[i]) {\n                return false;\n                break;\n            }\n            temp = in[i];\n        }\n        return true;\n\n   }\n\n};\n// CPP program to find Levelorder\n// successor of given node in the\n// Binary Tree\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Tree Node\nstruct Node {\n\tstruct Node *left, *right;\n\tint value;\n};\n\n// Utility function to create a\n// new node with given value\nstruct Node* newNode(int value)\n{\n\tNode* temp = new Node;\n\ttemp->left = temp->right = NULL;\n\ttemp->value = value;\n\n\treturn temp;\n}\n\n// Function to find the Level Order Successor\n// of a given Node in Binary Tree\nNode* levelOrderSuccessor(Node* root, Node* key)\n{\n\t// Base Case\n\tif (root == NULL)\n\t\treturn NULL;\n\n\t// If root equals to key\n\tif (root == key) {\n\n\t\t// If left child exists it will be\n\t\t// the Postorder Successor\n\t\tif (root->left)\n\t\t\treturn root->left;\n\n\t\t// Else if right child exists it will be\n\t\t// the Postorder Successor\n\t\telse if (root->right)\n\t\t\treturn root->right;\n\t\telse\n\t\t\treturn NULL; // No Successor\n\t}\n\n\t// Create an empty queue for level\n\t// order traversal\n\tqueue<Node*> q;\n\n\t// Enqueue Root\n\tq.push(root);\n\n\twhile (!q.empty()) {\n\t\tNode* nd = q.front();\n\t\tq.pop();\n\n\t\tif (nd->left != NULL) {\n\t\t\tq.push(nd->left);\n\t\t}\n\n\t\tif (nd->right != NULL) {\n\t\t\tq.push(nd->right);\n\t\t}\n\n\t\tif (nd == key)\n\t\t\tbreak;\n\t}\n\n\treturn q.front();\n}\n\n// Driver code\nint main()\n{\n\tstruct Node* root = newNode(20);\n\troot->left = newNode(10);\n\troot->left->left = newNode(4);\n\troot->left->right = newNode(18);\n\troot->right = newNode(26);\n\troot->right->left = newNode(24);\n\troot->right->right = newNode(27);\n\troot->left->right->left = newNode(14);\n\troot->left->right->left->left = newNode(13);\n\troot->left->right->left->right = newNode(15);\n\troot->left->right->right = newNode(19);\n\n\tstruct Node* key = root->right->left; // node 24\n\n\tstruct Node* res = levelOrderSuccessor(root, key);\n\n\tif (res)\n\t\tcout << \"LevelOrder successor of \"\n\t\t\t<< key->value << \" is \" << res->value;\n\telse\n\t\tcout << \"LevelOrder successor of \"\n\t\t\t<< key->value << \" is \" << \"NULL\";\n\n\treturn 0;\n}\n\n// C++ program to find longest consecutive\n// sequence in binary tree\n#include <iostream>\n#include<algorithm>\nusing namespace std;\nstruct Node\n{\n    int data;\n    Node *left, *right;\n};\n Node* newNode(int data)\n{\n    Node* temp = new Node;\n    temp->data = data;\n    temp->left = temp->right = NULL;\n    return temp;\n}\n\nvoid longestConsecutiveUtil(Node* root, int curLength,int expected, int& res)\n{\n    if (root == NULL)\n        return;\n    if (root->data == expected)\n        curLength++;\n    else\n        curLength = 1;\n    res = max(res, curLength);\n    longestConsecutiveUtil(root->left, curLength,root->data + 1, res);\n    longestConsecutiveUtil(root->right, curLength,root->data + 1, res);\n}\n\nint longestConsecutive(Node* root)\n{\n    if (root == NULL)\n        return 0;\n \n    int res = 0;\n    longestConsecutiveUtil(root, 0, root->data, res);\n    return res;\n}\n \nint main()\n{\n    Node* root = newNode(6);\n    root->right = newNode(9);\n    root->right->left = newNode(7);\n    root->right->right = newNode(10);\n    root->right->right->right = newNode(11);\n \n    cout<< longestConsecutive(root)<<endl;\n    return 0;\n}/**\n * Definition for binary tree\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n int solve(TreeNode* A, int val)\n {\n     if(!A) return 0;\n     int temp = (((val*10)%1003) + A->val)%1003;\n     if(A->left ==NULL && A->right == NULL)\n        return temp;\n     int l = solve(A->left,temp);\n     int r = solve(A->right,temp);\n     return (l+r)%1003;\n }\n \nint Solution::sumNumbers(TreeNode* A) {\n    return solve(A,0);\n}\n\n#include<vector>\n#include<map>\n#include<set>\n/*\nclass Node {\n    public:\n        int data;\n        Node *left;\n        Node *right;\n        Node(int d) {\n            data = d;\n            left = NULL;\n            right = NULL;\n        }\n};\n\n*/\nmap<int,map<int,set<int>>> mymap;\n    void solve(Node *curr,int col,int row)\n    {\n        if(!curr)\n            return;\n        \n        mymap[col][row].insert(curr->data);\n        solve(curr->left,col-1,row+1);\n        solve(curr->right,col+1,row+1);\n    }\n    \n    vector<vector<int>> verticalTraversal(Node* root) {\n        solve(root,0,0);\n        \n        vector<vector<int>> ans;\n        for(auto m1: mymap)\n        {    \n            ans.push_back(vector<int>());\n            for(auto m2: m1.second)\n            {\n                for(auto m3: m2.second)\n                    ans.back().push_back(m3);\n            }\n        }\n        return ans;\n    }\n\n    void topView(Node * root) {\n        vector<vector<int>> v;\n        v = verticalTraversal(root);\n        for(int i = 0; i< v.size(); i++)\n                cout<<*(v[i]).begin()<<\" \";\n\n    }\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n   void findMinMax( TreeNode*node, int *min, int *max, int hd)\n{\n    \n    if (node == NULL) return;\n \n    \n    if (hd < *min)  *min = hd;\n    else if (hd > *max) *max = hd;\n \n    \n    findMinMax(node->left, min, max, hd-1);\n    findMinMax(node->right, min, max, hd+1);\n}\n\nvoid printVerticalLine(TreeNode *node, int line_no, int hd,vector<int> &t)\n{\n    if (node == NULL) return ;\n \n    if (hd == line_no){\n\n        t.push_back(node->val);\n    }\n    \n    printVerticalLine(node->left, line_no, hd-1,t);\n    printVerticalLine(node->right, line_no, hd+1,t);    \n}\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> res;\n        vector<int> t;\n        int min = 0, max = 0,line_no;\n        findMinMax(root, &min, &max, 0);\n\n        for (line_no = min; line_no <= max; line_no++)\n        {\n            printVerticalLine(root, line_no, 0,t);\n            res.push_back(t);\n            t.clear();\n        }\n        return res;\n    }\n};\n\n#include<iostream>\nusing namespace std;\nclass Trie {\n    struct trienode{\n        int val;\n        int count;\n        int endsHere;\n        trienode* child[26];\n    };\n    trienode* root;\n    trienode* getnode(int index)\n    {\n        trienode* newnode = new trienode();\n        newnode->val = 'a'+index;\n        newnode->count = newnode->endsHere = 0;\n        for(int i = 0; i<26; i++)\n            newnode->child[i] = NULL;\n        return newnode;\n    }\npublic:\n    /** Initialize your data structure here. */\n    Trie() {\n        root = getnode('/'-'a');\n    }\n    \n    /** Inserts a word into the trie. */\n    void insert(string word)\n    {\n        trienode* curr = root;\n        int index;\n        for(int i = 0; word[i] !='\\0'; i++)\n        {\n            index = word[i]-'a';\n            if(curr->child[index] == NULL)\n                curr->child[index] = getnode(index);\n            curr->child[index]-> count += 1;\n            curr = curr->child[index];\n        }\n        curr->endsHere += 1;\n    }\n    \n    /** Returns if the word is in the trie. */\n    bool search(string word) {\n        trienode* curr = root;\n        int index;\n        for(int i = 0; word[i] !='\\0'; i++)\n        {\n            index = word[i]-'a';\n            if(curr->child[index] == NULL)\n                return false;\n            curr = curr->child[index];\n        }\n        return (curr->endsHere > 0);\n    }\n    \n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    bool startsWith(string prefix) {\n        trienode* curr = root;\n        int index;\n        for(int i = 0; prefix[i] !='\\0'; i++)\n        {\n            index = prefix[i]-'a';\n            if(curr->child[index] == NULL)\n                return false;\n            curr = curr->child[index];\n        }\n        return (curr->count > 0);\n    }\n};\n\nint main()\n{\n    Trie* trie = new Trie();\n\n    trie->insert(\"apple\");\n    cout<< boolalpha <<trie->search(\"apple\")<<endl;   // returns true\n    cout<< boolalpha <<trie->search(\"app\")<<endl;     // returns false\n    cout<< boolalpha <<trie->startsWith(\"app\")<<endl; // returns true\n    trie->insert(\"app\");   \n    cout<< boolalpha <<trie->search(\"app\")<<endl;     // returns true\n    return 0;\n}class Solution {\npublic:\n    class TrieNode{\n    public:\n    TrieNode* next[2];\n    TrieNode(){\n        next[0] = NULL;\n        next[1] = NULL;\n    }\n};\n\nTrieNode* buildTrie(vector<int> & a){\n    TrieNode* root = new TrieNode();\n    int n = a.size();\n    for(int i = 0; i<n; i++){\n        int num = a[i];\n        TrieNode* cur = root;\n        for(int i = 31; i>=0; i--)\n        {\n            int bit = (num>>i)&1;\n            if(cur->next[bit]== NULL)\n                cur->next[bit] = new TrieNode();\n            cur = cur->next[bit];\n        }\n    }\n    return root;\n}\n\nint helper(TrieNode* root, vector<int> &a)\n{\n    int res = 0;\n    for(int i=0; i<a.size(); i++)\n    {\n        int num = a[i];\n        TrieNode* it = root;\n        int cur_max = 0;\n        for(int i = 31; i>=0; i--)\n        {\n            int bit = ((num>>i)&1)?0:1;\n            if(it->next[bit]){\n                cur_max<<=1;\n                cur_max |= 1;\n                it = it->next[bit];\n            }\n            else{\n                cur_max<<=1;\n                cur_max |= 0;\n                it = it->next[bit ? 0: 1];\n            }\n        }\n        res = max(res,cur_max);\n    }\n    return res;\n}\n    int findMaximumXOR(vector<int>& nums) {\n        TrieNode* root = buildTrie(nums);\n        return helper(root,nums);       \n    }\n};#include<iostream>\n#include<vector>\nusing namespace std;\nclass Trie{\n    public:\n    class node{\n        public:\n        bool end;\n        node* next[26];\n        node(){\n            end = false;\n            for(int i = 0; i< 26; i++)\n                next[i] = NULL;\n        }\n    };\n    node* trie;\n    Trie(){\n        trie = new node();\n    }\n    void insert(string word){\n        int i = 0;\n        node* it = trie;\n        while(i< word.size())\n        {\n            if(!it-> next[word[i]-'a'])\n                it -> next[word[i]-'a'] = new node();\n            it = it-> next[word[i]-'a'];\n            i++;\n        }\n        it->end = true;\n    }\n    bool search(string word){\n        int i = 0;\n        node* it = trie;\n        while(i< word.size())\n        {\n            if(!it->next[word[i]-'a'])\n                return false;\n            it = it-> next[word[i]-'a'];\n            i++;\n        }\n        return it->end;\n    }\n};\nint main(){\n    Trie* mytrie = new Trie();\n    vector<string> words = {\"agnik\",\"anik\",\"anamik\"};\n    for(auto word : words){\n        mytrie->insert(word);\n    }\n    cout<<boolalpha<<mytrie->search(\"agnik\")<<endl;\n    cout<<boolalpha<<mytrie->search(\"fuad\")<<endl;\n    return 0;\n}#include<iostream>\nusing namespace std;\n#include<algorithm>\n#include<vector>\n\nclass TrieNode{\n    public:\n    TrieNode* next[2];\n    TrieNode(){\n        next[0] = NULL;\n        next[1] = NULL;\n    }\n};\n\nTrieNode* buildTrie(vector<int> & a){\n    TrieNode* root = new TrieNode();\n    int n = a.size();\n    for(int i = 0; i<n; i++){\n        int num = a[i];\n        TrieNode* cur = root;\n        for(int i = 31; i>=0; i--)\n        {\n            int bit = (num>>i)&1;\n            if(cur->next[bit]== NULL)\n                cur->next[bit] = new TrieNode();\n            cur = cur->next[bit];\n        }\n    }\n    return root;\n}\n\nint helper(TrieNode* root, vector<int> &a)\n{\n    int res = 0;\n    for(int i=0; i<a.size(); i++)\n    {\n        int num = a[i];\n        TrieNode* it = root;\n        int cur_max = 0;\n        for(int i = 31; i>=0; i--)\n        {\n            int bit = ((num>>i)&1)?0:1;\n            if(it->next[bit]){\n                cur_max<<=1;\n                cur_max |= 1;\n                it = it->next[bit];\n            }\n            else{\n                cur_max<<=1;\n                cur_max |= 0;\n                it = it->next[bit ? 0: 1];\n            }\n        }\n        res = max(res,cur_max);\n    }\n    return res;\n}\nint main(){\n    vector<int> a = {2,5,6,78,5,3,5};\n    TrieNode* root = buildTrie(a);\n    cout<<helper(root,a)<<endl;\n    return 0;\n}#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <time.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\nusing namespace std;\n \n#define ll\t\t\t\tlong long int\n#define ld\t\t\t\tlong double\n#define mod \t\t\t1000000007\n#define inf \t\t\t1e18 \n#define ff              first\n#define ss              second\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump\t\t\t\tunordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\t\n \n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\nclass TopoSort{\npublic:\n  static vector<int> findOrder(int numCourses, vector<vector<int>>& edges) {\n        vector<int> sortedorder;\n     if(numCourses <= 0) {\n         cout<<\"IMPOSSIBLE\";\n        return vector<int>();\n     }\n    //initialization\n        unordered_map<int, int> indegree;\n        unordered_map<int, vector<int>> graph;\n        for(int i = 0; i< numCourses; i++)\n        {\n            indegree[i] = 0;\n            graph[i] = vector<int>();\n        }\n    //Build the graph\n    for(int i = 0; i<edges.size(); i++)\n    {\n        int parent = edges[i][0], child = edges[i][1];\n        graph[parent].push_back(child);\n        indegree[child]++;\n    }\n    queue<int> q;\n    for (auto i: indegree){\n        if(i.second == 0)\n            q.push(i.first);\n    }\n    while(!q.empty())\n    {\n        int vertex = q.front();\n        q.pop();\n        sortedorder.push_back(vertex);\n        vector<int> children= graph[vertex];\n        for(auto child: children)\n        {\n            indegree[child]--;\n            if(indegree[child] == 0)\n                q.push(child);\n        }\n    }\n    if (sortedorder.size() < numCourses){\n        cout<<\"IMPOSSIBLE\" ;\n        return vector<int>();\n    }\n    return sortedorder;\n    }\n};\nint main()\n{\n    file_i_o();\n    int n,m; // no of courses and requirements\n    cin>>n>>m;\n     vector<vector<int>> arr(m, vector<int>(2));\n     loop(i,0,m-1)\n     {\n         vector<int> temp;\n     \tloop(j,0,1)\n     \t{\n     \t\tint no;\n     \t\tcin>>no;\n     \t\ttemp.push_back(no);\n     \t}\n         arr.push_back(temp);\n         temp.clear();\n     }\n     vector<int> res = TopoSort::findOrder(n,arr);\n   for(auto num : res)\n     {\n     \tcout<<num<<\" \";\n     }\n    return 0;\n}/*By AGNIK SAHA */\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <time.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\nusing namespace std;\n \n#define ll\t\t\t\tlong long int\n#define ld\t\t\t\tlong double\n#define mod \t\t\t1000000007\n#define inf \t\t\t1e18 \n#define ff              first\n#define ss              second\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump\t\t\t\tunordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\n\n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n  \nint main()\n{\n    file_i_o();\n    int x;\n    cin>>x;\n    return 0;\n}/*By AGNIK SAHA */\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll\t\t\t\tlong long int\n#define ld\t\t\t\tlong double\n#define mod \t\t\t1000000007\n#define inf \t\t\t1e18 \n#define ff              first\n#define ss              second\n#define int             long long\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump\t\t\t\tunordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\t\n\n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n \nint32_t main()\n{\n    file_i_o();\n    int n,x;\n    cin>>n>>x;\n    vector<int>dp(x+1,0);\n    dp[0] = 1;\n    vector<int> coins(n);\n    loop(i,0,n-1) cin>>coins[i];\n    loop(i,1,x)\n    {\n    \tloop(j,0,n-1)\n    \t{\n    \t\tif(coins[j]>i) continue;\n    \t\tdp[i] = (dp[i]+dp[i-coins[j]])%mod;\n    \t}\n    }\n    cout<<dp[x]%mod;\n    return 0;\n   \n}/*By AGNIK SAHA */\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll\t\t\t\tlong long int\n#define ld\t\t\t\tlong double\n#define mod \t\t\t1000000007\n#define inf \t\t\t1e18 \n#define ff              first\n#define ss              second\n#define int             long long\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump\t\t\t\tunordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\t\n\n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n \nint32_t main()\n{\n    file_i_o();\n    int n,x;\n    cin>>n>>x;\n    vector<int>dp(x+1,0);\n    dp[0] = 1;\n    vector<int> coins(n);\n    loop(i,0,n-1) cin>>coins[i];\n    loop(j,0,n-1)\n    {\n      loop(i,1,x)\n      {\n        if(coins[j]>i) continue;\n        dp[i] = (dp[i]+dp[i-coins[j]])%mod;\n      }\n    }\n    cout<<dp[x]%mod;\n    return 0;\n}#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <iterator>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <limits>\n#include <time.h>\n#include <math.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\nusing namespace std;\n\n#define ll\t\t\t\tlong long int\n#define ld\t\t\t\tlong double\n#define mod \t\t\t1000000007\n#define inf \t\t\t1e18 \n#define ff              first\n#define ss              second\n#define int             long long\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump\t\t\t\tunordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\t\n\n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n  /*By AGNIK SAHA */\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll\t\t\t\tlong long int\n#define ld\t\t\t\tlong double\n#define mod \t\t\t1000000007\n#define inf \t\t\t1e18 \n#define ff              first\n#define ss              second\n#define int             long long\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump\t\t\t\tunordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\t\n\n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n \nint32_t main()\n{\n    file_i_o();\n    int n;\n    cin>>n;\n   \tvector<int> dp(n+1,0);\n   \tdp[0]=dp[1]=1;\n   \tloop(i,2,n)\n   \t{\n   \t\tloop(j,1,6)\n   \t\t{\n   \t\t\tif(j>i) continue;\n   \t\t\tdp[i] = (dp[i]+dp[i-j])%mod;\n   \t\t}\n   \t}\n   \tcout<<dp[n]%mod;\n   \treturn 0;\n}/*By AGNIK SAHA */\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll\t\t\t\tlong long int\n#define ld\t\t\t\tlong double\n#define mod \t\t\t1000000007\n#define inf \t\t\t1e18 \n#define ff              first\n#define ss              second\n#define int             long long\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump\t\t\t\tunordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\t\n\n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n\nvi getDigits(int n)\n{\n\tvi v;\n\twhile(n)\n\t{\n\t\tif(n%10 !=0)\n\t\t{\n\t\t\tv.pb(n%10);\n\t\t}\n\t\tn/=10;\n\t}\n\treturn v;\n}\n \nint32_t main()\n{\n    file_i_o();\n    int n;\n\tcin>>n;\n\tvector<int> dp(n+1, INT_MAX);\n\tloop(i, 1, 9) dp[i] = 1;\n\tloop(i, 10, n) {\n\t\tvi digits = getDigits(i);\n\t\tloop(j, 0, digits.size() - 1) {\n\t\t\tdp[i] = min(dp[i], 1+dp[i-digits[j]]);\n\t\t}\n\t}\n\tcout<<dp[n];\n    return 0;\n} /*By AGNIK SAHA */\n \n #include<bits/stdc++.h>\n using namespace std;\n \n #define ll\t\t\t\tlong long int\n #define ld\t\t\t\tlong double\n #define mod \t\t\t1000000007\n #define inf \t\t\t1e18 \n #define ff              first\n #define ss              second\n #define int             long long\n #define pb              push_back\n #define mp              make_pair\n #define pii             pair<int,int>\n #define ump\t\t\t\tunordered_map\n #define vi              vector<int>\n #define mii             map<int,int>\n #define pq_max          priority_queue<int>\n #define pq_min          priority_queue<int,vi,greater<int> >\n #define loop(i,a,b)\t\tfor(int i =(a); i<=(b); i++)\n #define loopprev(i,a,b) for(int i =(a); i<=(b); i--)\t\t\t\n \n  \n void file_i_o()\n {\n     ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n #ifndef ONLINE_JUDGE\n     freopen(\"input.txt\", \"r\", stdin);\n     freopen(\"output.txt\", \"w\", stdout);\n #endif\n }\n  \n int32_t main()\n {\n     file_i_o();\n     int n;\n     cin>>n;\n    // vector<vector<int>> arr(n, vector<int>(n,0));\n     int arr[n][n];\n     loop(i,0,n-1)\n     {\n     \tloop(j,0,n-1)\n     \t{\n     \t\tchar ch;\n     \t\tcin>>ch;\n     \t\tarr[i][j]= (ch == '.')?0:1;\n     \t}\n     }\n\n   // vector<vector<int>> dp(n, vector<int>(n,0));\n     int d[n][n];\n     loopprev(i,n-1,0)\n     {\n     \tloopprev(j,n-1,0)\n     \t{\n     \t\tif(i == n-1 && j == n-1 ) dp[i][j]= 1;\n     \t\telse \n     \t\t\t{\n     \t\t\t\tint op1 = (j==n-1)? 0 : dp[i][j+1];\n     \t\t\t\tint op2 = ( i==n-1 ) ? 0 : dp[i+1][j];\n     \t\t\t\tdp[i][j] = (op1+op2)%mod;\n\n     \t\t\t\tif(arr[i][j]) dp[i][j] = 0;\n     \t\t\t}\n     \t}\n     \n     }\n\n     if(arr[n-1][n-1]) cout<<0;\n     else cout<<dp[0][0];\n     return 0;\n }/*By AGNIK SAHA */\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll                long long int\n#define ld                long double\n#define mod             1000000007\n#define inf             1e18 \n#define ff              first\n#define ss              second\n#define int             long long\n#define pb              push_back\n#define mp              make_pair\n#define pii             pair<int,int>\n#define ump                unordered_map\n#define vi              vector<int>\n#define mii             map<int,int>\n#define pq_max          priority_queue<int>\n#define pq_min          priority_queue<int,vi,greater<int> >\n#define loop(i,a,b)        for(int i =(a); i<=(b); i++)\n#define loopprev(i,a,b) for(int i =(a); i<=(b); i--)            \n\n \nvoid file_i_o()\n{\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#ifndef ONLINE_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n#endif\n}\n \nint32_t main()\n{\n    file_i_o();\n    int n,x;\n    cin>>n>>x;\n    vector<int>dp(x+1,INT_MAX);\n    dp[0] = 0;\n    vector<int> coins(n);\n    loop(i,0,n-1) cin>>coins[i];\n    loop(i,1,x)\n    {\n        loop(j,0,n-1)\n        {\n            if(coins[j]>i) continue;\n            dp[i] = min(dp[i],1+dp[i-coins[j]]);\n        }\n    }\n    if(dp[x] == INT_MAX) cout<<-1;\n    else \n        cout<<dp[x];\n    return 0;\n}#include<algorithm>\nclass Solution {\npublic:\n    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency, int k) {\n      vector<pair<int, int>> eff_sp;\n        priority_queue <int, vector<int>, greater<int> > pq_speeds;\n        long sum = 0, res = 0;\n        for (auto i = 0; i < n; ++i)\n            eff_sp.push_back({efficiency[i], speed[i]});\n        sort(begin(eff_sp), end(eff_sp));\n        for (auto i = n - 1; i >= 0; --i) {\n            sum += eff_sp[i].second;\n            pq_speeds.push(eff_sp[i].second);\n            if (pq_speeds.size() > k) {\n                sum -= pq_speeds.top();\n                pq_speeds.pop();\n            }\n            res = max(res, sum * eff_sp[i].first);\n        }\n        return res % 1000000007;\n        \n    }\n};class Solution {\npublic:\n    bool static compare(vector<int> &x,vector<int> &y){\n        return (x[1]>y[1]);\n    }\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\n        int ans = 0;\n        sort(boxTypes.begin(), boxTypes.end(),compare);\n        for(int i = 0; i< boxTypes.size(); i++){\n            int boxCount = min(boxTypes[i][0],truckSize);\n            ans += (boxTypes[i][1]*boxCount);\n            truckSize -= boxCount;\n            if(truckSize==0) break;\n        }\n        return ans;\n    }\n};int Solution::candy(vector<int> &A) {\n    vector<int> l2r(A.size(),1);\n    vector<int> r2l(A.size(),1);\n    vector<int> res(A.size());\n    int sum = 0;\n    for(int i = 1;i<A.size();i++)\n    {\n        if(A[i]>A[i-1]) l2r[i]=1+l2r[i-1];\n    }\n    for(int i = A.size()-2;i>=0;i--)\n    {\n        if(A[i]>A[i+1]) r2l[i]=1+r2l[i+1];\n    }\n    for(int i = 0;i<A.size();i++)\n    {\n        res[i]= max(l2r[i],r2l[i]);\n    }\n    for(int i = 0;i<A.size();i++)\n    {\n        sum+=res[i];\n    }\n    return sum;\n}// Problem description: https://www.hackerrank.com/challenges/tree-huffman-decoding/problem\n\n// input: huffman encoded tree and encoded message\n//output: decoded string\n\n//\n//  main.cpp\n//  Huffman\n//\n//  Created by Vatsal Chanana\n\n#include<iostream>\nusing namespace std;\n\ntypedef struct node {\n    int freq;\n    char data;\n    node * left;\n    node * right;\n} node;\n\nstruct deref:public binary_function<node*, node*, bool> {\n  \tbool operator()(const node * a, const node * b)const {\n        return a->freq > b->freq;\n    }\n};\n\ntypedef priority_queue<node *, vector<node*>, deref> spq;\n\nnode * huffman_hidden(string s) {\n\n    spq pq;\n    vector<int>count(256,0);\n  \n    for(int i = 0; i < s.length(); i++ ) {\n        count[s[i]]++;\n    }\n    \n    for(int i=0; i < 256; i++) {\n        \n        node * n_node = new node;\n        n_node->left = NULL;\n        n_node->right = NULL;\n        n_node->data = (char)i;\n        n_node->freq = count[i];\n      \n        if( count[i] != 0 )\n        \tpq.push(n_node);\n      \n    }\n    \n    while( pq.size() != 1 ) {\n      \n        node * left = pq.top();\n        pq.pop();\n        node * right = pq.top();\n        pq.pop();\n        node * comb = new node;\n        comb->freq = left->freq + right->freq;\n        comb->data = '\\0';\n        comb->left = left;\n        comb->right = right;\n        pq.push(comb);\n      \n    }\n    \n    return pq.top();\n    \n}\n\nvoid print_codes_hidden(node * root, string code, map<char, string>&mp) {\n    \n  \tif(root == NULL)\n        return;\n    \n  \tif(root->data != '\\0') {\n        mp[root->data] = code;\n    }\n  \n    print_codes_hidden(root->left, code+'0', mp);\n    print_codes_hidden(root->right, code+'1', mp);\n        \n}\n\n\n\ntypedef struct node {\n\n\tint freq;\n    char data;\n    node * left;\n    node * right;\n    \n} node;\n\n\n\n\nvoid decode_huff(node * root, string s) {\n    node * p = root;\n    for(int i = 0 ; s[i]; i++) {\n\n        if(s[i] == '0') {\n            p = p->left;\n        }\n        else {\n            p = p->right;\n        }\n\n        if(p->left == NULL && p->right == NULL) {\n            cout<<p->data;\n            p = root;\n        }\n    }\n    cout<<endl;    \n}\n\nint main() {\n  \n    string s;\n    std::cin >> s;\n  \n    node * tree = huffman_hidden(s);\n    string code = \"\";\n    map<char, string>mp;\n  \n    print_codes_hidden(tree, code, mp);\n    \n    string coded;\n  \n    for( int i = 0; i < s.length(); i++ ) {\n        coded += mp[s[i]];\n    }\n    \n    decode_huff(tree,coded);\n  \n    return 0;\n}const int MOD = 1e9 + 7;\nclass Solution {\npublic:\n\n    int maximumGap( vector<int> &A) \n    {\n        if(A.size()<=1) return 0;\n        priority_queue<int> pq;\n        for(int i=0;i<A.size();i++){\n            pq.push(A[i]);\n        }\n        int mx=INT_MIN;\n        int x=pq.top();\n        pq.pop();\n        while(!pq.empty())\n        {\n            int y=pq.top();\n            pq.pop();\n            mx=max(mx,x-y);\n            x=y;\n        }\n        return mx;\n    }\n    int maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) {\n        // Find maximum consecutive difference\n        // then get the area\n        horizontalCuts.insert(horizontalCuts.begin(),0);\n        horizontalCuts.push_back(h);\n        verticalCuts.insert(verticalCuts.begin(),0);\n        verticalCuts.push_back(w);\n        long int a1 = maximumGap(horizontalCuts);\n        long int a2 = maximumGap(verticalCuts);\n        return (a1*a2)%MOD;\n    }\n};class Solution {\npublic:\n    bool areInterwoven(string one, string two, string three, int i, int j,vector<vector<int>> &cache)\n    {\n        if (cache[i][j] != -1)\n            return cache[i][j];\n        int k = i + j;\n        if (k == three.size())\n             return true;\n        if (i < one.size() && one[i] == three[k]) {\n                 cache[i][j] = areInterwoven(one, two, three, i + 1, j, cache);\n                 if (cache[i][j] == true)\n                         return true;\n                 }\n        if (j < two.size() && two[j] == three[k]) {\n              cache[i][j] = areInterwoven(one, two, three, i, j + 1, cache);\n                  return cache[i][j];\n        }\n        cache[i][j] = false;\n        return false;\n}\n    bool isInterleave(string one, string two, string three) {\n        if (three.size() != one.size() + two.size())\n        {\n            return false;\n         }\n        vector<vector<int>> cache(one.size()+1, vector<int>(two.size()+1,-1));\n\n         return areInterwoven(one, two, three, 0, 0, cache);\n        \n    }\n};\n\n\n\n\n\n\n// Recursive solution\nusing namespace std;\nbool areInterwoven(string one, string two, string three, int i, int j);\n// O(2^(n + m)) time | O(n + m) space - where n is the length\n// of the first string and m is the length of the second string\nbool interweavingStrings(string one, string two, string three) {\nif (three.size() != one.size() + two.size()) {\nreturn false;\n}\nreturn areInterwoven(one, two, three, 0, 0);\n}\nbool areInterwoven(string one, string two, string three, int i, int j) {\nint k = i + j;\nif (k == three.size())\nreturn true;\nif (i < one.size() && one[i] == three[k]) {\nif (areInterwoven(one, two, three, i + 1, j))\nreturn true;\n}\nif (j < two.size() && two[j] == three[k]) {\nreturn areInterwoven(one, two, three, i, j + 1);\n}\nreturn false;\n}class Solution {\npublic:\n    void solve(int open, int close,vector<string>& res, string op){\n        if(open == 0 && close == 0){\n            res.push_back(op);\n            return ;\n        }\n        if(open != 0)\n            solve(open-1,close,res,op+\"(\");\n        if(close > open)\n            solve(open,close-1,res,op+\")\");\n        return;\n    }\n    vector<string> generateParenthesis(int n) {\n        int open = n, close = n;\n        vector<string> res;\n        string op=\"\";\n        solve(open,close,res,op);  \n        return res;\n    }\n};class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        if(n == 1) return vector<int>{0,1};\n        vector<int>prev = grayCode(n-1);\n        \n        for(int i=prev.size()-1;i>=0;i--)\n            prev.push_back(prev[i]+pow(2,n-1));\n        \n        return prev;\n    }\n};//tower of hanoi\n#include<iostream>\nusing namespace std;\nvoid toh(int n,char src, char dest, char helper)\n{\n    if(n==0) return;\n    toh(n-1,src,helper,dest);\n    cout<<\"move from \"<<src<<\" to \"<<dest<<endl;\n    toh(n-1,helper,dest,src);\n}\nint main()\n{\n    toh(4,'A','C','B');\n}#include<iostream>\nusing namespace std;\nbool array_sorted(int arr[],int n)\n{\n    if(n==1) return true;\n    bool restArray = array_sorted(arr+1,n-1);\n    return (arr[0]<arr[1] && restArray);\n}\nint main(){\n    int arr[] = {2,4,9,6,8};\n    cout<<array_sorted(arr,8)<<endl;\n    return 0;\n}#include<iostream>\nusing namespace std;\nvoid print_decrease(int n)\n{\n    if(n==0){return;} \n    cout<<n<<\" \";\n    print_decrease(n-1);\n}\nint main()\n{\n    int n;\n    cin>>n;\n    \n    print_decrease(n);\n    \n}#include<iostream>\nusing namespace std;\nvoid print_inc(int n)\n{\n    if(n==1) {\n        cout<<\"1\"<<endl;\n        return ;\n    }\n    print_inc(n-1);\n    cout<<n<<endl;\n}\nint main()\n{\n    int n;\n    cin>>n;\n    print_inc(n);\n    return 0;\n}#include<iostream>\nusing namespace std;\nbool isSafe(int **arr, int x, int y,int n, int **solArr)\n{\n    if(x<n && y<n &&  arr[x][y] == 1 )\n    {\n        solArr[x][y] = 1;\n        return true;\n    }\n    return false;\n}\nbool ratInMaze(int **arr, int x, int y, int n, int**solArr)\n{\n    if(x == n-1 && y == n-1)\n    {\n        solArr[x][y] = 1;\n        return true;\n    }\n    if(isSafe(arr,x,y,n, solArr))\n    {\n        solArr[x][y] = 1; //choose\n        if(ratInMaze(arr,x+1,y,n,solArr)) return true;\n        if(ratInMaze(arr,x,y+1,n,solArr)) return true;\n        solArr[x][y] = 0;\n        return false;\n    }\n    return false;\n}\nint main()\n{\n    int n;\n    cin>>n;\n    int **arr = new int*[n];\n    for(int i = 0; i< n; i++)\n        arr[i] = new int[n];\n    for(int i = 0; i<n; i++)\n    {\n        for(int j = 0; j<n; j++)\n        {\n            cin>> arr[i][j];\n        }\n    }\n    int **solArr = new int*[n];\n    for(int i = 0; i< n; i++)\n    {\n        solArr[i] = new int[n];\n        for(int j=0; j<n; j++)\n            solArr[i][j]=0;\n    }\n    if(ratInMaze(arr,0,0,n,solArr))\n    {\n        for(int i = 0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                cout<< solArr[i][j]<<\" \";\n            }cout<<endl;\n        }\n    }\n    return 0;\n}\n/*\n1 0 1 0 1\n1 1 1 1 1 \n0 1 0 1 0\n1 0 0 1 1\n1 1 1 0 1\n*///given a string replace its all pi with 3.14\n//input: pippxxppiixipi\n#include<iostream>\nusing namespace std;\nvoid replacePI(string s)\n{\n    if(s.length() == 0) return ;\n    if(s[0] == 'p' && s[1] == 'i')\n    {\n        cout<<\"3.14\";\n        replacePI(s.substr(2));\n    }\n    else{\n        cout<<s[0];\n        replacePI(s.substr(1));\n    }\n}\nint main()\n{\n    string s = \"pippxxppiixipi\";\n    replacePI(s);\n}#include<iostream>\nusing namespace std;\nvoid reverse_string(string s)\n{\n    if(s.length() == 0) return;\n    string ros = s.substr(1);\n    reverse_string(ros);\n    cout<<s[0];\n\n}\nint main()\n{\n    string s = \"Agnik\";\n    reverse_string(s);\n    return 0;\n}//find firsr & last occurance of a number\n//return the index\n#include<iostream>\nusing namespace std;\n\nint first_ocur(int arr[],int n,int i, int key)\n{\n    if(i==n) return -1;\n    if(arr[i] == key) return i;\n    return first_ocur(arr,n,i+1,key);\n}\n\nint last_ocur(int arr[],int n,int i, int key)\n{\n    if(i==n) return -1; //base condition\n    int restArray = last_ocur(arr,n,i+1,key);\n    if(restArray != -1) return restArray;\n    if(arr[i] == key) return i;\n    return -1;\n}\nint main()\n{\n    int arr[]={5,7,3,4,2,3,1};\n    cout<<first_ocur(arr,7,0,3)<<endl;\n    cout<<last_ocur(arr,7,0,3)<<endl;\n    return 0;\n}#include<iostream>\n#include<vector>\nusing namespace std; \nvoid insert(vector<int> &v, int temp)\n{\n    if(v.size()==0 || v[v.size()-1]<=temp)\n    {\n        v.push_back(temp);\n        return;\n    }\n    int val = v[v.size()-1];\n    v.pop_back();\n    insert(v,temp);\n    v.push_back(val);\n    return;\n}\nvoid sortArr(vector<int> &v)\n{\n    if(v.size()==1) return;\n    int temp = v[v.size()-1];\n    v.pop_back();\n    sortArr(v);\n    insert(v,temp);\n}\nint main()\n{\n    vector<int> v={2,1,4,2,5,9,6};\n    sortArr(v);\n    for(int i : v)\n        cout<<i<<\" \";\n    return 0;\n}#include<iostream>\n#include<stack>\nusing namespace std; \nvoid insert(stack<int> &v, int temp)\n{\n    if(v.size()==0 || v.top() <=temp)\n    {\n        v.push(temp);\n        return;\n    }\n    int val = v.top();\n    v.pop();\n    insert(v,temp);\n    v.push(val);\n    return;\n}\nvoid sortStack(stack<int> &v)\n{\n    if(v.size()==1) return;\n    int temp = v.top();\n    v.pop();\n    sortStack(v);\n    insert(v,temp);\n}\nint main()\n{\n    stack<int> st;;\n    st.push(5);\n    st.push(2);\n    st.push(3);\n    st.push(4);\n    st.push(1);\n    sortStack(st);\n    while(!st.empty())\n    {\n        cout<<st.top()<<\" \";\n        st.pop();\n    }\n    return 0;\n}", "https://github.com/agnik2019/Deep_learning_with_pytorch": "!pip install torch\n !pip install transformer import numpy as np\n import pandas as pd\n import torch\n import torch.nn as nn\n from sklearn.model_selection import train_test_split\n from sklearn.metrics import classification_report\n import transformers\n from transformers import AutoModel, BertTokenizerFastdf = pd.read_csv(\"dataset_spam.csv\")\n df.head()# split train dataset into train, validation and test sets\n train_text, temp_text, train_labels, temp_labels = train_test_split(df['text'], df['label'], \n                                                                     random_state=2018, \n                                                                     test_size=0.3, \n                                                                     stratify=df['label'])\n \n \n val_text, test_text, val_labels, test_labels = train_test_split(temp_text, temp_labels, \n                                                                 random_state=2018, \n                                                                 test_size=0.5, \n                                                                 stratify=temp_labels)df.shape# check class distribution\n df['label'].value_counts(normalize = True)train_text, temp_text, train_labels, temp_labels = train_test_split(df['text'], df['label'], \n                                                                     random_state=2018, \n                                                                     test_size=0.3, \n                                                                     stratify=df['label'])\n \n # we will use temp_text and temp_labels to create validation and test set\n val_text, test_text, val_labels, test_labels = train_test_split(temp_text, temp_labels, \n                                                                 random_state=2018, \n                                                                 test_size=0.5, \n                                                                 stratify=temp_labels)# import BERT-base pretrained model\n bert = AutoModel.from_pretrained('bert-base-uncased')\n \n # Load the BERT tokenizer\n tokenizer = BertTokenizerFast.from_pretrained('bert-base-uncased')# sample data\n text = [\"this is a bert model tutorial\", \"we will fine-tune a bert model\"]\n \n # encode text\n sent_id = tokenizer.batch_encode_plus(text, padding=True, return_token_type_ids=False)# output\n print(sent_id)# import BERT-base pretrained model\n bert = AutoModel.from_pretrained('bert-base-uncased')\n \n # Load the BERT tokenizer\n tokenizer = BertTokenizerFast.from_pretrained('bert-base-uncased')# sample data\n text = [\"this is a bert model tutorial\", \"we will fine-tune a bert model\"]\n \n # encode text\n sent_id = tokenizer.batch_encode_plus(text, padding=True)\n \n # output\n print(sent_id)# get length of all the messages in the train set\n seq_len = [len(i.split()) for i in train_text]\n \n pd.Series(seq_len).hist(bins = 30)max_seq_len = 25# tokenize and encode sequences in the training set\n tokens_train = tokenizer.batch_encode_plus(\n     train_text.tolist(),\n     max_length = max_seq_len,\n     pad_to_max_length=True,\n     truncation=True,\n     return_token_type_ids=False\n )\n \n # tokenize and encode sequences in the validation set\n tokens_val = tokenizer.batch_encode_plus(\n     val_text.tolist(),\n     max_length = max_seq_len,\n     pad_to_max_length=True,\n     truncation=True,\n     return_token_type_ids=False\n )\n \n # tokenize and encode sequences in the test set\n tokens_test = tokenizer.batch_encode_plus(\n     test_text.tolist(),\n     max_length = max_seq_len,\n     pad_to_max_length=True,\n     truncation=True,\n     return_token_type_ids=False\n )# for train set\n train_seq = torch.tensor(tokens_train['input_ids'])\n train_mask = torch.tensor(tokens_train['attention_mask'])\n train_y = torch.tensor(train_labels.tolist())\n \n # for validation set\n val_seq = torch.tensor(tokens_val['input_ids'])\n val_mask = torch.tensor(tokens_val['attention_mask'])\n val_y = torch.tensor(val_labels.tolist())\n \n # for test set\n test_seq = torch.tensor(tokens_test['input_ids'])\n test_mask = torch.tensor(tokens_test['attention_mask'])\n test_y = torch.tensor(test_labels.tolist())from torch.utils.data import TensorDataset, DataLoader, RandomSampler, SequentialSampler\n \n #define a batch size\n batch_size = 32\n \n # wrap tensors\n train_data = TensorDataset(train_seq, train_mask, train_y)\n \n # sampler for sampling the data during training\n train_sampler = RandomSampler(train_data)\n \n # dataLoader for train set\n train_dataloader = DataLoader(train_data, sampler=train_sampler, batch_size=batch_size)\n \n # wrap tensors\n val_data = TensorDataset(val_seq, val_mask, val_y)\n \n # sampler for sampling the data during training\n val_sampler = SequentialSampler(val_data)\n \n # dataLoader for validation set\n val_dataloader = DataLoader(val_data, sampler = val_sampler, batch_size=batch_size)# freeze all the parameters\n for param in bert.parameters():\n     param.requires_grad = Falseclass BERT_Arch(nn.Module):\n     def __init__(self, bert):\n         super(BERT_Arch, self).__init__()\n         self.bert = bert \n       # dropout layer\n         self.dropout = nn.Dropout(0.1)\n       # relu activation function\n         self.relu =  nn.ReLU()\n       # dense layer 1\n         self.fc1 = nn.Linear(768,512)\n       # dense layer 2 (Output layer)\n         self.fc2 = nn.Linear(512,2)\n       #softmax activation function\n         self.softmax = nn.LogSoftmax(dim=1)\n         \n         \n     def forward(self, sent_id, mask):\n         _, cls_hs = self.bert(sent_id, attention_mask=mask, return_dict=False)\n         x = self.fc1(cls_hs)\n         x = self.relu(x)\n         x = self.dropout(x)\n         \n         # output layer\n         x = self.fc2(x)\n         #apply softmax activation\n         x = self.softmax(x)\n         \n         return x  # pass the pre-trained BERT to our define architecture\n model = BERT_Arch(bert)# optimizer from hugging face transformers\n from transformers import AdamW\n \n # define the optimizer\n optimizer = AdamW(model.parameters(), lr = 1e-3)from sklearn.utils.class_weight import compute_class_weight\n \n #compute the class weights\n class_wts = compute_class_weight('balanced', np.unique(train_labels), train_labels)\n \n print(class_wts)# convert class weights to tensor\n weights= torch.tensor(class_wts,dtype=torch.float)\n #weights = weights.to(device)\n \n # loss function\n cross_entropy  = nn.NLLLoss(weight=weights) \n \n # number of training epochs\n epochs = 10# function to train the model\n def train():\n   \n     model.train()\n \n     total_loss, total_accuracy = 0, 0\n   \n   # empty list to save model predictions\n     total_preds=[]\n   \n   # iterate over batches\n     for step,batch in enumerate(train_dataloader):\n     \n     # progress update after every 50 batches.\n         if step % 50 == 0 and not step == 0:\n               print('  Batch {:>5,}  of  {:>5,}.'.format(step, len(train_dataloader)))\n \n     # push the batch to gpu\n         #batch = [r.to(device) for r in batch]\n  \n         sent_id, mask, labels = batch\n \n     # clear previously calculated gradients \n         model.zero_grad()        \n \n     # get model predictions for the current batch\n         preds = model(sent_id, mask)\n \n     # compute the loss between actual and predicted values\n         loss = cross_entropy(preds, labels)\n \n     # add on to the total loss\n         total_loss = total_loss + loss.item()\n \n     # backward pass to calculate the gradients\n         loss.backward()\n \n     # clip the the gradients to 1.0. It helps in preventing the exploding gradient problem\n         torch.nn.utils.clip_grad_norm_(model.parameters(), 1.0)\n \n     # update parameters\n         optimizer.step()\n \n     # model predictions are stored on GPU. So, push it to CPU\n         preds=preds.detach().cpu().numpy()\n \n     # append the model predictions\n         total_preds.append(preds)\n \n   # compute the training loss of the epoch\n     avg_loss = total_loss / len(train_dataloader)\n   \n   # predictions are in the form of (no. of batches, size of batch, no. of classes).\n   # reshape the predictions in form of (number of samples, no. of classes)\n     total_preds  = np.concatenate(total_preds, axis=0)\n \n   #returns the loss and predictions\n     return avg_loss, total_preds# function for evaluating the model\n def evaluate():\n     print(\"\\nEvaluating...\")\n   \n   # deactivate dropout layers\n     model.eval()\n \n     total_loss, total_accuracy = 0, 0\n   \n   # empty list to save the model predictions\n     total_preds = []\n \n   # iterate over batches\n     for step,batch in enumerate(val_dataloader):\n     \n     # Progress update every 50 batches.\n         if step % 50 == 0 and not step == 0:     \n       # Calculate elapsed time in minutes.\n           elapsed = format_time(time.time() - t0)         \n       # Report progress.\n           print('  Batch {:>5,}  of  {:>5,}.'.format(step, len(val_dataloader)))\n \n     # push the batch to gpu\n     # batch = [t.to(device) for t in batch]\n \n     sent_id, mask, labels = batch\n \n     # deactivate autograd\n     with torch.no_grad():\n       \n       # model predictions\n         preds = model(sent_id, mask)\n \n       # compute the validation loss between actual and predicted values\n         loss = cross_entropy(preds,labels)\n \n         total_loss = total_loss + loss.item()\n \n         preds = preds.detach().cpu().numpy()\n \n         total_preds.append(preds)\n \n   # compute the validation loss of the epoch\n     avg_loss = total_loss / len(val_dataloader) \n \n   # reshape the predictions in form of (number of samples, no. of classes)\n     total_preds  = np.concatenate(total_preds, axis=0)\n \n     return avg_loss, total_preds# set initial loss to infinite\n best_valid_loss = float('inf')\n \n # empty lists to store training and validation loss of each epoch\n train_losses=[]\n valid_losses=[]\n \n #for each epoch\n for epoch in range(epochs):\n      \n     print('\\n Epoch {:} / {:}'.format(epoch + 1, epochs))\n     \n     #train model\n     train_loss, _ = train()\n     \n     #evaluate model\n     valid_loss, _ = evaluate()\n     \n     #save the best model\n     if valid_loss < best_valid_loss:\n         best_valid_loss = valid_loss\n         torch.save(model.state_dict(), 'saved_weights.pt')\n     \n     # append training and validation loss\n     train_losses.append(train_loss)\n     valid_losses.append(valid_loss)\n     \n     print(f'\\nTraining Loss: {train_loss:.3f}')\n     print(f'Validation Loss: {valid_loss:.3f}')#load weights of best model\n path = 'saved_weights.pt'\n model.load_state_dict(torch.load(path))", "https://github.com/agnik2019/Facial-Speech_Emotion-Detection": "", "https://github.com/agnik2019/Gender_Classification_flask": "import warnings\n warnings.filterwarnings('ignore')\n import numpy as np \n import pandas as pd\n import matplotlib.pyplot as plt\n from sklearn.decomposition import PCA\n %matplotlib inlinels datadata = np.load('./data/data_pca_50_y_mean.pickle.npz')\n data.filesX = data['arr_0']\n y = data['arr_1']\n mean = data['arr_2']from sklearn.model_selection import train_test_split\n x_train, x_test, y_train, y_test = train_test_split(X, y , test_size=0.2, stratify = y)\n x_train.shape, x_test.shape, y_train.shape, y_test.shape# Training a Machine Learning Modelfrom sklearn.svm import SVCmodel = SVC(C=1.0,kernel = 'rbf', gamma = 0.01, probability = True)model.fit(x_train,y_train)\n print(\"model trained successfully\")model.score(x_train, y_train)model.score(x_test, y_test)# Model Evaluation\n - Confusion Matrix\n - Classification Report\n - Kappa Score\n - ROC and AUC (probability)from sklearn import metrics\ny_pred = model.predict(x_test)\n y_prob = model.predict_proba(x_test)cm = metrics.confusion_matrix(y_test, y_pred)\n \n cm = np.concatenate((cm,cm.sum(axis=0).reshape(1,-1)), axis=0)\n \n cm = np.concatenate((cm,cm.sum(axis=1).reshape(-1,1)), axis=1)\n cmplt.imshow(cm)plt.imshow(cm)\n for i in range(3):\n     for j in range(3):\n         plt.text(i,j,'%d'%cm[i,j])\n     \n plt.xticks([0,1])\n plt.yticks([0,1])\n plt.xlabel('Predicted Values')\n plt.ylabel('True Values')\n plt.show()# Classification report\n cr = metrics.classification_report(y_test, y_pred, target_names=['male','female'], output_dict = True)crpd.DataFrame(cr).T# Kappa\n metrics.cohen_kappa_score(y_test, y_pred)# ROC and AUC# roc for female\n fpr, tpr, thresh = metrics.roc_curve(y_test, y_prob[:,1])\n auc_s = metrics.auc(fpr,tpr)\n \n plt.figure(figsize=(10,6))\n \n plt.plot(fpr,tpr,'--')\n plt.plot([0,1],[0,1],'b--')\n \n for i in range(0, len(thresh), 20):\n     plt.plot(fpr[i],tpr[i],'^')\n     plt.text(fpr[i], tpr[i],\"%0.2f\"%thresh[i])\n     \n plt.legend([\"AUC Score = %0.2f\"%auc_s])\n \n plt.xlabel('False Positive Rate')\n plt.ylabel('True Positive Rate')\n plt.title('Receiver Operating Characteristics')\n plt.show()# Hyper Parameter Tuningmodel_tune = SVC()from sklearn.model_selection import GridSearchCVparam_grid = {'C':[1,10,20,30,50,100],\n               'Kernel':['rbf','poly'],\n               'gamma':[0.1,0.05,0.01,0.001,0.002,0.005],\n               'coef0':[0,1],\n              }# GridSearchCV(model_tune, param_grid = param_grid,scoring='')# metrics.SCORERSmodel_grid = GridSearchCV(model_tune, param_grid = param_grid, scoring=\"accuracy\", cv=5, verbose=2)model_grid.fit(X,y)SVC().get_params().keys()SVC(C=10, kernel='rbf',gamma=\"0.1\")", "https://github.com/agnik2019/gmail_clone": "import React from 'react';\nimport Header from \"./Header\"\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from 'react-router-dom'\nimport Sidebar from \"./Sidebar\"\n\nimport './App.css';\nimport Mail from \"./Mail\";\nimport EmailList from \"./EmailList\";\n\n\nfunction App() {\n  return (\n<Router>\n    <div className=\"App\">\n      <Header />\n      <div className=\"app__body\">\n      <Sidebar />\n      <Switch>\n        <Route path=\"/mail\">\n          <Mail/>\n        </Route>\n        <Route path=\"/\">\n          <EmailList/>\n        </Route>\n     </Switch>\n     </div>\n    </div>\n    </Router>\n\n  );\n}\n\nexport default App;\nimport React from 'react'\nimport {Checkbox, IconButton} from \"@material-ui/core\"\nimport ArrowDropDownIcon from \"@material-ui/icons/ArrowDropDown\"\nimport RedoIcon from \"@material-ui/icons/Redo\"\nimport MoreVertIcon from \"@material-ui/icons/MoreVert\"\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft\"\nimport ChevronRightIcon from \"@material-ui/icons/ChevronRight\"\n\nimport KeyboardHideIcon from \"@material-ui/icons/KeyboardHide\"\n\nimport SettingsIcon from \"@material-ui/icons/Settings\"\nimport PeopleIcon from \"@material-ui/icons/People\"\n\nimport LocalOfferIcon from \"@material-ui/icons/LocalOffer\"\n\nimport InboxIcon from \"@material-ui/icons/Inbox\"\nimport Section from \"./Section\"\n\n\n\nimport \"./EmailList.css\"\nfunction EmailList() {\n    return (\n        <div className='emailList'>\n            <div className=\"emailList__settings\">\n                <div className=\"emailList__settingsLeft\">\n                    <Checkbox />\n                    <IconButton>\n                        <ArrowDropDownIcon/>\n                    </IconButton>\n                    <IconButton>\n                        <RedoIcon/>\n                    </IconButton>\n                    <IconButton>\n                        <MoreVertIcon/>\n                    </IconButton>\n   \n                </div>\n                <div className=\"emailList__settingsRight\">\n                <IconButton>\n                        <ChevronLeftIcon/>\n                    </IconButton>\n                    <IconButton>\n                        <ChevronRightIcon/>\n                    </IconButton>\n                    <IconButton>\n                        <KeyboardHideIcon/>\n                    </IconButton>\n                    <IconButton>\n                        <SettingsIcon/>\n                    </IconButton>\n                </div>\n                </div>\n                <div className=\"emailList__sections\">\n                    <Section Icon={InboxIcon} title=\"Primary\" color=\"red\" selected />\n                    <Section Icon={PeopleIcon} title=\"Social\" color=\"#1A73E8\"  />\n                    <Section Icon={LocalOfferIcon} title=\"Promotions\" color=\"green\"  />\n                \n            </div>\n            <div className=\"emailList__list\">\n                \n            </div>\n        </div>\n    )\n}\n\nexport default EmailList\nimport React from 'react'\nimport \"./EmailRow.css\"\nfunction EmailRow({id,title,subject, description, time}) {\n    return (\n        <div className=\"emailRow\">\n            <div className=\"emailRow__options\">\n\n            </div>\n            <div className=\"emailRow__title\">\n\n            </div>\n            <div className=\"emailRow__messeage\">\n\n            </div>\n            <div className=\"emailRow__description\">\n                \n            </div>\n            \n        </div>\n    )\n}\n\nexport default EmailRow\nimport React from 'react'\nimport \"./Header.css\"\nimport MenuIcon from '@material-ui/icons/Menu';\nimport {Avatar,IconButton } from '@material-ui/core'\nimport SearchIcon from '@material-ui/icons/Search';\nimport ArrowDropDownIcon from '@material-ui/icons/ArrowDropDown';\nimport AppsIcon from '@material-ui/icons/Apps';\nimport NotificationsIcon from '@material-ui/icons/Notifications';\n\nfunction Header() {\n    return (\n        <div className=\"header\">\n            <div className=\"header__left\">\n                <IconButton>\n                     <MenuIcon />\n                </IconButton>\n                <img src=\"http://i.pinimg.com/originals/ae/47/fa/ae47fa9a8fd263aa364018517020552d.png\"\n                alt=\"\" />\n\n            </div>\n            <div className=\"header__middle\">\n                <SearchIcon />\n                <input placeholder=\"Search mail\" type=\"text\" />\n                <ArrowDropDownIcon className=\"header__inputCaret\" /> \n\n            </div>\n            <div className=\"header__right\">\n            <IconButton>\n                     <AppsIcon />\n                </IconButton>\n                <IconButton>\n                     <NotificationsIcon />\n                </IconButton>\n                <Avatar />\n            </div>\n        </div>\n    )\n}\n\nexport default Header\nimport React from 'react'\nimport \"./Mail.css\"\n\nfunction Mail() {\n    return (\n        <div>\n            \n        </div>\n    )\n}\n\nexport default Mail\nimport React from 'react'\nimport \"./Section.css\"\n\nfunction Section({Icon, title, color, selected}) {\n    return (\n        <div className={`section ${selected && \"section--selected\"}`}\n        style={\n            {\n                borderBottom:`3px solid ${color}`,\n                color:`${selected && color}`\n            }\n        }> \n        \n        <Icon />\n        <h4>{title}</h4>\n            \n        </div>\n    )\n}\n\nexport default Section\nimport { Button, IconButton } from '@material-ui/core'\nimport React from 'react'\nimport \"./Sidebar.css\"\nimport AddIcon from \"@material-ui/icons/Add\"\nimport InboxIcon from \"@material-ui/icons/Inbox\"\nimport StarIcon from \"@material-ui/icons/Star\"\nimport AccessTimeIcon from \"@material-ui/icons/AccessTime\"\nimport NearMeIcon from \"@material-ui/icons/NearMe\"\nimport NoteIcon from \"@material-ui/icons/Note\"\nimport LabelImportantIcon from \"@material-ui/icons/LabelImportant\"\nimport ExpandMoreIcon from \"@material-ui/icons/ExpandMore\"\nimport SidebarOption from \"./SidebarOption\"\nimport PhoneIcon from \"@material-ui/icons/Phone\"\nimport DuoIcon from \"@material-ui/icons/Duo\"\nimport PersonIcon from \"@material-ui/icons/Person\"\n\n\n\n\nfunction Sidebar() {\n    return (\n        <div className=\"sidebar\">\n            <Button startIcon={<AddIcon \n            fontSize=\"large\" /> } className=\"sidebar__compose\" >\n           Compose</Button>\n\n           <SidebarOption Icon={InboxIcon} title=\"Inbox\" number={54} selected={true}/>\n           <SidebarOption Icon={StarIcon} title=\"Starred\" number={54} />\n           <SidebarOption Icon={AccessTimeIcon} title=\"Snoozed\" number={54} />\n           <SidebarOption Icon={LabelImportantIcon} title=\"Important\" number={54} />\n           <SidebarOption Icon={NearMeIcon} title=\"Sent\" number={54} />\n           <SidebarOption Icon={NoteIcon} title=\"Drafts\" number={54} />\n           <SidebarOption Icon={ExpandMoreIcon} title=\"More\" number={54} />\n            \n            <div className=\"sidebar__footer\">\n                <div className=\"sidebar__footerIcons\">\n                    <IconButton>\n                        <PersonIcon />\n                    </IconButton>\n                    <IconButton>\n                        <DuoIcon />\n                    </IconButton>\n                    <IconButton>\n                        <PhoneIcon />\n                    </IconButton>\n                </div>\n            </div>\n        </div>\n    \n    )\n}\n\nexport default Sidebar\nimport React from 'react'\nimport \"./SidebarOption.css\"\n\nfunction SidebarOption({Icon, title, number, selected }) {\n    return (\n        <div className={`sidebarOption ${selected && \"sidebarOption--active\"}`}>\n            <Icon />\n            <h3>{title}</h3>\n            <p>{number}</p>\n        </div>\n    )\n}\n\nexport default SidebarOption\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport store from './app/store';\nimport { Provider } from 'react-redux';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n// jest-dom adds custom jest matchers for asserting on DOM nodes.\n// allows you to do things like:\n// expect(element).toHaveTextContent(/react/i)\n// learn more: https://github.com/testing-library/jest-dom\nimport '@testing-library/jest-dom/extend-expect';\n", "https://github.com/agnik2019/healthcare_website": "const express = require('express')\nconst User = require('./models/User')\nconst Question = require('./models/Question') // includes our model\nconst Answers = require('./models/Answers')\nconst session = require(\"express-session\");\n\nconst app= express()\n\napp.set('views', './src/views');\n\n\napp.set(\"view engine\",\"ejs\")\n\napp.use(express.static(__dirname + '/public'));\napp.use(express.urlencoded({\n    extended: true\n  }));\n\napp.use(session({secret:\"notagoodsecret\", resave:true, saveUninitialized:true}));\n\nconst requireLogin = (req,res,next) => {\n    if(!req.session.user_id){\n        return res.redirect('/login')\n    }\n    next();\n }\n \n\n\n  app.get('/', (req, res) => {\n    try{\n       res.render('diagnosis1.ejs')\n    }\n    catch(err){\n        console.log(err);\n    }\n})\napp.get('/patient_dashboard', requireLogin,(req, res) => {\n    try{\n       res.render('patientDash.ejs')\n    }\n    catch(err){\n        console.log(err);\n    }\n})\n\napp.get('/register', (req, res) => {\n    try{\n        res.render('register.ejs')\n     }\n     catch(err){\n         console.log(err);\n     }\n});\napp.post('/register', async( req, res) => {\n    try{\n    const {password, username, email} = req.body;\n    const user = new User({username, password, email});\n    await user.save();\n    req.session.user_id = user._id;\n    res.redirect('/patient_dashboard');\n    }\n    catch {\n        res.redirect(\"/error\")\n    }\n});\n\napp.get('/login', (req,res) => {\n    res.render('login')\n });\n\n app.get('/error', (req, res) => {\n    try{\n    res.render('error');\n    }\n    catch(err){\n        console.log(err)\n    }\n});\n\n app.post('/login', async(req,res) => {\n     try{\n    const {username, password} = req.body;\n    const foundUser = await User.findAndValidate(username, password)\n    if(foundUser){\n        req.session.user_id = foundUser._id;\n        res.redirect('/patient_dashboard');\n    } else {\n        res.redirect(\"/error\")\n    }} catch{\n        res.redirect(\"/error\")\n    }\n });\n\n app.post('/logout',(req,res) => {\n    req.session.user_id = null;\n    res.redirect('/login')\n });\n\n app.get('/diagnosis', requireLogin,(req, res) => {\n    try{\n       res.render('diagnosis.ejs')\n    }\n    catch(err){\n        console.log(err);\n    }\n});\napp.get('/meoryou',requireLogin, (req, res) => {\n    try{\n       res.render('meoryou.ejs')\n\n    }\n    catch(err){\n        console.log(err);\n    }\n})\napp.get('/patient',requireLogin, (req, res) => {\n    try{\n       res.render('patient.ejs')\n    }\n    catch(err){\n        console.log(err);\n    }\n})\napp.get('/Symptoms',requireLogin, (req, res) => {\n    try{\n       res.render('Symptoms.ejs');\n    }\n    catch(err){\n        console.log(err);\n    }\n});\n\napp.get('/ques',requireLogin, async  (req, res)  => {   \n    await Question.find({}, function (err, allDetails) {\n        if (err) {\n            console.log(err);\n        } else {\n            res.render(\"ques\", { details: allDetails })\n        }\n})\n});\n\napp.get('/Result',requireLogin,function (req, res)\n {   \n    Answers.find({\"response\" : { $ne : null}}, function (err, allDetails) {\n        if (err) {\n            console.log(err);\n        } else {\n            //console.log(allDetails)\n            res.render(\"Result\", {response: allDetails })\n        }\n})\n });\n\n app.post('/Result', async(req, res) => {\n    // console.log(req.body);\n   try {\n    const { response } = req.body;\n    const answer = await Answers.create({\n        response\n    })\n   return res.render('Result2',{response})\n} catch (error) {\n    return res.status(500).json({\"error\":error})\n}\n})\n\n\n\n\nmodule.exports = appconst express = require('express')\nconst app = express()\nconst mongoose = require('mongoose')\nconst routes = require('./routes') // includes the routes.js file\n\nconst User = require('./models/User');\n\nconst dburl = \"mongodb+srv://agnik:NyPH2Iwsdz7slgDe@cluster0.se5mx.mongodb.net/<dbname>?retryWrites=true&w=majority\";\n\napp.use(express.json()) // we need to tell server to use json as well\napp.use(routes) // tells the server to use the routes in routes.js\n\nmongoose.connect(dburl, {\n  useNewUrlParser: true,\n  useCreateIndex: true,\n  useUnifiedTopology: true,\n  useFindAndModify: false\n});\n\nconst db = mongoose.connection;\ndb.on(\"error\", console.error.bind(console, \"connection error:\"));\ndb.once(\"open\", () => {\n  console.log(\"Database connected\");\n});\n\n\n\n\nconst port = process.env.PORT || 9000;\n\napp.listen(port, () => {\n    console.log(\"The api is running...\")\n})const lib = require('../lib');\n/*\ntest('Our first test', ()=> {\n    //throw new Error('Something failed');\n})\n*/\ndescribe('registerUser', ()=> {\n    it('should throw error if username is falsy', ()=> {\n        const args = [null, undefined, NaN, '', 0, false]; \n        args.forEach( a => {\n            expect(()=>{lib.registerUser(a)}).toThrow();\n        });\n    });\n    it('should return a user object if valid username is passed', ()=> {\n        const result = lib.registerUser('agnik');\n        expect(result).toMatchObject({username:'agnik'});\n        expect(result.id).toBeGreaterThan(0);\n    });\n});", "https://github.com/agnik2019/ImageCaptionGenerator": "# Steps\n 1. data collection\n 2. Understanding the data\n 3. Data cleaning\n 4. Loading the training set\n 5. Data preprocessing - images\n 6. Data preprocessing - Captions\n 7. Data preparation using Generator Function\n 8. Word Embeddings\n 9. Model Architecture\n 10. Inference\n 11. Evaluation!pip install tensorflow!pip install kerasimport pandas as pd\n import numpy as np\n import matplotlib.pyplot as plt\n import keras\n import re\n import nltk\n import string\n import json\n from time import time\n import pickle\n from keras.applications.vgg16 import VGG16\n from keras.applications.resnet50 import ResNet50, preprocess_input, decode_predictions\n from keras.preprocessing import image\n from keras.models import Model, load_model\n from keras.preprocessing.sequence import pad_sequences\n from keras.utils import to_categorical\n from keras.layers import Input,Dense,Dropout,Embedding, LSTM\n from keras.layers.merge import add\n#read text caption\n \n def readTextFile(path):\n     with open(path) as f:\n         captions = f.read() #readline to read each line\n     return captions\n         captions = readTextFile(\"flickr_dataset/Flickr8k_text/Flickr8k.token.txt\")\n captions = captions.split(\"\\n\")[:-1]\n #len(captions.split(\"\\n\"))  --> 40461len(captions)captions[-1]captions[0]first, second = captions[0].split(\"\\t\")\n print(first.split(\".\")[0])\n print(second)print(captions[2])descriptions = {}\n \n for i in range(0,40460):\n     first, second = captions[i].split(\"\\t\")\n     img_name = first.split(\".\")[0]\n     \n     #if the image id is already present or not\n     if descriptions.get(img_name) is None:\n         descriptions[img_name] = []\n         \n     descriptions[img_name].append(second)descriptions[\"1000268201_693b08cb0e\"]!pip3 install opencv-pythonIMG_PATH = \"flickr_dataset/Flicker8k_Dataset/\"\n \n import cv2\n from matplotlib import pyplot as plt\n \n img = cv2.imread(IMG_PATH+\"1000268201_693b08cb0e.jpg\")\n cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n plt.imshow(img)\n plt.show()# data cleaningdef clean_text(sentence):\n     sentence = sentence.lower()\n     sentence = re.sub(\"[^a-z]\",\" \", sentence)\n     sentence = sentence.split()\n     \n     sentence = [s for s in sentence if len(s)>1]\n     sentence = \" \".join(sentence)\n     return sentence\n     clean_text(\"A cat is sitting over the house number 64\")#clean all captions\n for key, caption_list in descriptions.items():\n     for i in range(len(caption_list)):\n         caption_list[i] = clean_text(caption_list[i])descriptions[\"1000268201_693b08cb0e\"]# write the data to text file\n with open(\"descriptions_1.txt\",\"w\") as f:\n     f.write(str(descriptions))# Vocabulary\n (set of all unique words model can predict)descriptions = None\n with open(\"descriptions_1.txt\",\"r\") as f:\n     descriptions= f.read()\n     \n json_acceptable_string = descriptions.replace(\"'\",\"\\\"\")\n descriptions = json.loads(json_acceptable_string)print(type(descriptions))# Vocab\n vocab = set()\n for key in descriptions.keys():\n     [vocab.update(sentence.split()) for sentence in descriptions[key]]\n     \n print(\"Vocab Size : %d\"% len(vocab))\n     total_words = []\n \n for key in descriptions.keys():\n     [total_words.append(i) for des in descriptions[key] for i in des.split()]\n     \n print(\"Total words %d\"%len(total_words))import collections\n \n counter = collections.Counter(total_words)\n freq_cnt = dict(counter)\n print(len(freq_cnt.keys()))#sort the dictionary according to the freq count\n sorted_freq_cnt = sorted(freq_cnt.items(), reverse=True, key= lambda x:x[1])\n \n #Filter\n threshold = 10\n sorted_freq_cnt = [x for x in sorted_freq_cnt if x[1]>threshold]\n total_words = [x[0] for x in sorted_freq_cnt]#sorted_freq_cnt\n '''\n [('in', 18987),\n  ('the', 18420),\n  ('on', 10746),\n  ('is', 9345),\n  ('and', 8863),\n  ('dog', 8138),\n  ('with', 7765),\n  ('man', 7275),.............]\n  '''# prepare train/test datatrain_file_data = readTextFile(\"flickr_dataset/Flickr8k_text/Flickr_8k.trainImages.txt\")\n test_file_data = readTextFile(\"flickr_dataset/Flickr8k_text/Flickr_8k.testImages.txt\")print(train_file_data[10])train = [row.split(\".\")[0] for row in train_file_data.split(\"\\n\")[:-1]]\n test = [row.split(\".\")[0] for row in test_file_data.split(\"\\n\")[:-1]]\n \n print(train[:5])\n # print(test[:-10])train_descriptions= {}\n \n for img_id in train:\n     train_descriptions[img_id] = []\n     for cap in descriptions[img_id]:\n         cap_to_append =\"startseq \"+cap+\" endseq\"\n         train_descriptions[img_id].append(cap_to_append)\n         train_descriptions[\"1000268201_693b08cb0e\"]# Transfer Learning\n \n images --> Features\n Text ----> Features\n \n ## Step 1 Image Feature Extraction\nmodel = ResNet50(weights=\"imagenet\", input_shape=(224,224,3))\n model.summary()# resnet --> extract features\n model.layers[-2]model.layers[-2].outputmodel_new = Model(model.input, model.layers[-2].output)def preprocess_img(img):\n     img = image.load_img(img, target_size=(224,224))\n     img = image.img_to_array(img)\n     img = np.expand_dims(img, axis = 0)\n     # Normalisation\n     img = preprocess_input(img)\n     return imgimg = preprocess_img(IMG_PATH+\"1000268201_693b08cb0e.jpg\")\n plt.imshow(img[0])\n plt.axis(\"off\")\n plt.show()\n # print(img)def encode_img(img):\n     img = preprocess_img(img)\n     feature_vector = model_new.predict(img)\n     feature_vector = feature_vector.reshape((-1,))\n     #print(feature_vector.shape)\n     return feature_vectorencode_img(IMG_PATH+\"1000268201_693b08cb0e.jpg\")start = time()\n encoding_train = {}\n #image_id ---> feature_vector extracted from Resnet Image\n for ix, img_ig in enumerate(train):\n     img_path = IMG_PATH+\"/\"+img_id+\".jpg\"\n     encoding_train[img_id] = encode_img(img_path)\n     \n     if ix%100==0 :\n         print(\"Encoding in Progress Time step %d \"%ix)\n end_t = time()\n print(\"Total time taken :\", end_t - start)\n#store every thing to the disk\n with open(\"encoded_train_features.pk1\",\"wb\") as f:\n     pickle.dump(encoding_train, f)start = time()\n encoding_test = {}\n #image_id ---> feature_vector extracted from Resnet Image\n for ix, img_ig in enumerate(test):\n     img_path = IMG_PATH+\"/\"+img_id+\".jpg\"\n     encoding_test[img_id] = encode_img(img_path)\n     \n     if ix%100==0 :\n         print(\"Test Encoding in Progress Time step %d \"%ix)\n end_t = time()\n print(\"Total time taken(test) :\", end_t - start)\n#store every thing to the disk\n with open(\"encoded_test_features.pk1\",\"wb\") as f:\n     pickle.dump(encoding_test, f)### Data Pre-processing for Captions# Vocab\n len(total_words)word_to_idx = {}\n idx_to_word = {}\n \n for i,word in enumerate(total_words):\n     word_to_idx[word] = i+1\n     idx_to_word[i+1] = word\n     word_to_idx[\"dog\"]\n idx_to_word[1]\n print(len(idx_to_word))idx_to_word[1846] = 'startseq'\n word_to_idx['startseq'] = 1846\n \n idx_to_word[1847] = 'endseq'\n word_to_idx['endseq'] = 1847\n \n vocab_size = len(word_to_idx)+1\n print(\"Vocab Size\", vocab_size)max_len = 0\n for key in train_descriptions.keys():\n     for cap in train_description[key]:\n         max_len = max(max_len, len(cap.split()))\n         \n print(max_len)    ", "https://github.com/agnik2019/image_caption_generator": "", "https://github.com/agnik2019/intagram_clone-Firebase-kotlin-": "", "https://github.com/agnik2019/LEARN_NODEJS_THE_HARD_WAY": "const chalk = require('chalk');\nconst yargs = require('yargs')\nconst notes = require(\"./notes.js\");\n/*\nconst msg = getNotes();\nconsole.log(msg);\n\nconst greenMsg = chalk.blue.inverse.bold(\"Success!\")\nconsole.log(greenMsg)\n\nconsole.log(process.argv);\n*/\n//add , remove, read, list\n\n// Create add command\nyargs.command({\n    command:'add',\n    describe:'Add a new note',\n    builder:{\n        title:{\n            describe:\"Note title\",\n            demandOption: true,\n            type:'string'\n        },\n        body:{\n            describe:\"Note body\",\n            demandOption: true,\n            type:'string'\n        }\n    },\n    handler: function(argv){\n        // console.log('Title: '+argv.title)\n        // console.log('Body: '+argv.body)\n        notes.addNote(argv.title, argv.body)\n    }\n})\n\n// create remove command\nyargs.command({\n    command:'remove',\n    describe:\"remove a note\",\n    handler: function(){\n        console.log('Removing the note...')\n    }\n})\n\nyargs.command({\n    command:'list',\n    describe:\"listing out notes\",\n    handler: function(){\n        console.log('listing out note...')\n    }\n})\n\nyargs.command({\n    command:'read',\n    describe:\"read a note\",\n    handler: function(){\n        console.log('Reading the note...')\n    }\n})\n\nyargs.parse()\n//console.log(yargs.argv);\n/*\n\nconst command = process.argv[2]\n\nif(command === 'add'){\n    console.log(\"Adding note!!\");\n} else if(command === 'remove'){\n    console.log(\"Removing note!\")\n}\n\n*/const fs = require('fs');\nconst getNotes = function(){\n    return \"Your notes....\"\n};\n\nconst addNote = function(title,body){\n    const notes = loadNotes();\n    const duplicateNotes = notes.filter(function(note){\n        return note.title === title\n    })\n\n    if(duplicateNotes.length=== 0)\n    {\n        notes.push({\n            title:title,\n            body:body\n        })\n        saveNotes(notes)\n        console.log(\"New note added!!!\")\n    } else {\n        console.log(\"Note title taken!!\")\n    }\n    \n}\n\nconst saveNotes = function(notes){\n    const dataJSON = JSON.stringify(notes);\n    fs.writeFileSync('notes.json',dataJSON);\n}\n\nconst loadNotes = function(){\n    try{\n        const dataBuffer = fs.readFileSync('notes.json')\n        const dataJson = dataBuffer.toString();\n        return JSON.parse(dataJson);\n    } catch(e){\n        return [];\n    }\n\n}\n\nmodule.exports = {\n    getNotes:getNotes,\n    addNote:addNote\n}const fs = require('fs')\n\n\nconst dataBuffer = fs.readFileSync('1-json.json')\nconst dataJSON = dataBuffer.toString()\nconst user = JSON.parse(dataJSON)\n\nuser.name = \"Andrew\"\nuser.age=33\n\nconst userJSON = JSON.stringify(user)\nfs.writeFileSync('1-json.json',userJSON);// setTimeout(()=>{\n//     console.log(\"Two seconds are up!!!\")\n// },2000);\n\n\n// const names = ['Andrew','Jen','Jess']\n// const shortNames = names.filter((name)=> {\n//     return name.length<= 4;\n// })\n\n// const geocode = (address,callback) => {\n//     setTimeout(()=> {\n//     const data = {\n//         latitude:0,\n//         longitude:0\n//     }\n//     callback(data);\n// },2000)\n// }\n// geocode('Narayanganj',(data)=> {\n//         console.log(data);\n// });\n\n\n\nconst add = (num1,num2, callback) =>{\n    setTimeout(()=> {\n        let sum = num1+num2;\n        callback(sum);\n        },2000)\n}\n\nadd(1,4, (sum) => {\n    console.log(sum)  // should print 5\n})/*\n// Object property Shorthand\n\nconst name = 'Agnik'\nconst userAge = 22;\n\nconst user = {\n    name,  //name : name   --> object shorthand property\n    age: userAge,\n    location:'Kolkata'\n};\n\nconsole.log(user)\n\n\n// Object destructuring\n\nconst product = {\n    label : 'Red notebook',\n    price: 3,\n    stock: 201,\n    salePrice: undefined\n}\n// const label = product.label;\n// const stock = product.stock;\n//const {label:productlabel, stock, rating=5} = product;  // rename the variable\n\n// console.log(productlabel);\n// console.log(stock)\n// console.log(rating)\n\n*/\n\nconst transaction = (type, {label, price=0} = {}) => {\n    console.log(type, label, price)\n}\n//transaction('order', product)\ntransaction('order');\nconst greeter = (name = 'User') => {\n    console.log('hello '+name);\n}\ngreeter('Agnik')\ngreeter();const bcrypt = require('bcrypt');\n\nasync function run(){\n    \n    console.log(salt);\n    console.log(hashed);\n}\n\nrun();require('express-async-errors');\nconst error = require('./middleware/error');\nconst config = require('config');\nconst Joi = require('joi');\nJoi.objectId = require('joi-objectid')(Joi);\nconst mongoose = require('mongoose');\nconst genres = require('./routes/genres');\nconst customers = require('./routes/customers');\nconst movies = require('./routes/movies');\nconst rentals = require('./routes/rentals');\nconst users = require('./routes/users');\nconst auth = require('./routes/auth')\nconst express = require('express');\nconst app = express();\n\nif(!config.get('jwtPrivateKey')){\n  console.error(\"FATAL ERROR: jwtPrivateKey is not defined\");\n  process.exit(1);\n}\n\nmongoose.connect('mongodb://localhost/vidly')\n  .then(() => console.log('Connected to MongoDB...'))\n  .catch(err => console.error('Could not connect to MongoDB...'));\n\napp.use(express.json());\napp.use('/api/genres', genres);\napp.use('/api/customers', customers);\napp.use('/api/movies', movies);\napp.use('/api/rentals', rentals);\napp.use('/api/users',users);\napp.use('/api/auth', auth);\n\napp.use(error);\n\nconst port = process.env.PORT || 3000;\napp.listen(port, () => console.log(`Listening on port ${port}...`));const geocode = require('./utils/geocode');\nconst forecast = require('./utils/forecast');\n\n\n// const url =\"http://api.weatherstack.com/current?access_key=3a97ca219bae8fcff391e93a56ed6ecb&query=37.8267,-122.4233\"\n\n// request({ url : url,json: true},(error,response)=>{\n//     if(!error){\n//     console.log(response.body.current.weather_descriptions[0]+\". It is currently \"+response.body.current.temperature+\" and Real feel is \"+response.body.current.feelslike);\n//     } else if(response.body.error){\n//         console.log(\"unable to find location\")\n//     }\n//     else{\n//         console.log(\"unable to connect to weather services \");\n//     }\n// })\n\n// Print the lat/long for Los Angeles\n\n\n// const geocodingURL = \"https://api.mapbox.com/geocoding/v5/mapbox.places/Los%20Angeles.json?access_token=pk.eyJ1IjoiYWduaWtzYWhhIiwiYSI6ImNraDUweGlrdzA0aGcyc3J6Z2Y0NzNpZnEifQ.9fbu4DY4MCS8G3oDtO7blA\";\n// request({ url : geocodingURL,json: true},(error,response)=>{\n//     if(error){\n//         console.log(\"unable to connect weather services \")\n//     } else if(response.body.features.length === 0){\n//         console.log(\"Unable to find location. Try another Search\")\n//     } else {\n//         const latitude = response.body.features[0].center[1];\n//         const longitude = response.body.features[0].center[0]\n//         console.log(\"lattitude: \"+latitude+\" longitude: \"+longitude)\n//     }\n// })\n\n// geocode('Dhaka', (error,data)=> {\n//     console.log('Error', error);\n//     console.log('Data',data);\n// });\n\n// forecast(23.784506,90.403409, (error,data) => {\n//     console.log('Error',error);\n//     console.log('Data', data);\n// })\nconst address = process.argv[2];\n\nif(!address){\n    console.log('Please provide an address');\n} else {\ngeocode(address, (error,{latitude, longitude, location} = {})=> {\n    if(error){\n        return console.log(error);\n    } \n\n    forecast(latitude,longitude, (error,forecastdata) => {\n        if(error){\n            return console.log(error);\n        } \n        console.log(location);\n        console.log(forecastdata);\n    })\n});\n}\n\n\n", "https://github.com/agnik2019/Learn_React_the_hard_way": "", "https://github.com/agnik2019/LinkedIn_Clone": "404: Not Found", "https://github.com/agnik2019/Linked_In_Full_stack_clone": ""}